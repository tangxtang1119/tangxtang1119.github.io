<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="‘有志少女 先读书’" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CTF |  tangxtang</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CTF"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CTF
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/04/26/CTF/" class="article-date">
  <time datetime="2025-04-25T16:00:00.000Z" itemprop="datePublished">2025-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">53 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="赛事介绍"><a href="#赛事介绍" class="headerlink" title="赛事介绍"></a>赛事介绍</h1><p>CTF（Capture The Flag），中文称为夺旗赛，是网络安全领域中一种备受关注和欢迎的竞赛形式。</p>
<h2 id="竞赛模式"><a href="#竞赛模式" class="headerlink" title="竞赛模式"></a>竞赛模式</h2><p>CTF 竞赛主要有以下几种模式：</p>
<h4 id="解题模式（Jeopardy）"><a href="#解题模式（Jeopardy）" class="headerlink" title="解题模式（Jeopardy）"></a><strong>解题模式（Jeopardy）</strong></h4><p>这是最常见的 CTF 模式。<br>比赛中会设置一系列不同类型和难度的题目，涵盖密码学、Web 安全、逆向工程、漏洞挖掘等多个领域。<br>每个题目对应一个分值，参赛队伍通过解题获取 Flag 并提交来得分。<br>比赛结束时，根据各队的总得分进行排名。</p>
<h4 id="攻防模式（Attack-Defense）"><a href="#攻防模式（Attack-Defense）" class="headerlink" title="攻防模式（Attack-Defense）"></a>攻防模式（Attack-Defense）</h4><p>参赛队伍在相互竞争的环境中进行攻击和防御。<br>每个队伍拥有自己的服务或系统需要防守，同时要尝试攻击其他队伍的服务来获取分数。<br>成功攻击其他队伍可得分，自己防守成功避免被攻击也能得分。<br>比赛过程中，分数实时变化，最终以比赛结束时的总分决定胜负。</p>
<h4 id="混合模式（Mix）"><a href="#混合模式（Mix）" class="headerlink" title="混合模式（Mix）"></a>混合模式（Mix）</h4><p>结合了解题模式和攻防模式的特点。<br>例如，先通过解题获得一定的初始分数，然后进入攻防阶段，根据攻防的表现来增减分数。</p>
<h4 id="靶场模式（Ranges）"><a href="#靶场模式（Ranges）" class="headerlink" title="靶场模式（Ranges）"></a>靶场模式（Ranges）</h4><p>提供一个模拟的网络环境或系统作为靶场。<br>参赛队伍需要在这个环境中发现漏洞、解决问题，并获取 Flag。<br>重点考察选手在实际场景中的渗透测试和漏洞修复能力。</p>
<h4 id="AWD-模式（Attack-With-Defense）"><a href="#AWD-模式（Attack-With-Defense）" class="headerlink" title="AWD 模式（Attack With Defense）"></a>AWD 模式（Attack With Defense）</h4><p>类似于攻防模式，但更强调实时性和连续性。<br>参赛队伍在攻击其他队伍的同时，要随时应对自己系统遭受的攻击并进行防御和修复。</p>
<p>不同的 CTF 竞赛模式各有特点，对参赛队伍的技术能力、团队协作和策略规划都有不同的要求。</p>
<h2 id="CTF各大题型简介"><a href="#CTF各大题型简介" class="headerlink" title="CTF各大题型简介"></a>CTF各大题型简介</h2><p>以下是 CTF 常见的各大题型的简介：</p>
<h4 id="密码学（Crypto）"><a href="#密码学（Crypto）" class="headerlink" title="密码学（Crypto）"></a>密码学（Crypto）</h4><p>涉及各种加密算法的分析和破解，包括对称加密（如 AES）、非对称加密（如 RSA）、哈希函数（如 MD5、SHA-256）等。<br>可能需要从密文或加密过程中推导出明文、找出密钥，或者验证数字签名的正确性。</p>
<h4 id="Web-安全（Web）"><a href="#Web-安全（Web）" class="headerlink" title="Web 安全（Web）"></a>Web 安全（Web）</h4><p>主要针对网站和 Web 应用程序的安全漏洞进行挖掘和利用。<br>常见的漏洞类型有 SQL 注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、文件包含漏洞、命令执行漏洞等。</p>
<h4 id="逆向工程（Reverse）"><a href="#逆向工程（Reverse）" class="headerlink" title="逆向工程（Reverse）"></a>逆向工程（Reverse）</h4><p>对给定的二进制文件、可执行程序或恶意软件进行分析和反编译。<br>目的是理解其工作原理、找出隐藏的逻辑、提取关键信息或破解其保护机制。</p>
<h4 id="漏洞挖掘与利用（Pwn）"><a href="#漏洞挖掘与利用（Pwn）" class="headerlink" title="漏洞挖掘与利用（Pwn）"></a>漏洞挖掘与利用（Pwn）</h4><p>专注于发现操作系统、软件或服务中的漏洞，并通过编写利用代码来获取系统的控制权。<br>常涉及缓冲区溢出、堆溢出、格式化字符串漏洞等。</p>
<h4 id="隐写术（Steganography）"><a href="#隐写术（Steganography）" class="headerlink" title="隐写术（Steganography）"></a>隐写术（Steganography）</h4><p>研究如何将信息隐藏在图像、音频、视频、文本等文件中而不引起注意。<br>参赛者需要找出隐藏的信息。</p>
<h4 id="移动安全（Mobile）"><a href="#移动安全（Mobile）" class="headerlink" title="移动安全（Mobile）"></a>移动安全（Mobile）</h4><p>针对安卓或 iOS 移动应用进行安全分析。<br>包括 APK 反编译、漏洞检测、权限滥用等方面。</p>
<h4 id="杂项（Misc）"><a href="#杂项（Misc）" class="headerlink" title="杂项（Misc）"></a>杂项（Misc）</h4><p>这是一个较为宽泛的类别，包含一些难以归类的题目。<br>可能涉及数据分析、编码解码、流量分析、游戏破解等各种独特的挑战。</p>
<h4 id="区块链安全（Blockchain）"><a href="#区块链安全（Blockchain）" class="headerlink" title="区块链安全（Blockchain）"></a>区块链安全（Blockchain）</h4><p>随着区块链技术的发展而出现的题型，涉及区块链中的加密算法、智能合约漏洞、私钥管理等方面的问题。</p>
<h4 id="取证分析（Forensics）"><a href="#取证分析（Forensics）" class="headerlink" title="取证分析（Forensics）"></a>取证分析（Forensics）</h4><p>从给定的系统镜像、网络流量、日志文件等数据中提取和分析有价值的信息，以找出与安全相关的线索或证据。<br>不同的 CTF 比赛可能会根据主题和难度对这些题型进行调整和创新。</p>
<h2 id="赛题情况分析"><a href="#赛题情况分析" class="headerlink" title="赛题情况分析"></a>赛题情况分析</h2><h3 id="赛题难度分布"><a href="#赛题难度分布" class="headerlink" title="赛题难度分布"></a>赛题难度分布</h3><p>CTF 赛题通常会涵盖从简单到困难的不同难度级别。</p>
<h4 id="1-简单题目："><a href="#1-简单题目：" class="headerlink" title="1.简单题目："></a>1.简单题目：</h4><p>主要针对基础知识和常见技术，旨在帮助新手入门和积累经验。<br>例如，一些基本的密码学加密算法的简单应用，或者明显的 Web 漏洞。</p>
<h4 id="2-中等难度题目："><a href="#2-中等难度题目：" class="headerlink" title="2.中等难度题目："></a>2.中等难度题目：</h4><p>要求参赛者对特定领域有一定的深入理解和实践经验。<br>可能是复杂一些的密码分析，或者需要综合运用多种技术的 Web 安全挑战。</p>
<h4 id="3-困难题目："><a href="#3-困难题目：" class="headerlink" title="3.困难题目："></a>3.困难题目：</h4><p>往往涉及前沿技术、罕见漏洞或者复杂的加密算法。<br>这类题目通常只有少数顶尖团队能够解决。</p>
<h3 id="赛题类型比例"><a href="#赛题类型比例" class="headerlink" title="赛题类型比例"></a>赛题类型比例</h3><p>不同类型的题目在比赛中的比例会根据赛事的侧重点和目标受众有所不同。</p>
<h4 id="1-密码学题目"><a href="#1-密码学题目" class="headerlink" title="1.密码学题目"></a>1.密码学题目</h4><p>一般会占有一定比例，通常在 15%-25%之间。<br>以检验参赛者对加密算法的理解和分析能力。</p>
<h4 id="2-Web-安全题目"><a href="#2-Web-安全题目" class="headerlink" title="2.Web 安全题目"></a>2.Web 安全题目</h4><p>是常见且重要的类型，比例可能在 20%-30%左右。<br>反映了 Web 应用在网络中的广泛应用和面临的安全威胁。</p>
<h4 id="3-逆向工程和漏洞挖掘利用题目"><a href="#3-逆向工程和漏洞挖掘利用题目" class="headerlink" title="3.逆向工程和漏洞挖掘利用题目"></a>3.逆向工程和漏洞挖掘利用题目</h4><p>合计可能占 20%-30%。<br>对参赛者的底层技术理解和实践能力有较高要求。</p>
<h4 id="4-其他类型（如隐写术、移动安全、杂项等）"><a href="#4-其他类型（如隐写术、移动安全、杂项等）" class="headerlink" title="4.其他类型（如隐写术、移动安全、杂项等）"></a>4.其他类型（如隐写术、移动安全、杂项等）</h4><p>总共约占 15%-25%。<br>用于增加比赛的多样性和全面性。</p>
<h3 id="赛题的创新性"><a href="#赛题的创新性" class="headerlink" title="赛题的创新性"></a>赛题的创新性</h3><p>为了保持比赛的吸引力和挑战性，CTF 赛题不断推陈出新。</p>
<h4 id="1-结合新的技术趋势："><a href="#1-结合新的技术趋势：" class="headerlink" title="1.结合新的技术趋势："></a>1.结合新的技术趋势：</h4><p>例如，随着人工智能和物联网的发展，出现了与这些领域相关的安全挑战题目。</p>
<h4 id="2-独特的场景设计："><a href="#2-独特的场景设计：" class="headerlink" title="2.独特的场景设计："></a>2.独特的场景设计：</h4><p>构建新颖的网络环境或应用场景，让参赛者在不熟悉的情况下进行分析和解决问题。</p>
<h4 id="3-跨领域综合题目："><a href="#3-跨领域综合题目：" class="headerlink" title="3.跨领域综合题目："></a>3.跨领域综合题目：</h4><p>融合多种技术领域，要求参赛者具备综合运用不同知识和技能的能力。</p>
<h3 id="赛题的时效性"><a href="#赛题的时效性" class="headerlink" title="赛题的时效性"></a>赛题的时效性</h3><h4 id="1-反映当前热点安全问题"><a href="#1-反映当前热点安全问题" class="headerlink" title="1.反映当前热点安全问题"></a>1.反映当前热点安全问题</h4><p>例如，近期出现的新型网络攻击手法或重大安全漏洞可能会被改编成赛题。</p>
<h4 id="2-跟进技术发展"><a href="#2-跟进技术发展" class="headerlink" title="2.跟进技术发展"></a>2.跟进技术发展</h4><p>随着新的加密算法、开发框架等的出现，相应的题目也会更新。</p>
<h2 id="赛题的隐蔽性和误导性"><a href="#赛题的隐蔽性和误导性" class="headerlink" title="赛题的隐蔽性和误导性"></a>赛题的隐蔽性和误导性</h2><h3 id="1-隐蔽性："><a href="#1-隐蔽性：" class="headerlink" title="1.隐蔽性："></a>1.隐蔽性：</h3><p>关键信息可能隐藏在大量的无关数据中，需要参赛者仔细筛选和分析。</p>
<h3 id="2-误导性："><a href="#2-误导性：" class="headerlink" title="2.误导性："></a>2.误导性：</h3><p>题目可能设置一些虚假的线索或干扰项，考验参赛者的判断力和排除干扰的能力。</p>
<p>综上所述，CTF 赛题在难度、类型、创新性、时效性、隐蔽性等方面都具有多样化的特点，需要参赛者具备扎实的知识基础、丰富的实践经验、创新的思维和敏锐的洞察力。</p>
<h2 id="CTF学习路线"><a href="#CTF学习路线" class="headerlink" title="CTF学习路线"></a>CTF学习路线</h2><h3 id="基础知识储备"><a href="#基础知识储备" class="headerlink" title="基础知识储备"></a>基础知识储备</h3><h4 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1.编程语言"></a>1.编程语言</h4><p>Python：掌握基本语法、数据结构、文件操作等。<br>C&#x2F;C++：了解底层编程和内存操作。</p>
<h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2.计算机网络"></a>2.计算机网络</h4><p>熟悉 TCP&#x2F;IP 协议栈、IP 地址、端口、路由等概念。<br>学习网络抓包工具如 Wireshark 的使用。</p>
<h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3.操作系统"></a>3.操作系统</h4><p>掌握 Linux 基本命令和操作。<br>了解 Windows 系统的常见设置和安全机制。</p>
<h4 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h4><p>学习 SQL 语言，了解常见的数据库漏洞。</p>
<h3 id="专业知识学习"><a href="#专业知识学习" class="headerlink" title="专业知识学习"></a>专业知识学习</h3><h4 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1.密码学"></a>1.密码学</h4><p>学习常见的加密算法（对称加密如 AES，非对称加密如 RSA）。<br>了解哈希函数、数字签名等概念。</p>
<h4 id="2-Web-安全"><a href="#2-Web-安全" class="headerlink" title="2.Web 安全"></a>2.Web 安全</h4><p>掌握 HTTP 协议。<br>学习常见的 Web 漏洞（SQL 注入、XSS、CSRF 等）。<br>熟悉 Web 应用防火墙（WAF）的原理。</p>
<h4 id="3-逆向工程"><a href="#3-逆向工程" class="headerlink" title="3.逆向工程"></a>3.逆向工程</h4><p>学习汇编语言。<br>掌握反编译工具（如 IDA Pro）的使用。</p>
<h4 id="4-漏洞挖掘与利用"><a href="#4-漏洞挖掘与利用" class="headerlink" title="4.漏洞挖掘与利用"></a>4.漏洞挖掘与利用</h4><p>了解缓冲区溢出、堆溢出等原理。<br>学习漏洞利用框架（如 Metasploit）。</p>
<h4 id="5-移动安全"><a href="#5-移动安全" class="headerlink" title="5.移动安全"></a>5.移动安全</h4><p>熟悉安卓和 iOS 系统的架构。<br>学习移动应用的安全分析方法。</p>
<h3 id="实践与练习"><a href="#实践与练习" class="headerlink" title="实践与练习"></a>实践与练习</h3><p>参加线上 CTF 平台的练习赛，如 HackTheBox、CTFTime 等。<br>分析他人的 Write-up，学习解题思路和技巧。<br>自己搭建实验环境，复现和练习常见的漏洞利用。</p>
<h3 id="深入学习与拓展"><a href="#深入学习与拓展" class="headerlink" title="深入学习与拓展"></a>深入学习与拓展</h3><p>研究前沿的安全技术和研究成果。<br>参与开源安全项目，贡献代码和发现。<br>关注安全领域的博客、论坛和会议，了解最新动态。</p>
<h3 id="团队协作与交流"><a href="#团队协作与交流" class="headerlink" title="团队协作与交流"></a>团队协作与交流</h3><p>加入 CTF 团队，与队友共同训练和参赛。<br>积极参与团队内部的讨论和分享，提高协作能力。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="网络漏洞"><a href="#网络漏洞" class="headerlink" title="网络漏洞"></a>网络漏洞</h2><h3 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h3><p>JavaScript 仅在浏览器中执行。</p>
<p>如果想在远程服务器中进行计算并将数据存储，该怎么办？例如，当登录网站时，必须在服务器上验证用户和密码。密码存储在服务器中，为了安全起见，不应从服务器外传输。</p>
<p>如果你在 JavaScript 上验证密码，你将能够在浏览器上看到它，就像你看到任何 JavaScript 一样，这将是非常不安全的。有几种编程语言可以在服务器上执行，例如：</p>
<ul>
<li>python</li>
<li>java</li>
<li>等等</li>
</ul>
<p>对于示例，将开始使用 PHP，不是因为认为它是一种很棒的语言，而是因为 Internet 上的大量网站都在使用它，并且它非常易于学习和部署。</p>
<p>假设有一个名为 hello.php 的文本文件，其中包含：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="title function_">alert</span>(<span class="string">&#x27;Hello World from JavaScript!&#x27;</span>); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">    echo &quot;Hello World from PHP!&quot;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，在扩展名为 .php 的文件中，可以混合使用 html、JavaScript 和 PHP 代码！如果服务器支持 PHP，<strong>那么 <php ></strong> 里面的所有内容都会被理解为 PHP 代码，并由服务器运行，而不是由浏览器运行。</p>
<p>如果在笔记本电脑上打开包含该内容的文件，则不会执行 PHP 代码，因为笔记本电脑不是 PHP 服务器（如果尚未将其设为 PHP 服务器）。因此，要执行 PHP，需要将笔记本电脑设为服务器。但目前，可以使用以下内容：<a target="_blank" rel="noopener" href="https://www.w3schools.com/php/phptryit.asp?filename=tryphp_intro">W3Schools Tryit Editor</a></p>
<p>访问该链接，将在右侧看到一个包含 html 和 PHP 代码的文件，运行时，打印“我的第一个 PHP 脚本！让修改代码以额外打印日期，因此在行下方</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My first PHP script!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>添加行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(<span class="string">&quot;H:i:s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>PHP 是服务器端代码，因此时间从服务器上的时钟开始！</p>
<p>现在做一个实验，并添加另一行带有此 php 代码的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt; alert(&#x27;Hello World from JavaScript!&#x27;); &lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在 PHP 中回显的字符串具有 JavaScript 代码。是否显示 JavaScript 警报？发生了什么事？正如预期的那样，在 php 上打印的任何内容都将成为 html 下载文件的组成部分，因此将执行 JavaScript。这为著名的跨站点脚本 （XSS） 攻击打开了大门。</p>
<h3 id="跨站脚本-（XSS）"><a href="#跨站脚本-（XSS）" class="headerlink" title="跨站脚本 （XSS）"></a>跨站脚本 （XSS）</h3><p>登录网站后，网站需要一种方法来知道来自自己浏览器的任何请求都来自之前登录的用户，而无需再次发送用户密码。为此，该网站可以在登录后向浏览器发送一个秘密随机值。该值通常存储在 Cookie 或 JavaScript 本地存储中。对于此示例，假设它存储在 cookie 中，而 cookie 只是浏览器中可以保留数据的变量。如果网站在浏览器中设置了特定的 Cookie，则浏览器会在向网站的每个请求中自动重新发送该 Cookie。如果网站仅使用 cookie 来保留会话，并且如果黑客可以从这儿窃取身份验证 cookie，他们就可以冒充！请注意，仅使用 cookie 进行身份验证会打开跨站点请求伪造 （CSRF） 的可能性，但这将在后面解释，现在专注于 XSS。</p>
<p>假设是社交网络中的黑客。创建帐户时，输入的不是自己姓名，而是 JavaScript 代码。当朋友访问自己个人资料时，网站将尝试打印姓名，但姓名实际上是 JavaScript 代码，因此浏览器可能会执行该 JavaScript 代码。这样，就可以在朋友的浏览器上执行自己的 JavaScript！</p>
<p>当在其他人的浏览器中执行 JavaScript 时，可以读取他们的身份验证数据，这些数据可以是用户登录后放置在 cookie 或 JavaScript 本地存储上的秘密值。那时，朋友的帐户可能会被盗用！</p>
<p>需要具备的一项重要技能是使用浏览器调试器。对于此解释，将使用 Firefox。可以在此处下载并安装 Firefox：<a target="_blank" rel="noopener" href="https://www.mozilla.org/en-US/firefox/new/">https://www.mozilla.org/en-US/firefox/new/</a></p>
<p>注意：如果真的不想使用 Firefox，每个浏览器都有一个调试器，可以在 google 上搜索如何使用它。不会有那么不同。</p>
<p>使用 Firefox，在以下链接的描述中输入姓名和一些文本：</p>
<p><a target="_blank" rel="noopener" href="https://primer.picoctf.org/vuln/web/sign_up.php">https://primer.picoctf.org/vuln/web/sign_up.php</a></p>
<p>打开另一个选项卡并访问以下链接。应该会看到姓名和描述：</p>
<p><a target="_blank" rel="noopener" href="https://primer.picoctf.org/vuln/web/tableusers.php">https://primer.picoctf.org/vuln/web/tableusers.php</a></p>
<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><p>密码学是一个古老的领域，可以追溯到古罗马。从词源上讲，这个词可以追溯到希腊词根“kryptos”，意思是“隐藏的”，而“graphein”的意思是“写”。它用于在敌人面前秘密通信。使用加密技术，可以在发送消息时实现以下属性：</p>
<ul>
<li>机密性：任何人都无法意外地阅读该消息。</li>
<li>完整性：如果消息被篡改，则可以检测到它被篡改。</li>
<li>鉴权：可以准确验证个人身份。</li>
<li>不可否认性：如果某人发送了特定消息，则该人无法否认该消息是由他们发送的。</li>
</ul>
<p>首先，将了解如何实现机密性。这是通过加密完成的。当想隐藏一条消息时，加密了消息。要了解加密的工作原理，将看到一个加密消息的古老方法的示例，该方法在今天无论如何都不安全，但它很适合说明。但首先，为了练习终端技能，将在 linux 中加密一个文件夹，以防止任何人在没有适当密码的情况下读取其内容。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>要在现实生活中使用加密，永远不应该使用自己的 implementations。首先，将演示如何在没有任何密码学知识的情况下加密文件。转到 picoCTF Webshell：<a target="_blank" rel="noopener" href="https://webshell.picoctf.org/">https://webshell.picoctf.org/</a></p>
<p>到达后创建一个包含自己名字的文件“tangxtang.txt”。可以使用 ‘ nano’编辑器，但在linux中可以执行以下技巧：</p>
<p>运行以下命令创建文本文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tangxtang&quot; &gt; tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>‘echo’ 命令只输出一个字符串，将该输出重定向到一个文件。例如，如果只运行</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tangxtang&quot;</span><br></pre></td></tr></table></figure>

<p>只会在屏幕上看到 ‘samuel’ 的印刷。现在运行：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>将看到自己创建的文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>如果运行以下命令：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>将看到以下内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat tangxtang.txt</span><br><span class="line">tangxtang</span><br></pre></td></tr></table></figure>

<p>现在，使用姓氏创建另一个名为 ‘tang.txt’ 的文件。可以使用相同的技术来创建 ‘tang.txt：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;pardo&quot; &gt; tang.txt</span><br></pre></td></tr></table></figure>

<p>将这两个文件移动到以一个新文件夹，然后压缩该文件夹，然后对其进行加密！压缩文件夹只会使多个文件或文件夹显示为单个文件，他们占用的磁盘空间会更少，但压缩不提供任何安全性。任何人都可以简单的解压它并查看原始内容。但是，加密会阻止在没有密钥的情况下获取原始内容。要进行该实验，先创建一个名为my info的目录：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_info</span><br></pre></td></tr></table></figure>

<p>并使用命令 mv （mv 表示移动） 将两个文件移动到内部：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv tangxtang.txt my_info/</span><br><span class="line">mv tang.txt my_info/</span><br></pre></td></tr></table></figure>

<p>导航到文件夹“my_info”并确保它包含文件。现在，回到my_info文件夹之外，通过运行将文件夹压缩成一个 zip 文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r my_info.zip my_info/</span><br></pre></td></tr></table></figure>

<p>请注意，my_info.zip 是为压缩文件选择的名称，而 ‘-r’ 表示递归，在本例中，这意味着想要压缩文件夹中的所有内容。如果运行应该会看到文件夹和压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info  my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在通过运行以下命令删除文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r my_info</span><br></pre></td></tr></table></figure>

<p>‘rm’ 表示删除，’-r’ 表示递归，表示想要删除文件夹中的所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r my_info</span><br></pre></td></tr></table></figure>

<p>现在，如果运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>应该只看到压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info.zip</span><br></pre></td></tr></table></figure>

<p>可以通过运行以下命令轻松解压缩文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip my_info.zip</span><br></pre></td></tr></table></figure>

<p>并获取原始文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info  my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在，创建一个受加密保护的 zip 文件，这样它就不能在没有密钥的情况下解压缩。在这种情况下，“key”和“password”这两个词是同义词。</p>
<p>首先删除已经通过运行创建的 .zip 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在，使用以下命令使用密码创建加密的 zip：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip --encrypt -r my_protected_info.zip my_info/</span><br></pre></td></tr></table></figure>

<p>系统将要求输入密码并验证密码，因此请记住使用的密码，以便稍后能够解密它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip --encrypt -r my_protected_info.zip my_info/</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">  adding: my_info/ (stored 0%)</span><br><span class="line">  adding: my_info/my_name.txt (stored 0%)</span><br><span class="line">  adding: my_info/my_lastname.txt (stored 0%)</span><br></pre></td></tr></table></figure>

<p>如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip my_protected_info.zip</span><br></pre></td></tr></table></figure>

<p>它会询问密码，只有输入正确的密码，才会找回原始内容！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Archive:  my_protected_info.zip</span><br><span class="line">   creating: my_info/</span><br><span class="line">[my_protected_info.zip] my_info/my_name.txt password:</span><br><span class="line"> extracting: my_info/my_name.txt</span><br><span class="line"> extracting: my_info/my_lastname.txt</span><br></pre></td></tr></table></figure>

<p>没有密码就无法获取原始内容，因为它用于对内容执行作以获取生成的加密文件。此时，可能不知道发生了什么。有许多加密算法，这些算法是从古罗马时代开始创建的。如今，旧的数据加密方法很容易被打破。如今，即使是相对较新的数据加密方法也很容易被破解。其中一些现在被认为是牢不可破的，但将来会损坏。</p>
<h3 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h3><p>“密码”是指一种秘密或伪装的编写消息的方式。它可以被认为与加密相同。一种在古罗马发明并以皇帝尤利乌斯·凯撒 （Julius Caesar） 的名字命名的密码方法是凯撒密码，他将其用于私人通信。此密码只是将一个单词的每个字母替换为另一个字母，该字母在字母表中的位置具有一定数量。这个 “一定数量的位置” 称为 shift 。</p>
<p>例如，如果有单词 “hello” 并且想使用 Caesar 密码对其进行加密，并且偏移量为 3，会将 ‘h’ 替换为 ‘k’，因为 ‘k’ 在字母表中的位置更高 3 位，出于同样的原因，将 ‘e’ 替换为 ‘h’，依此类推。将要加密的原始文本称为明文或明文。使用 Caesar’s 加密 ‘hello’ （偏移量为 3）的结果如下：</p>
<p>明文 → h e l l o</p>
<p>加密文本 → k h o o r</p>
<p><strong>“解密”是指从加密文本中获取明文。</strong>对于 Caesar 的密码，只需执行相同的作，但要相反;将字母表中的每个字母减去 3 个位置。</p>
<p>请注意，<strong>当在加密某些内容时添加位置后到达字母表的末尾时，只是重叠了字母表</strong>。例如，要加密字母 ‘z’，将使用字母 ‘c’ 对其进行加密。</p>
<p>Caesar 的密码是一种<strong>替换密码</strong>，因为它将每个字母替换为其他字母。在替换密码中，不一定需要用另一个字母替换一个字母。如果知道如何反转它，可以使用任何符号。</p>
<p>将使用一个 python 代码，该代码使用 Caesar 密码仅加密和解密小写字母。这是它的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(text):</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 遍历for循环中文本的每个字符</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line"></span><br><span class="line">        # 通过word获取ASCII值</span><br><span class="line">        char_position = ord(text[i])</span><br><span class="line"></span><br><span class="line">        #减去97得到一个从1到26的字符</span><br><span class="line">        char_position = char_position - 97</span><br><span class="line"></span><br><span class="line">        # 偏移量为 3</span><br><span class="line">        new_char_position = char_position + 3</span><br><span class="line"></span><br><span class="line">        # 确保位置不超过26</span><br><span class="line">        new_char_position = new_char_position % 26</span><br><span class="line"></span><br><span class="line">        # 转换回ASCII值</span><br><span class="line">        new_char_position = new_char_position + 97</span><br><span class="line"></span><br><span class="line">        #将ASCII值转换为字符并将其连接到最终结果</span><br><span class="line">        result = result + chr(new_char_position)</span><br><span class="line"></span><br><span class="line">        print(result)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def caesar_decrypt(cipher_text):</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    #遍历for循环中文本的每个字符</span><br><span class="line">    for i in range(len(cipher_text)):</span><br><span class="line"></span><br><span class="line">        # 通过word获取ASCII值</span><br><span class="line">        char_position = ord(cipher_text[i])</span><br><span class="line"></span><br><span class="line">        # 减去97得到一个从1到26的字符</span><br><span class="line">        char_position = char_position - 97</span><br><span class="line"></span><br><span class="line">        # 偏移量为 3</span><br><span class="line">        new_char_position = char_position - 3</span><br><span class="line"></span><br><span class="line">        # 确保位置不超过26</span><br><span class="line">        new_char_position = new_char_position % 26</span><br><span class="line"></span><br><span class="line">        # 转换回ASCII值</span><br><span class="line">        new_char_position = new_char_position + 97</span><br><span class="line"></span><br><span class="line">        #将ASCII值转换为字符并将其连接到最终结果</span><br><span class="line">        result = result + chr(new_char_position)</span><br><span class="line"></span><br><span class="line">        print(result)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">text = &quot;picoctf&quot;</span><br><span class="line">print(f&quot;Plain Text: &#123;text&#125;&quot;)</span><br><span class="line">cipher_text = caesar_encrypt(text)</span><br><span class="line">print(f&quot;Encrypted: &#123;cipher_text&#125;&quot;)</span><br><span class="line">print(f&quot;Decrypted: &#123;caesar_decrypt(cipher_text)&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>应该会看到以下输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Plain Text: picoctf</span><br><span class="line">s</span><br><span class="line">sl</span><br><span class="line">slf</span><br><span class="line">slfr</span><br><span class="line">slfrf</span><br><span class="line">slfrfw</span><br><span class="line">slfrfwi</span><br><span class="line">Encrypted: slfrfwi</span><br><span class="line">p</span><br><span class="line">pi</span><br><span class="line">pic</span><br><span class="line">pico</span><br><span class="line">picoc</span><br><span class="line">picoct</span><br><span class="line">picoctf</span><br><span class="line">Decrypted: picoctf</span><br></pre></td></tr></table></figure>

<h3 id="换位密码"><a href="#换位密码" class="headerlink" title="换位密码"></a>换位密码</h3><p>在换位密码中，不会用其他符号替换字母，而只是改变在明文上的显示顺序。例如，可以决定加密算法只是将字母向右移动并重叠。通过将单词 ‘pico’ 的字母向右旋转一个位置来加密单词 ‘pico’。</p>
<p>明文 → p i c o</p>
<p>加密文本 → o p i c</p>
<p>这是一种非常简单的换位。但是可以有一个进行更复杂的换调的映射。例如，可以决定使用以下映射以 6 个字母为块进行转置来加密文本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202504261633232.png"></p>
<p>数字表示字母的位置。使用该映射，对单词 ‘pico’ 进行加密。由于 pico 只有 4 个字母，可以简单地使用填充来完成，直到 6 个字母。在这个例子中，将使用符号 * 作为填充，所以有：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%BA%94%E7%94%A8%E5%B8%A6%E5%A1%AB%E5%85%85%E7%9A%84%E6%98%A0%E5%B0%84.png"></p>
<p>加密的单词是 ‘c*ip*o’，使用任意定义的映射。假设想要加密一个长文本。在这种情况下，只需每 6 个字符应用相同的映射。</p>
<p>到目前为止，已经了解了转置和替换密码的工作原理。如果它们只自己使用，它们很容易破解。另一方面，如果有人发现了用来加密的算法，加密就永远被打破了！改善这种情况的一种方法是使用基于密钥的加密算法。</p>
<h3 id="密钥密码"><a href="#密钥密码" class="headerlink" title="密钥密码"></a>密钥密码</h3><p>密码学中有一条原则叫做 Kerckhoffs 原则，它指出：“即使关于系统的所有内容（除了密钥）都是公共知识，密码系统也应该是安全的”。</p>
<p>该原则声称要克服这样一个事实，即一旦敌人知道加密算法，加密就会被破坏。解决方案是使用密钥。一种用于使用密钥加密数据的旧算法是“Vigenere”。它看起来肯定比之前学习的算法更强大。尽管它现在很容易破碎，但在当时它被认为是牢不可破的。</p>
<p>为了了解 Vigenere 的工作原理，将加密明文:</p>
<p>“I LOVE PITTSBURGH”</p>
<p>首先，删除空格，因为 Vigenere 表没有空格。但是，即使文本没有空格，人类也可以轻松识别文本中的单词。得到：</p>
<p>“ILOVEPITTSBURGH”</p>
<p>现在，可以选择一个密钥。在这个示例中，将使用密钥“PICOCTF”。由于文本比密钥长，只需重复密钥几次，直到长度相同，具体方式如下：</p>
<p>明文：ILOVEPITTSBURGH</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p><strong>明文的第一个字母与密钥的第一个字母配对。</strong>因此，得到配对（’I’，’P’）。现在，在下面给出的维吉尼亚密码表中，使用第 i 行和第 p 列。该列和该行的交叉单元格将是加密后的字母，在这种情况下是 X。对剩余的字母重复同样的操作，最终会得到以下结果：</p>
<p>明文：ILOVEPITTSBURGH</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p>加密文本：XTQJGINIBUPWKLW</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/Vigenere%E8%A1%A8.png"></p>
<p>现在来看看解密是如何工作的。假设只有 key 和 encrypted：</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p>加密文本：XTQJGINIBUPWKLW</p>
<p>取键的第一个字母，即 ‘P’，然后转到 vigenere 表中的该行。然后在 ‘P’ 行中，找到加密文本的第一个字母，即 ‘X’。对应于 ‘X’ 的列是明文的第一个字母，在例子中是 ‘I’。对每个角色重复相同的过程，直到得到 ‘ILOVEPITSBURGH’。</p>
<p>即使没有电脑，Vigenere 也很容易被打破。著名的科学传播者 Simon Singh 在他的网站上有一个破解 Vigenere 的好工具：</p>
<p><a target="_blank" rel="noopener" href="https://www.simonsingh.net/The_Black_Chamber/vigenere_cracking_tool.html">https://www.simonsingh.net/The_Black_Chamber/vigenere_cracking_tool.html</a></p>
<p>破解密码本身就是一个称为密码分析的领域。密码分析和密码学构成了更大的领域，称为密码学。</p>
<h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><p>在现代密码学中存在对称和非对称密码学的概念。对称加密意味着使用相同的密钥进行加密和解密，就像刚刚在 Vigenere 上所做的那样。在非对称加密中，有两个密钥。一个用于加密，称为公钥，另一个用于解密，称为私钥。非对称加密技术很有用，因为它可用于解决密钥交换问题。此外，它还可用于提供完整性和不可否认性的数字签名。</p>
<h4 id="对称加密示例：AES"><a href="#对称加密示例：AES" class="headerlink" title="对称加密示例：AES"></a>对称加密示例：AES</h4><p>当今对称加密的常用算法是 AES，意思是“高级加密标准”。此算法使用固定长度的 key 组合替换和转置。固定长度的 key 意味着算法只能有一定大小的 key。但是，AES 有不同的版本，每个版本可以支持不同大小的密钥长度。最常见的版本是 AES 128 和 AES 256，它们的密钥长度分别为 128 位和 AES 256。AES 算法被认为是安全的。但是，如果实现存在缺陷，则可以成功攻击该实现。例如，破解 AES 加密的一种著名方法是 Padding Oracle Attack，它可以成功破解 SSL，这是一种广泛用于保护 HTTP 流量的加密协议。然而，这不是 AES 的弱点，而是它使用方式的弱点。</p>
<p>AES 有不同的作模式。将分析其中两个，以说明它们在使用过程中可能出现的漏洞。这些作模式是 “ECB” 和 “CBC”。</p>
<h5 id="作模式-ECB"><a href="#作模式-ECB" class="headerlink" title="作模式 ECB"></a>作模式 ECB</h5><p><strong>ECB 表示 电子密码簿。</strong>在这种作模式下，根据密钥长度独立加密明文的块。例如，如果使用 AES 128，将明文分成 128 位的块，并使用 AES 独立加密它们。这会导致问题，因为它会泄露加密文本中的结构。</p>
<p>假设正在发送加密文本，并且知道前 128 位包含名称，后 128 位包含日期。假设是一名攻击者，在不同日期捕获了一些加密邮件。即使不知道密钥，也可以交换第二个消息块以篡改日期。</p>
<p>ECB 的另一个问题是，如果将相同的消息发送两次，任何攻击者都可以看到相同的消息正在再次发送。安全的加密算法不应泄露有关消息的任何信息。知道过去发送了相同的消息可用于了解有关通信的详细信息。<strong>建议永远不要使用 ECB。</strong></p>
<h5 id="作模式-CBC"><a href="#作模式-CBC" class="headerlink" title="作模式 CBC"></a>作模式 CBC</h5><p>更安全的作模式是 CBC，即密码块链接。在此模式下，包含其他元素。第一个是初始化向量，一个与键大小相同的随机值。在 AES 中，密钥大小与块大小相同。请记住，在 AES 中，必须将明文分隔为与密钥大小相同的块。在开始加密之前，在第一个明文块和初始化向量之间进行 XOR，然后开始使用 AES 和选择的密钥进行加密。每条消息的初始化向量都不同，因此如果两次发送相同的消息，它会因初始化向量而有所不同。必须将初始化向量附加到消息中。在此作模式中添加的另一个元素是，不单独加密区块，而是使用一个区块中的加密文本，并将其与要加密的下一个明文区块进行 XOR 运算。然后，使用 AES 和密钥来加密该结果。在下图中，显示了刚才解释的图形表示，请注意，带有叉号的圆圈表示 XOR：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/CBC%E5%9B%BE.png"></p>
<p> AES 中，明文的大小必须与块大小的倍数相同。例如，如果你有一个恰好短于块的明文，则需要向明文添加填充，以便它至少匹配一个块。如果明文大于一个块，但小于两个块，则需要向明文添加填充，直到它与两个块的大小相同。在 AES 中，有一种常见的填充方式，称为 PKCS #7 的标准。在 AES 128 中，正如我们之前所说，块大小为 128 位，相当于 16 字节。假设要加密消息：</p>
<p>“HELLOPICOCTF”</p>
<p>由于该消息是 12 字节，因此我们需要添加 4 字节的填充来完成块的大小。在 PKCS#7 中，使用字节添加填充，其中包含需要填充的字节值。在我们的示例中，由于我们需要填充 4 个字节才能完成 16 个字节，因此我们将像这样填充：</p>
<p>“HELLOPICOCTF”+“\x04\x04\x04\x04”</p>
<p>请注意，“\x” 是一种表示在字符串中我们想在字节上使用确切数字的方法，即使它不是可打印的 ASCII。现在，假设我们要加密一条 15 字节的消息，如下所示：</p>
<p>“GOODBYEPICOCTF!”</p>
<p>使用 PKCS#7 填充后，结果是：</p>
<p>“GOODBYEPICOCTF!”+”\x01”</p>
<p>填充消息 “BYEPICOCTF” 后会有什么结果？</p>
<p>“BYEPICOCTF”+”\x06\x06\x06\x06\x06\x06”</p>
<p>是对的。</p>
<h4 id="非对称加密示例：RSA"><a href="#非对称加密示例：RSA" class="headerlink" title="非对称加密示例：RSA"></a>非对称加密示例：RSA</h4><p>请记住，非对称加密意味着使用一个密钥进行加密（公钥），使用另一个密钥进行解密（私钥）。假设想与非对称加密进行秘密通信。在这种情况下，将生成公有密钥和私有密钥对。然后，将公钥提供给任何想要向自己发送加密消息的人。他们将使用自己的公钥加密消息，当自己收到加密消息时，自己是唯一可以解密它的人，因为自己是唯一拥有私钥的人。这就是为什么它被称为 “private”。请注意，自己的公钥可以是公共知识，并且没有人能够解密消息。如果自己想向某人发送加密消息，该人必须提供他们的公钥。</p>
<p>一种非常广泛使用的非对称加密算法是 RSA。它被称为 RSA，因为它的发明者是：Ronald <strong>R</strong>ivest、Adi <strong>S</strong>hamir 和 Leonard <strong>A</strong>dleman。为了了解它的工作原理，将使用 RSA 算法和为此示例生成的公钥-私钥对进行加密和解密;这看起来有点神奇。之后，将了解一些概念，学习生成密钥，并使用生成的密钥进行加密和解密。</p>
<p>在加密之前，如果还不知道，则需要了解它是如何工作的模运算。其实很简单。取模运算可查找一个数字除以另一个数字后的余数。例如，8 mod 3 &#x3D; 2，因为 3 适合 8 两次，并且有一个 2 的提醒。由于 RSA 使用非常基本的算术，因此准备查看该示例。在 RSA 中，公钥是一对数字，也是私钥。消息可以是可以表示为数字的任何内容。在计算机中，正如所知，一切都是一个数字。加密的文本（也称为密文）将是另一个数字。总之，这是在 RSA 中需要加密和解密的：</p>
<p>RSA 公钥：是一对数字  (e,n)</p>
<p>RSA 私钥：是一对数字  (d,n)</p>
<p>消息: m</p>
<p>密文: c</p>
<p>加密: m^e^ mod n &#x3D; c</p>
<p>解密: c^d^  mod n &#x3D; m</p>
<p>基本上，’d’ 是私钥的私有值，因为 ‘n’ 也在公钥中。正如刚才看到的，公式非常简单。要加密消息，只需将消息发挥到 ‘e’ 的幂，然后对 ‘n’ 执行模数作。要解密，请将密文取到 ‘d’ 的幂，然后对 ‘n’ 进行模运算，这将产生原始消息。在此示例中，密钥的数量非常小，这在现实生活中是不安全的。RSA 仅在使用较大值时是安全的。到 2019 年，只有当密钥是至少需要 2048 位的数字时，RSA 才被认为是安全的。大约是 <strong>617 位数字</strong>。这是 617 位数字的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764</span><br></pre></td></tr></table></figure>

<p>这当然是一个非常大的数字。但是，要了解它的工作原理，最好使用较小的数字。让看一个例子：</p>
<p>公钥 （e，n） → （11,117）</p>
<p>私钥 （d，n） → （35,117）</p>
<p>消息 m –&gt; 10</p>
<p>到目前为止，有一个 e&#x3D;11 的公钥和一个 d&#x3D;35 的私钥。信息是 10，要加密 10，执行以下作：</p>
<p>10^11^ mod 117</p>
<p>结果是 82 次。所以，有：</p>
<p>10^11^ mod 117 &#x3D; 82</p>
<p>密文 → 82</p>
<p>现在，对于解密，执行以下作：</p>
<p>82^35^ mod 117 &#x3D; 10</p>
<p>明文 → 10</p>
<p>这有点神奇。RSA 私有密钥和公有密钥是通过使它们具有此属性的步骤生成的。密钥生成的过程相对简单。只需要了解它的某些部分来展示攻击。</p>
<p>请注意，“在数论中，如果两个整数 a 和 b 除以它们的唯一正整数（因数）是 1，则称它们为相对素数、互素数或互质（也写为互质）。因此，任何除以一个的素数都不会除以另一个。这相当于它们的最大公约数 （gcd） 是 1“。乘法逆元是用来将另一个数相乘并得到 1 的数字。</p>
<p>例如，在非整数算术中（在 RSA 中我们只使用整数算术），8 的乘法逆元是 1&#x2F;8，因为 8 * 1&#x2F;8&#x3D;1。但是，在整数算术中，没有分数。但是我可以有一个乘法逆模 n，这意味着如果有一个数字，将其乘以它的乘法逆数，取模 n，结果将是 1。</p>
<p>例如，3 模 4 中的乘法逆元是 3，为什么？因为如果你乘以 3*3，得到 9，而 9 以 4 为模数，是 1。现在，已准备好查看密钥生成而不会丢失。就是这样：</p>
<ul>
<li>生成两个大的互质数 p 和 q。</li>
<li>找到 n &#x3D; pq 和 phi &#x3D; （p-1） （q-1）</li>
<li>选择 e，使 1 &lt; e &lt; phi，e 是 phi 的互质</li>
<li>找到 d，它是 e 模 phi 的乘法逆元。</li>
<li>这对 （e， n） 是公钥</li>
<li>这对 （d， n） 是私钥</li>
</ul>
<p>这相对简单！要查找乘法逆元，可以使用扩展欧几里得算法 （EEA）。在谷歌中很容易找到它的在线实现。</p>
<p>公钥 （e，n） → （11,117）</p>
<p>私钥 （d，n） → （35,117）</p>
<p>这是以同样的方式生成的。首先，选择了两个互质数。选择的号码是：</p>
<p>p &#x3D; 13</p>
<p>q&#x3D;9</p>
<p>它们是互质的，因为它们的最大公约数是 1。然后</p>
<p>n&#x3D;13*9&#x3D;117</p>
<p>phi&#x3D;（13-1）（9-1）&#x3D;96</p>
<p>要选择 e，我们任意选择一个大于 1 且小于 phi 的数字，它与 phi 互质。数字 11 符合这些要求。所以</p>
<p>e&#x3D;11</p>
<p>现在，要获得 ‘d’ 应用 EEA.我们可以在这个网站上做到这一点：</p>
<p><a target="_blank" rel="noopener" href="https://planetcalc.com/3298/">https://planetcalc.com/3298/</a></p>
<h5 id="攻击-RSA"><a href="#攻击-RSA" class="headerlink" title="攻击 RSA"></a>攻击 RSA</h5><p>如果 RSA 有一个小的 ‘n’，它很容易被破坏。这在现实生活中并不经常发生，除非程序员决定实现他们自己的 RSA 版本。程序员不应该自己实现密码学，使用经过行业测试的库是一般规则。RSA 的安全性基于这样一个事实，即没有有效的算法来分解大的“n”，因此攻击者无法从公钥生成私钥。如果 ‘n’ 太小，则可以对其进行因式分解。</p>
<p>将了解如何通过从公众处恢复私钥来破解 RSA。在现实生活中，公钥位于数字证书中，该证书是一个包含与公钥所有者相关的数据以及公钥本身的软件包。数字证书通常以 base64 编码，这是一种将二进制文件编码为可打印文本的方法。以下是以 base64 编码的数字证书示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIB6zCB1AICMDkwDQYJKoZIhvcNAQECBQAwEjEQMA4GA1UEAxMHUGljb0NURjAe</span><br><span class="line">Fw0xOTA3MDgwNzIxMThaFw0xOTA2MjYxNzM0MzhaMGcxEDAOBgNVBAsTB1BpY29D</span><br><span class="line">VEYxEDAOBgNVBAoTB1BpY29DVEYxEDAOBgNVBAcTB1BpY29DVEYxEDAOBgNVBAgT</span><br><span class="line">B1BpY29DVEYxCzAJBgNVBAYTAlVTMRAwDgYDVQQDEwdQaWNvQ1RGMCIwDQYJKoZI</span><br><span class="line">hvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQABMA0GCSqGSIb3DQEBAgUAA4IBAQAH</span><br><span class="line">al1hMsGeBb3rd/Oq+7uDguueopOvDC864hrpdGubgtjv/hrIsph7FtxM2B4rkkyA</span><br><span class="line">eIV708y31HIplCLruxFdspqvfGvLsCynkYfsY70i6I/dOA6l4Qq/NdmkPDx7edqO</span><br><span class="line">T/zK4jhnRafebqJucXFH8Ak+G6ASNRWhKfFZJTWj5CoyTMIutLU9lDiTXng3rDU1</span><br><span class="line">BhXg04ei1jvAf0UrtpeOA6jUyeCLaKDFRbrOm35xI79r28yO8ng1UAzTRclvkORt</span><br><span class="line">b8LMxw7e+vdIntBGqf7T25PLn/MycGPPvNXyIsTzvvY/MXXJHnAqpI5DlqwzbRHz</span><br><span class="line">q16/S1WLvzg4PsElmv1f</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>将该文本复制到 Webshell 的文本文件中，并将其命名为 “weak_n_certificate”。要破解具有弱 n 的 RSA，必须做的第一件事是从证书中提取 n。请记住，n 是模数，e 是指数。 可以使用以下命令提取这些值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in weak_n_certificate -text -noout</span><br></pre></td></tr></table></figure>

<p>在这种情况下，</p>
<p>n&#x3D; 4966306421059967</p>
<p>e&#x3D; 65537</p>
<p>正如在命令的输出中看到的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 12345 (0x3039)</span><br><span class="line">        Signature Algorithm: md2WithRSAEncryption</span><br><span class="line">        Issuer: CN = PicoCTF</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jul  8 07:21:18 2019 GMT</span><br><span class="line">            Not After : Jun 26 17:34:38 2019 GMT</span><br><span class="line">        Subject: OU = PicoCTF, O = PicoCTF, L = PicoCTF, ST = PicoCTF, C = US, CN = PicoCTF</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (53 bit)</span><br><span class="line">                Modulus: 4966306421059967 (0x11a4d45212b17f)</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">    Signature Algorithm: md2WithRSAEncryption</span><br><span class="line">         07:6a:5d:61:32:c1:9e:05:bd:eb:77:f3:aa:fb:bb:83:82:eb:</span><br><span class="line">         9e:a2:93:af:0c:2f:3a:e2:1a:e9:74:6b:9b:82:d8:ef:fe:1a:</span><br><span class="line">         c8:b2:98:7b:16:dc:4c:d8:1e:2b:92:4c:80:78:85:7b:d3:cc:</span><br><span class="line">         b7:d4:72:29:94:22:eb:bb:11:5d:b2:9a:af:7c:6b:cb:b0:2c:</span><br><span class="line">         a7:91:87:ec:63:bd:22:e8:8f:dd:38:0e:a5:e1:0a:bf:35:d9:</span><br><span class="line">         a4:3c:3c:7b:79:da:8e:4f:fc:ca:e2:38:67:45:a7:de:6e:a2:</span><br><span class="line">         6e:71:71:47:f0:09:3e:1b:a0:12:35:15:a1:29:f1:59:25:35:</span><br><span class="line">         a3:e4:2a:32:4c:c2:2e:b4:b5:3d:94:38:93:5e:78:37:ac:35:</span><br><span class="line">         35:06:15:e0:d3:87:a2:d6:3b:c0:7f:45:2b:b6:97:8e:03:a8:</span><br><span class="line">         d4:c9:e0:8b:68:a0:c5:45:ba:ce:9b:7e:71:23:bf:6b:db:cc:</span><br><span class="line">         8e:f2:78:35:50:0c:d3:45:c9:6f:90:e4:6d:6f:c2:cc:c7:0e:</span><br><span class="line">         de:fa:f7:48:9e:d0:46:a9:fe:d3:db:93:cb:9f:f3:32:70:63:</span><br><span class="line">         cf:bc:d5:f2:22:c4:f3:be:f6:3f:31:75:c9:1e:70:2a:a4:8e:</span><br><span class="line">         43:96:ac:33:6d:11:f3:ab:5e:bf:4b:55:8b:bf:38:38:3e:c1:</span><br><span class="line">         25:9a:fd:5f</span><br></pre></td></tr></table></figure>

<p>因式分解 n 很容易。如果你在 google 上搜索 “integer factorization online”，第一个结果是这个：</p>
<p><a target="_blank" rel="noopener" href="https://www.alpertron.com.ar/ECM.HTM">https://www.alpertron.com.ar/ECM.HTM</a></p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希通常用于在数据库中存储密码。当用户登录时，将计算密码的哈希值，并将其与存储的哈希值进行比较。如果它们匹配，则知道用户输入了正确的密码。请注意，哈希的一个基本属性是不可能从哈希中获取原始文本。因此，如果用户有权访问数据库，系统管理员将无法获知用户的实际密码。在数据泄露的情况下，当数据库泄露时，攻击者将无法获取用户的真实密码。</p>
<p>哈希如何受到攻击？对于密码，攻击者可以通过计算多个单词（例如英语词典中的所有单词）的哈希值来创建一个表，该表将多个密码映射到其哈希值。这样，如果攻击者在数据库中找到密码的哈希值，并且该密码是英语词典中的一个单词，则可以通过在表中查找它来将其映射回原始密码。但是，如果用户选择了安全密码，则此攻击将不起作用，因为该安全密码具有复杂性，不会出现在字典中。请注意，有一些常用密码列表，其中包含多种语言的单词及其变体，例如“Hello_12345”。安全密码应为随机字符，以防止此攻击。</p>
<p>质询：以下密码哈希值已从数据库中泄露，并且您知道用户没有使用强密码。</p>
<p>CD0894152aa5eec36ec79eb2bcb90ca40f056804530f40732b4957a496b23dc8</p>
<p>在 google 上搜索名为“rockyou”的密码列表并生成哈希值以查找与泄露的哈希值对应的密码！</p>
<p>提示：可以使用 python 生成哈希。哈希算法为 SHA256。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>当访问浏览器并访问网站时，网站的信息将以数据包的形式下载。今天的 Internet 速度很快，可能会觉得网站一下子就出现了。但是如果下载一个大文件，可以看到它需要一些时间。发生这种情况是因为文件被分解为计算机中接收的数据包，并开始累积，直到它们全部被接收并在下载完成时符合整个文件。每个数据包都包含对应于每个层的一块。在此处查看层：<a target="_blank" rel="noopener" href="https://primer.picoctf.org/#network_layers">网络层</a>。</p>
<h3 id="嗅探和攻击示例"><a href="#嗅探和攻击示例" class="headerlink" title="嗅探和攻击示例"></a>嗅探和攻击示例</h3><p>在一个名为 Wireshark 的工具中，我们可以“嗅探”网络上传输的数据包。用于指代 Wireshark 等工具的技术术语是“嗅探器”。</p>
<p>如果尚未安装，请在此处获取有关安装 Wireshark 的说明：<a target="_blank" rel="noopener" href="https://primer.picoctf.org/#installing_wireshark">安装 Wireshark</a>。</p>
<p>安装并打开它后，应该会看到一个类似于以下内容的窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/Wireshark%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2.png"></p>
<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><h2 id="环境与工具"><a href="#环境与工具" class="headerlink" title="环境与工具"></a>环境与工具</h2><h3 id="工具链："><a href="#工具链：" class="headerlink" title="工具链："></a><strong>工具链</strong>：</h3><ul>
<li><strong>反汇编工具</strong>：IDA Pro（主力）、Ghidra（免费替代）、Binary Ninja</li>
<li><strong>调试器</strong>：x64dbg（Windows）、GDB（Linux，配合Pwngdb插件）</li>
<li><strong>其他工具</strong>：PEiD&#x2F;Detect It Easy（查壳）、010 Editor（二进制分析）、Cutter（逆向辅助）</li>
<li><strong>动态分析</strong>：Cheat Engine（内存修改）、Process Monitor（行为监控）</li>
</ul>
<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a><strong>环境</strong>：</h3><ul>
<li>虚拟机或Docker（隔离实验环境）</li>
<li>Windows&#x2F;Linux双系统（覆盖常见题型）</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><ul>
<li>掌握x86&#x2F;x64基础指令（<code>mov</code>, <code>push/pop</code>, <code>call/ret</code>, <code>cmp/jmp</code>）</li>
<li>理解函数调用约定（<code>cdecl</code>, <code>stdcall</code>, <code>fastcall</code>）</li>
<li>熟悉栈帧结构（EBP&#x2F;RBP、ESP&#x2F;RSP）</li>
</ul>
<h5 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h5><h6 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a><strong>背景知识介绍</strong></h6><ol>
<li><strong>计算机基础原理</strong><br>  计算机是通过执行二进制指令来运行的程序。理解计算机的基本工作原理，如CPU、内存、输入输出设备等，是学习汇编的基础。二进制指令是计算机能够直接执行的最低级语言，而汇编语言则是对这些二进制指令的符号化表示。</li>
<li><strong>操作系统基础</strong><br>  操作系统管理计算机的硬件和软件资源。汇编语言与操作系统密切相关，因为不同的操作系统可能使用不同的函数调用约定和栈帧结构。了解操作系统的基本概念，如进程、线程、内存管理等，有助于理解汇编程序的执行环境。</li>
<li><strong>数据表示与存储</strong><br>  计算机中的数据以二进制形式存储和处理。理解数据的表示方式（如整数、浮点数、字符等）以及它们在内存中的存储方式（如大端序、小端序）对汇编编程至关重要。例如，x86架构通常使用小端序存储数据。</li>
<li><strong>寄存器与内存模型</strong><br>  寄存器是CPU内部的高速存储单元，用于临时存储数据和指令。x86&#x2F;x64架构中有多个寄存器（如EAX、EBX、ECX、EDX等），每个寄存器有特定的用途。理解寄存器的作用以及它们与内存之间的交互是汇编编程的核心。</li>
<li><strong>机器码与汇编指令的关系</strong><br>  汇编指令是对人类友好的指令表示，而机器码是计算机能够直接执行的二进制代码。每条汇编指令都对应一条或多条机器码指令。理解这两者之间的关系有助于更好地掌握汇编语言的本<strong>质。</strong></li>
</ol>
<h6 id="知识点详细讲解"><a href="#知识点详细讲解" class="headerlink" title="知识点详细讲解"></a><strong>知识点详细讲解</strong></h6><p><strong>1. x86&#x2F;x64基础指令</strong></p>
<ul>
<li><strong>mov</strong>: 用于将数据从一个位置移动到另一个位置。例如，<code>mov eax, 5</code> 将整数5加载到EAX寄存器中。</li>
<li><strong>push&#x2F;pop</strong>: 用于将数据压入栈或从栈中弹出。<code>push eax</code> 将EAX寄存器的值压入栈顶，<code>pop eax</code> 将栈顶的值弹出到EAX寄存器。</li>
<li><strong>call&#x2F;ret</strong>: <code>call</code> 用于调用一个函数，<code>ret</code> 用于从函数返回。<code>call label</code> 会将当前指令地址压入栈，然后跳转到<code>label</code>处执行代码；<code>ret</code> 会从栈中弹出地址并跳转回去。</li>
<li><strong>cmp&#x2F;jmp</strong>: <code>cmp</code> 用于比较两个操作数，<code>jmp</code> 用于无条件跳转。例如，<code>cmp eax, ebx</code> 会比较EAX和EBX寄存器的值，<code>je label</code> 会在相等时跳转到<code>label</code>。</li>
</ul>
<p><strong>2. 函数调用约定</strong></p>
<ul>
<li><strong>cdecl (C语言调用约定)</strong>: 调用者负责清理栈。参数从右到左压入栈，调用者在函数返回后清理栈。</li>
<li><strong>stdcall (标准调用约定)</strong>: 被调用函数负责清理栈。参数同样从右到左压入栈，但被调用函数会在返回前清理栈。</li>
<li><strong>fastcall</strong>: 使用寄存器传递前两个参数，剩余参数通过栈传递。这种约定提高了函数调用的效率。</li>
</ul>
<p><strong>3. 栈帧结构</strong></p>
<ul>
<li><strong>EBP&#x2F;RBP (基址指针)</strong>: 用于指向当前栈帧的底部。在函数调用时，EBP&#x2F;RBP通常用于保存上一个栈帧的基址，以便在函数返回时恢复。</li>
<li><strong>ESP&#x2F;RSP (栈指针)</strong>: 指向当前栈顶。在函数调用时，ESP&#x2F;RSP会随着<code>push</code>和<code>pop</code>指令的变化而移动。</li>
<li>栈帧是函数调用时在栈上分配的一块内存区域，用于存储局部变量、参数和返回地址。</li>
</ul>
<h6 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h6><p><strong>问题描述</strong>：编写一个简单的汇编程序，计算两个整数的和并返回结果。<br> <strong>分析</strong>：我们需要定义一个函数，接受两个整数作为参数，计算它们的和并返回结果。由于涉及函数调用，我们需要遵循调用约定（这里使用cdecl）。<br> <strong>为什么用该知识点</strong>：这个例子涉及x86&#x2F;x64基础指令（如<code>mov</code>、<code>push</code>、<code>call</code>、<code>ret</code>）、函数调用约定（cdecl）以及栈帧结构的使用。<br> <strong>应用过程</strong>：</p>
<ol>
<li>定义函数<code>add_two_numbers</code>，参数为<code>a</code>和<code>b</code>。</li>
<li>在函数内部，将<code>a</code>和<code>b</code>相加，结果存储在EAX寄存器中。</li>
<li>使用<code>ret</code>指令返回，调用者负责清理栈。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 调用add_two_numbers(5, 10)</span><br><span class="line">    push 10      ; 第二个参数</span><br><span class="line">    push 5       ; 第一个参数</span><br><span class="line">    call add_two_numbers</span><br><span class="line">    add esp, 8   ; 清理栈（2个参数，每个4字节）</span><br><span class="line">    ; 结果在EAX中</span><br><span class="line">    ; 退出程序</span><br><span class="line">    mov eax, 1   ; 系统调用号（exit）</span><br><span class="line">    int 0x80     ; 调用内核</span><br><span class="line"></span><br><span class="line">add_two_numbers:</span><br><span class="line">    push ebp     ; 保存上一个栈帧</span><br><span class="line">    mov ebp, esp ; 设置当前栈帧</span><br><span class="line">    mov eax, [ebp+8] ; 获取第一个参数</span><br><span class="line">    add eax, [ebp+12] ; 加上第二个参数</span><br><span class="line">    pop ebp     ; 恢复上一个栈帧</span><br><span class="line">    ret         ; 返回</span><br></pre></td></tr></table></figure>

<p><strong>计算结果</strong>：EAX寄存器中存储的值为15，即5 + 10的结果。</p>
<h6 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h6><ol>
<li><strong>汇编器与链接器</strong><br>  汇编器将汇编代码转换为机器码，链接器将多个目标文件合并为一个可执行文件。理解它们的工作原理有助于更好地掌握汇编编程的完整流程。</li>
<li><strong>逆向工程</strong><br>  通过分析可执行文件的机器码，还原出汇编代码甚至高级语言代码。逆向工程在安全、破解、调试等领域有重要应用。</li>
<li><strong>中断与异常处理</strong><br>  中断是CPU响应外部事件的一种机制，异常是CPU内部错误或特殊条件的处理。理解中断和异常处理有助于编写更健壮的汇编程序。</li>
<li><strong>多线程与并发编程</strong><br>  在汇编语言中实现多线程和并发编程需要深入理解CPU的上下文切换、锁机制、同步原语等。这是高级汇编编程的重要内容。</li>
<li><strong>优化技术</strong><br>  汇编语言允许程序员直接控制CPU指令的执行，因此可以通过优化指令顺序、减少内存访问、利用CPU特性等手段提升程序性能。</li>
</ol>
<h4 id="C语言逆向"><a href="#C语言逆向" class="headerlink" title="C语言逆向"></a>C语言逆向</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li>变量存储（栈、堆、全局区）</li>
<li>函数调用、循环和分支结构的汇编对应</li>
<li>简单逆向练习（如CrackMe题：尝试<a target="_blank" rel="noopener" href="https://crackmes.one/">Easy CrackMe</a>）</li>
</ul>
<h5 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h5><h6 id="背景知识介绍-1"><a href="#背景知识介绍-1" class="headerlink" title="背景知识介绍"></a><strong>背景知识介绍</strong></h6><ol>
<li><strong>计算机内存结构</strong>：计算机内存可以粗略分为代码区、数据区和未使用区。数据区又细分为栈区、堆区和静态存储区（包括全局区和静态局部变量区）。理解这些区域的划分和各自用途，是掌握变量存储的基础。</li>
<li><strong>函数调用栈</strong>：函数调用时，系统会在栈上为该函数创建一个栈帧，用于存储函数的局部变量、参数、返回地址等。随着函数的嵌套调用，栈会不断增长；函数返回时，对应的栈帧会被销毁，栈空间得以回收。这一过程是理解函数调用与栈关系的关键。</li>
<li><strong>动态内存管理</strong>：堆区是程序中用于动态内存分配的区域。通过malloc、calloc、realloc等函数，我们可以在运行时申请所需大小的内存块；使用完毕后，需要通过free函数释放，以避免内存泄漏。动态内存管理是编程中一项重要技能。</li>
<li><strong>汇编语言基础</strong>：汇编语言是与机器语言紧密相关的编程语言，它直接操作计算机硬件，包括寄存器、内存等。了解汇编语言的基本语法和指令集，有助于我们理解C语言代码如何被翻译成机器指令，以及这些指令如何在CPU上执行。</li>
<li><strong>逆向工程概念</strong>：逆向工程是指通过对目标程序的分析，推导出其源代码或逻辑结构的过程。在C语言逆向中，我们通常需要分析程序的二进制文件（如可执行文件或库文件），从中提取出有用的信息，如函数调用关系、变量布局等。这是理解C语言逆向基础的重要背景。</li>
</ol>
<h6 id="知识点详细讲解-1"><a href="#知识点详细讲解-1" class="headerlink" title="知识点详细讲解"></a>知识点详细讲解</h6><p><strong>变量存储</strong></p>
<ul>
<li><strong>栈区</strong>：栈是一种后进先出的数据结构，用于存储函数的局部变量、参数以及函数调用时的维护信息（如返回地址）。每当进入一个函数，系统就会在栈上为该函数分配一个栈帧；函数返回时，栈帧被销毁，栈空间得以回收。由于栈的先进后出特性，使得局部变量的生命周期与其所在函数的执行时间严格对应。此外，栈区的操作非常高效，因为只需要移动栈指针即可完成变量的分配和释放。</li>
<li><strong>堆区</strong>：堆是程序中一块预留的内存空间，用于动态内存分配。与栈不同，堆区的内存分配不受函数调用范围的限制，可以跨越多个函数甚至整个程序生命周期。通过malloc等函数申请的内存块，在没有被free释放之前，将一直有效。然而，这也意味着程序员需要手动管理堆区的内存，包括及时释放不再使用的内存块，以避免内存泄漏和碎片化问题。</li>
<li><strong>全局区</strong>：全局区用于存储全局变量和静态变量。这些变量在程序启动时即已分配内存，并在整个程序运行期间都存在。全局变量在所有文件中可见（需通过extern声明），而静态变量仅在其定义的作用域内可见但具有全局生命周期。全局区的内存分配和释放由操作系统负责，程序员无需显式管理。</li>
</ul>
<p><strong>函数调用与汇编对应</strong></p>
<p>当C语言中的函数被调用时，背后发生了一系列与汇编指令相关的动作。以x86架构为例，函数调用时通常会进行以下操作：</p>
<ul>
<li><strong>压栈</strong>：将函数的参数、返回地址以及调用者的上下文（如寄存器值）压入栈中。这些信息构成了被调函数的栈帧。</li>
<li><strong>跳转</strong>：通过call指令跳转到被调函数的起始地址执行代码。此时，CPU的指令指针寄存器（如EIP）指向被调函数的第一条指令。</li>
<li><strong>执行函数体</strong>：在函数体内，可以通过栈指针（如ESP）访问局部变量和参数；通过寄存器进行计算和数据处理。</li>
<li><strong>返回准备</strong>：函数执行完毕前，需要恢复调用者的上下文（如从栈中弹出寄存器值），并将返回值（如果有的话）放入指定的寄存器（如EAX）或内存位置。</li>
<li><strong>返回</strong>：通过ret指令从栈中弹出返回地址并跳转回去执行调用者代码。此时，被调函数的栈帧被销毁，栈空间得以回收。</li>
</ul>
<h6 id="实例分析：Easy-CrackMe"><a href="#实例分析：Easy-CrackMe" class="headerlink" title="实例分析：Easy CrackMe"></a>实例分析：Easy CrackMe</h6><p>为了更好地理解上述知识点，将通过一个简单的CrackMe题目来演示如何运用这些知识进行逆向分析。</p>
<p><strong>1. 问题描述</strong></p>
<p>假设我们有一个简单的C程序（CrackMe题），其功能是要求用户输入一个密码，如果密码正确则输出“Congratulations!”，否则输出“Try again!”。任务是通过逆向分析找出正确的密码。</p>
<p><strong>2. 分析步骤</strong></p>
<ul>
<li><strong>获取二进制文件</strong>：首先，我们需要获取该C程序的二进制文件（如可执行文件或库文件）。这通常是通过编译源代码得到的。</li>
<li><strong>反汇编</strong>：使用反汇编工具（如IDA Pro、Ghidra等）打开二进制文件，将其转化为汇编代码以便分析。这一步将帮助我们理解程序的逻辑结构和函数调用关系。</li>
<li><strong>查找关键函数</strong>：在反汇编后的代码中查找与用户输入和密码验证相关的函数。通常这些函数会包含字符串比较、条件判断等逻辑。通过分析这些函数的汇编代码，我们可以推断出密码的存储位置和比较方式。</li>
<li><strong>定位密码字符串</strong>：根据字符串比较函数的参数或硬编码的字符串常量定位到密码字符串所在的内存地址。这一步可能需要结合数据区分析和调试技巧来完成。</li>
<li><strong>验证密码</strong>：一旦找到密码字符串就可以尝试输入该密码看是否能够成功通过验证。如果程序输出“Congratulations!”则说明密码正确；否则需要重新分析或尝试其他可能的密码组合。</li>
</ul>
<p><strong>3. 示例应用</strong></p>
<p>假设通过反汇编分析我们发现密码字符串存储在数据区的某个位置且为明文存储（如”.data section”中的某个字符串常量）。我们可以直接读取该字符串作为密码尝试输入；如果程序验证通过则说明分析成功。当然实际情况可能更复杂一些比如密码可能经过加密处理或者隐藏在其他位置需要通过更深入的分析才能找到。但无论如何只要掌握了正确的分析方法和工具就一定能够找到解决问题的办法。</p>
<h6 id="扩展知识点-1"><a href="#扩展知识点-1" class="headerlink" title="扩展知识点"></a>扩展知识点</h6><ul>
<li><strong>调试技术</strong>：调试是逆向工程中不可或缺的一部分。通过调试工具（如GDB、WinDbg等）可以实时观察程序的运行状态、寄存器值、内存变化等信息从而帮助分析人员更准确地理解程序逻辑和定位问题所在。掌握调试技术对于提高逆向工程的效率和准确性具有重要意义。</li>
<li><strong>加密与解密技术</strong>：在逆向工程中经常会遇到加密和解密的问题。了解常见的加密算法（如AES、DES等）和解密技术可以帮助分析人员更好地理解和处理加密数据从而突破某些保护机制获取关键信息。此外还需要关注加密算法的实现细节和可能存在的安全漏洞以便在必要时进行利用或修复。</li>
<li><strong>漏洞挖掘与利用</strong>：漏洞挖掘与利用是信息安全领域中的一个重要分支也是逆向工程的一个重要应用场景。通过逆向工程技术可以发现软件中的漏洞并对其进行详细分析；同时结合漏洞利用技术可以实现对目标系统的渗透测试或攻击模拟从而评估系统的安全性并提出改进建议。需要注意的是漏洞挖掘与利用应遵守法律法规和道德规范不得用于非法目的。</li>
<li><strong>自动化脚本编写</strong>：在逆向工程中经常需要处理大量的重复性工作如日志分析、数据提取等。此时编写自动化脚本（如Python、Perl等）可以大大提高分析效率减少人为错误。掌握一定的脚本编程能力对于逆向工程师来说是一项非常重要的技能可以帮助他们更好地应对复杂的分析任务和挑战。</li>
<li><strong>跨平台逆向工程</strong>：随着移动互联网和物联网的快速发展应用程序越来越多地运行在不同的操作系统和硬件平台上。因此掌握跨平台逆向工程技能变得尤为重要。这包括了解不同平台的系统架构、指令集、调试工具以及逆向工程技术的差异等以便能够针对不同平台进行有效的逆向分析和攻击模拟。同时还需要关注新兴技术和趋势如人工智能、区块链等对逆向工程的影响和挑战以便及时调整自己的技能和知识结构适应行业发展的需求。</li>
</ul>
<h3 id="静态与动态分析"><a href="#静态与动态分析" class="headerlink" title="静态与动态分析"></a>静态与动态分析</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><ul>
<li>使用IDA Pro分析控制流图（CFG）</li>
<li>识别关键函数（如<code>main</code>、<code>check_flag</code>）</li>
<li>修改反汇编结果（IDA Patch功能）</li>
</ul>
<h5 id="详解-2"><a href="#详解-2" class="headerlink" title="详解"></a>详解</h5><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li>设置断点、观察寄存器&#x2F;内存变化</li>
<li>修改执行流程（如跳过<code>jz</code>跳转）</li>
<li>实战：调试带简单加密的CrackMe（如异或加密）</li>
</ul>
<h5 id="详解-3"><a href="#详解-3" class="headerlink" title="详解"></a>详解</h5><h4 id="常见加密算法识别"><a href="#常见加密算法识别" class="headerlink" title="常见加密算法识别"></a>常见加密算法识别</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li>固定异或（<code>xor eax, 0x1234</code>）</li>
<li>常量比较（如<code>strcmp</code>后的<code>test eax, eax</code>）</li>
<li>识别Base64、TEA、RC4、AES的特征代码</li>
</ul>
<h5 id="详解-4"><a href="#详解-4" class="headerlink" title="详解"></a>详解</h5><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Spontaneous_0/article/details/142087893">2024CTF入门指南、CTF夺旗赛及刷题网站-CSDN博客</a></p>
<h6 id="CTF-引言"><a href="#CTF-引言" class="headerlink" title="CTF 引言"></a><a target="_blank" rel="noopener" href="https://primer.picoctf.org/#_input_and_output">CTF 引言</a></h6> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://tangxtang1119.github.io/2025/04/26/CTF/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag">信息安全</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/04/27/oup/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            oup
          
        </div>
      </a>
    
    
      <a href="/2025/04/24/Android/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Android</div>
      </a>
    
  </nav>

   
 
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2025
        <i class="ri-heart-fill heart_icon"></i> 唐小唐
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/yuhangyuan.ico" alt="tangxtang"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2658106011&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>