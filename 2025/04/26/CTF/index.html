<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="‘有志少女 先读书’" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CTF |  tangxtang</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CTF"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CTF
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/04/26/CTF/" class="article-date">
  <time datetime="2025-04-25T16:00:00.000Z" itemprop="datePublished">2025-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">23.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">86 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="赛事介绍"><a href="#赛事介绍" class="headerlink" title="赛事介绍"></a>赛事介绍</h1><p>CTF（Capture The Flag），中文称为夺旗赛，是网络安全领域中一种备受关注和欢迎的竞赛形式。</p>
<h2 id="竞赛模式"><a href="#竞赛模式" class="headerlink" title="竞赛模式"></a>竞赛模式</h2><p>CTF 竞赛主要有以下几种模式：</p>
<h4 id="解题模式（Jeopardy）"><a href="#解题模式（Jeopardy）" class="headerlink" title="解题模式（Jeopardy）"></a><strong>解题模式（Jeopardy）</strong></h4><p>这是最常见的 CTF 模式。<br>比赛中会设置一系列不同类型和难度的题目，涵盖密码学、Web 安全、逆向工程、漏洞挖掘等多个领域。<br>每个题目对应一个分值，参赛队伍通过解题获取 Flag 并提交来得分。<br>比赛结束时，根据各队的总得分进行排名。</p>
<h4 id="攻防模式（Attack-Defense）"><a href="#攻防模式（Attack-Defense）" class="headerlink" title="攻防模式（Attack-Defense）"></a>攻防模式（Attack-Defense）</h4><p>参赛队伍在相互竞争的环境中进行攻击和防御。<br>每个队伍拥有自己的服务或系统需要防守，同时要尝试攻击其他队伍的服务来获取分数。<br>成功攻击其他队伍可得分，自己防守成功避免被攻击也能得分。<br>比赛过程中，分数实时变化，最终以比赛结束时的总分决定胜负。</p>
<h4 id="混合模式（Mix）"><a href="#混合模式（Mix）" class="headerlink" title="混合模式（Mix）"></a>混合模式（Mix）</h4><p>结合了解题模式和攻防模式的特点。<br>例如，先通过解题获得一定的初始分数，然后进入攻防阶段，根据攻防的表现来增减分数。</p>
<h4 id="靶场模式（Ranges）"><a href="#靶场模式（Ranges）" class="headerlink" title="靶场模式（Ranges）"></a>靶场模式（Ranges）</h4><p>提供一个模拟的网络环境或系统作为靶场。<br>参赛队伍需要在这个环境中发现漏洞、解决问题，并获取 Flag。<br>重点考察选手在实际场景中的渗透测试和漏洞修复能力。</p>
<h4 id="AWD-模式（Attack-With-Defense）"><a href="#AWD-模式（Attack-With-Defense）" class="headerlink" title="AWD 模式（Attack With Defense）"></a>AWD 模式（Attack With Defense）</h4><p>类似于攻防模式，但更强调实时性和连续性。<br>参赛队伍在攻击其他队伍的同时，要随时应对自己系统遭受的攻击并进行防御和修复。</p>
<p>不同的 CTF 竞赛模式各有特点，对参赛队伍的技术能力、团队协作和策略规划都有不同的要求。</p>
<h2 id="CTF各大题型简介"><a href="#CTF各大题型简介" class="headerlink" title="CTF各大题型简介"></a>CTF各大题型简介</h2><p>以下是 CTF 常见的各大题型的简介：</p>
<h4 id="密码学（Crypto）"><a href="#密码学（Crypto）" class="headerlink" title="密码学（Crypto）"></a>密码学（Crypto）</h4><p>涉及各种加密算法的分析和破解，包括对称加密（如 AES）、非对称加密（如 RSA）、哈希函数（如 MD5、SHA-256）等。<br>可能需要从密文或加密过程中推导出明文、找出密钥，或者验证数字签名的正确性。</p>
<h4 id="Web-安全（Web）"><a href="#Web-安全（Web）" class="headerlink" title="Web 安全（Web）"></a>Web 安全（Web）</h4><p>主要针对网站和 Web 应用程序的安全漏洞进行挖掘和利用。<br>常见的漏洞类型有 SQL 注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、文件包含漏洞、命令执行漏洞等。</p>
<h4 id="逆向工程（Reverse）"><a href="#逆向工程（Reverse）" class="headerlink" title="逆向工程（Reverse）"></a>逆向工程（Reverse）</h4><p>对给定的二进制文件、可执行程序或恶意软件进行分析和反编译。<br>目的是理解其工作原理、找出隐藏的逻辑、提取关键信息或破解其保护机制。</p>
<h4 id="漏洞挖掘与利用（Pwn）"><a href="#漏洞挖掘与利用（Pwn）" class="headerlink" title="漏洞挖掘与利用（Pwn）"></a>漏洞挖掘与利用（Pwn）</h4><p>专注于发现操作系统、软件或服务中的漏洞，并通过编写利用代码来获取系统的控制权。<br>常涉及缓冲区溢出、堆溢出、格式化字符串漏洞等。</p>
<h4 id="隐写术（Steganography）"><a href="#隐写术（Steganography）" class="headerlink" title="隐写术（Steganography）"></a>隐写术（Steganography）</h4><p>研究如何将信息隐藏在图像、音频、视频、文本等文件中而不引起注意。<br>参赛者需要找出隐藏的信息。</p>
<h4 id="移动安全（Mobile）"><a href="#移动安全（Mobile）" class="headerlink" title="移动安全（Mobile）"></a>移动安全（Mobile）</h4><p>针对安卓或 iOS 移动应用进行安全分析。<br>包括 APK 反编译、漏洞检测、权限滥用等方面。</p>
<h4 id="杂项（Misc）"><a href="#杂项（Misc）" class="headerlink" title="杂项（Misc）"></a>杂项（Misc）</h4><p>这是一个较为宽泛的类别，包含一些难以归类的题目。<br>可能涉及数据分析、编码解码、流量分析、游戏破解等各种独特的挑战。</p>
<h4 id="区块链安全（Blockchain）"><a href="#区块链安全（Blockchain）" class="headerlink" title="区块链安全（Blockchain）"></a>区块链安全（Blockchain）</h4><p>随着区块链技术的发展而出现的题型，涉及区块链中的加密算法、智能合约漏洞、私钥管理等方面的问题。</p>
<h4 id="取证分析（Forensics）"><a href="#取证分析（Forensics）" class="headerlink" title="取证分析（Forensics）"></a>取证分析（Forensics）</h4><p>从给定的系统镜像、网络流量、日志文件等数据中提取和分析有价值的信息，以找出与安全相关的线索或证据。<br>不同的 CTF 比赛可能会根据主题和难度对这些题型进行调整和创新。</p>
<h2 id="赛题情况分析"><a href="#赛题情况分析" class="headerlink" title="赛题情况分析"></a>赛题情况分析</h2><h3 id="赛题难度分布"><a href="#赛题难度分布" class="headerlink" title="赛题难度分布"></a>赛题难度分布</h3><p>CTF 赛题通常会涵盖从简单到困难的不同难度级别。</p>
<h4 id="1-简单题目："><a href="#1-简单题目：" class="headerlink" title="1.简单题目："></a>1.简单题目：</h4><p>主要针对基础知识和常见技术，旨在帮助新手入门和积累经验。<br>例如，一些基本的密码学加密算法的简单应用，或者明显的 Web 漏洞。</p>
<h4 id="2-中等难度题目："><a href="#2-中等难度题目：" class="headerlink" title="2.中等难度题目："></a>2.中等难度题目：</h4><p>要求参赛者对特定领域有一定的深入理解和实践经验。<br>可能是复杂一些的密码分析，或者需要综合运用多种技术的 Web 安全挑战。</p>
<h4 id="3-困难题目："><a href="#3-困难题目：" class="headerlink" title="3.困难题目："></a>3.困难题目：</h4><p>往往涉及前沿技术、罕见漏洞或者复杂的加密算法。<br>这类题目通常只有少数顶尖团队能够解决。</p>
<h3 id="赛题类型比例"><a href="#赛题类型比例" class="headerlink" title="赛题类型比例"></a>赛题类型比例</h3><p>不同类型的题目在比赛中的比例会根据赛事的侧重点和目标受众有所不同。</p>
<h4 id="1-密码学题目"><a href="#1-密码学题目" class="headerlink" title="1.密码学题目"></a>1.密码学题目</h4><p>一般会占有一定比例，通常在 15%-25%之间。<br>以检验参赛者对加密算法的理解和分析能力。</p>
<h4 id="2-Web-安全题目"><a href="#2-Web-安全题目" class="headerlink" title="2.Web 安全题目"></a>2.Web 安全题目</h4><p>是常见且重要的类型，比例可能在 20%-30%左右。<br>反映了 Web 应用在网络中的广泛应用和面临的安全威胁。</p>
<h4 id="3-逆向工程和漏洞挖掘利用题目"><a href="#3-逆向工程和漏洞挖掘利用题目" class="headerlink" title="3.逆向工程和漏洞挖掘利用题目"></a>3.逆向工程和漏洞挖掘利用题目</h4><p>合计可能占 20%-30%。<br>对参赛者的底层技术理解和实践能力有较高要求。</p>
<h4 id="4-其他类型（如隐写术、移动安全、杂项等）"><a href="#4-其他类型（如隐写术、移动安全、杂项等）" class="headerlink" title="4.其他类型（如隐写术、移动安全、杂项等）"></a>4.其他类型（如隐写术、移动安全、杂项等）</h4><p>总共约占 15%-25%。<br>用于增加比赛的多样性和全面性。</p>
<h3 id="赛题的创新性"><a href="#赛题的创新性" class="headerlink" title="赛题的创新性"></a>赛题的创新性</h3><p>为了保持比赛的吸引力和挑战性，CTF 赛题不断推陈出新。</p>
<h4 id="1-结合新的技术趋势："><a href="#1-结合新的技术趋势：" class="headerlink" title="1.结合新的技术趋势："></a>1.结合新的技术趋势：</h4><p>例如，随着人工智能和物联网的发展，出现了与这些领域相关的安全挑战题目。</p>
<h4 id="2-独特的场景设计："><a href="#2-独特的场景设计：" class="headerlink" title="2.独特的场景设计："></a>2.独特的场景设计：</h4><p>构建新颖的网络环境或应用场景，让参赛者在不熟悉的情况下进行分析和解决问题。</p>
<h4 id="3-跨领域综合题目："><a href="#3-跨领域综合题目：" class="headerlink" title="3.跨领域综合题目："></a>3.跨领域综合题目：</h4><p>融合多种技术领域，要求参赛者具备综合运用不同知识和技能的能力。</p>
<h3 id="赛题的时效性"><a href="#赛题的时效性" class="headerlink" title="赛题的时效性"></a>赛题的时效性</h3><h4 id="1-反映当前热点安全问题"><a href="#1-反映当前热点安全问题" class="headerlink" title="1.反映当前热点安全问题"></a>1.反映当前热点安全问题</h4><p>例如，近期出现的新型网络攻击手法或重大安全漏洞可能会被改编成赛题。</p>
<h4 id="2-跟进技术发展"><a href="#2-跟进技术发展" class="headerlink" title="2.跟进技术发展"></a>2.跟进技术发展</h4><p>随着新的加密算法、开发框架等的出现，相应的题目也会更新。</p>
<h2 id="赛题的隐蔽性和误导性"><a href="#赛题的隐蔽性和误导性" class="headerlink" title="赛题的隐蔽性和误导性"></a>赛题的隐蔽性和误导性</h2><h3 id="1-隐蔽性："><a href="#1-隐蔽性：" class="headerlink" title="1.隐蔽性："></a>1.隐蔽性：</h3><p>关键信息可能隐藏在大量的无关数据中，需要参赛者仔细筛选和分析。</p>
<h3 id="2-误导性："><a href="#2-误导性：" class="headerlink" title="2.误导性："></a>2.误导性：</h3><p>题目可能设置一些虚假的线索或干扰项，考验参赛者的判断力和排除干扰的能力。</p>
<p>综上所述，CTF 赛题在难度、类型、创新性、时效性、隐蔽性等方面都具有多样化的特点，需要参赛者具备扎实的知识基础、丰富的实践经验、创新的思维和敏锐的洞察力。</p>
<h2 id="CTF学习路线"><a href="#CTF学习路线" class="headerlink" title="CTF学习路线"></a>CTF学习路线</h2><h3 id="基础知识储备"><a href="#基础知识储备" class="headerlink" title="基础知识储备"></a>基础知识储备</h3><h4 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1.编程语言"></a>1.编程语言</h4><p>Python：掌握基本语法、数据结构、文件操作等。<br>C&#x2F;C++：了解底层编程和内存操作。</p>
<h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2.计算机网络"></a>2.计算机网络</h4><p>熟悉 TCP&#x2F;IP 协议栈、IP 地址、端口、路由等概念。<br>学习网络抓包工具如 Wireshark 的使用。</p>
<h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3.操作系统"></a>3.操作系统</h4><p>掌握 Linux 基本命令和操作。<br>了解 Windows 系统的常见设置和安全机制。</p>
<h4 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h4><p>学习 SQL 语言，了解常见的数据库漏洞。</p>
<h3 id="专业知识学习"><a href="#专业知识学习" class="headerlink" title="专业知识学习"></a>专业知识学习</h3><h4 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1.密码学"></a>1.密码学</h4><p>学习常见的加密算法（对称加密如 AES，非对称加密如 RSA）。<br>了解哈希函数、数字签名等概念。</p>
<h4 id="2-Web-安全"><a href="#2-Web-安全" class="headerlink" title="2.Web 安全"></a>2.Web 安全</h4><p>掌握 HTTP 协议。<br>学习常见的 Web 漏洞（SQL 注入、XSS、CSRF 等）。<br>熟悉 Web 应用防火墙（WAF）的原理。</p>
<h4 id="3-逆向工程"><a href="#3-逆向工程" class="headerlink" title="3.逆向工程"></a>3.逆向工程</h4><p>学习汇编语言。<br>掌握反编译工具（如 IDA Pro）的使用。</p>
<h4 id="4-漏洞挖掘与利用"><a href="#4-漏洞挖掘与利用" class="headerlink" title="4.漏洞挖掘与利用"></a>4.漏洞挖掘与利用</h4><p>了解缓冲区溢出、堆溢出等原理。<br>学习漏洞利用框架（如 Metasploit）。</p>
<h4 id="5-移动安全"><a href="#5-移动安全" class="headerlink" title="5.移动安全"></a>5.移动安全</h4><p>熟悉安卓和 iOS 系统的架构。<br>学习移动应用的安全分析方法。</p>
<h3 id="实践与练习"><a href="#实践与练习" class="headerlink" title="实践与练习"></a>实践与练习</h3><p>参加线上 CTF 平台的练习赛，如 HackTheBox、CTFTime 等。<br>分析他人的 Write-up，学习解题思路和技巧。<br>自己搭建实验环境，复现和练习常见的漏洞利用。</p>
<h3 id="深入学习与拓展"><a href="#深入学习与拓展" class="headerlink" title="深入学习与拓展"></a>深入学习与拓展</h3><p>研究前沿的安全技术和研究成果。<br>参与开源安全项目，贡献代码和发现。<br>关注安全领域的博客、论坛和会议，了解最新动态。</p>
<h3 id="团队协作与交流"><a href="#团队协作与交流" class="headerlink" title="团队协作与交流"></a>团队协作与交流</h3><p>加入 CTF 团队，与队友共同训练和参赛。<br>积极参与团队内部的讨论和分享，提高协作能力。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="网络漏洞"><a href="#网络漏洞" class="headerlink" title="网络漏洞"></a>网络漏洞</h2><h3 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h3><p>JavaScript 仅在浏览器中执行。</p>
<p>如果想在远程服务器中进行计算并将数据存储，该怎么办？例如，当登录网站时，必须在服务器上验证用户和密码。密码存储在服务器中，为了安全起见，不应从服务器外传输。</p>
<p>如果你在 JavaScript 上验证密码，你将能够在浏览器上看到它，就像你看到任何 JavaScript 一样，这将是非常不安全的。有几种编程语言可以在服务器上执行，例如：</p>
<ul>
<li>python</li>
<li>java</li>
<li>等等</li>
</ul>
<p>对于示例，将开始使用 PHP，不是因为认为它是一种很棒的语言，而是因为 Internet 上的大量网站都在使用它，并且它非常易于学习和部署。</p>
<p>假设有一个名为 hello.php 的文本文件，其中包含：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="title function_">alert</span>(<span class="string">&#x27;Hello World from JavaScript!&#x27;</span>); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">    echo &quot;Hello World from PHP!&quot;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，在扩展名为 .php 的文件中，可以混合使用 html、JavaScript 和 PHP 代码！如果服务器支持 PHP，<strong>那么 <php ></strong> 里面的所有内容都会被理解为 PHP 代码，并由服务器运行，而不是由浏览器运行。</p>
<p>如果在笔记本电脑上打开包含该内容的文件，则不会执行 PHP 代码，因为笔记本电脑不是 PHP 服务器（如果尚未将其设为 PHP 服务器）。因此，要执行 PHP，需要将笔记本电脑设为服务器。但目前，可以使用以下内容：<a target="_blank" rel="noopener" href="https://www.w3schools.com/php/phptryit.asp?filename=tryphp_intro">W3Schools Tryit Editor</a></p>
<p>访问该链接，将在右侧看到一个包含 html 和 PHP 代码的文件，运行时，打印“我的第一个 PHP 脚本！让修改代码以额外打印日期，因此在行下方</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My first PHP script!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>添加行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(<span class="string">&quot;H:i:s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>PHP 是服务器端代码，因此时间从服务器上的时钟开始！</p>
<p>现在做一个实验，并添加另一行带有此 php 代码的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt; alert(&#x27;Hello World from JavaScript!&#x27;); &lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在 PHP 中回显的字符串具有 JavaScript 代码。是否显示 JavaScript 警报？发生了什么事？正如预期的那样，在 php 上打印的任何内容都将成为 html 下载文件的组成部分，因此将执行 JavaScript。这为著名的跨站点脚本 （XSS） 攻击打开了大门。</p>
<h3 id="跨站脚本-（XSS）"><a href="#跨站脚本-（XSS）" class="headerlink" title="跨站脚本 （XSS）"></a>跨站脚本 （XSS）</h3><p>登录网站后，网站需要一种方法来知道来自自己浏览器的任何请求都来自之前登录的用户，而无需再次发送用户密码。为此，该网站可以在登录后向浏览器发送一个秘密随机值。该值通常存储在 Cookie 或 JavaScript 本地存储中。对于此示例，假设它存储在 cookie 中，而 cookie 只是浏览器中可以保留数据的变量。如果网站在浏览器中设置了特定的 Cookie，则浏览器会在向网站的每个请求中自动重新发送该 Cookie。如果网站仅使用 cookie 来保留会话，并且如果黑客可以从这儿窃取身份验证 cookie，他们就可以冒充！请注意，仅使用 cookie 进行身份验证会打开跨站点请求伪造 （CSRF） 的可能性，但这将在后面解释，现在专注于 XSS。</p>
<p>假设是社交网络中的黑客。创建帐户时，输入的不是自己姓名，而是 JavaScript 代码。当朋友访问自己个人资料时，网站将尝试打印姓名，但姓名实际上是 JavaScript 代码，因此浏览器可能会执行该 JavaScript 代码。这样，就可以在朋友的浏览器上执行自己的 JavaScript！</p>
<p>当在其他人的浏览器中执行 JavaScript 时，可以读取他们的身份验证数据，这些数据可以是用户登录后放置在 cookie 或 JavaScript 本地存储上的秘密值。那时，朋友的帐户可能会被盗用！</p>
<p>需要具备的一项重要技能是使用浏览器调试器。对于此解释，将使用 Firefox。可以在此处下载并安装 Firefox：<a target="_blank" rel="noopener" href="https://www.mozilla.org/en-US/firefox/new/">https://www.mozilla.org/en-US/firefox/new/</a></p>
<p>注意：如果真的不想使用 Firefox，每个浏览器都有一个调试器，可以在 google 上搜索如何使用它。不会有那么不同。</p>
<p>使用 Firefox，在以下链接的描述中输入姓名和一些文本：</p>
<p><a target="_blank" rel="noopener" href="https://primer.picoctf.org/vuln/web/sign_up.php">https://primer.picoctf.org/vuln/web/sign_up.php</a></p>
<p>打开另一个选项卡并访问以下链接。应该会看到姓名和描述：</p>
<p><a target="_blank" rel="noopener" href="https://primer.picoctf.org/vuln/web/tableusers.php">https://primer.picoctf.org/vuln/web/tableusers.php</a></p>
<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><p>密码学是一个古老的领域，可以追溯到古罗马。从词源上讲，这个词可以追溯到希腊词根“kryptos”，意思是“隐藏的”，而“graphein”的意思是“写”。它用于在敌人面前秘密通信。使用加密技术，可以在发送消息时实现以下属性：</p>
<ul>
<li>机密性：任何人都无法意外地阅读该消息。</li>
<li>完整性：如果消息被篡改，则可以检测到它被篡改。</li>
<li>鉴权：可以准确验证个人身份。</li>
<li>不可否认性：如果某人发送了特定消息，则该人无法否认该消息是由他们发送的。</li>
</ul>
<p>首先，将了解如何实现机密性。这是通过加密完成的。当想隐藏一条消息时，加密了消息。要了解加密的工作原理，将看到一个加密消息的古老方法的示例，该方法在今天无论如何都不安全，但它很适合说明。但首先，为了练习终端技能，将在 linux 中加密一个文件夹，以防止任何人在没有适当密码的情况下读取其内容。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>要在现实生活中使用加密，永远不应该使用自己的 implementations。首先，将演示如何在没有任何密码学知识的情况下加密文件。转到 picoCTF Webshell：<a target="_blank" rel="noopener" href="https://webshell.picoctf.org/">https://webshell.picoctf.org/</a></p>
<p>到达后创建一个包含自己名字的文件“tangxtang.txt”。可以使用 ‘ nano’编辑器，但在linux中可以执行以下技巧：</p>
<p>运行以下命令创建文本文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tangxtang&quot; &gt; tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>‘echo’ 命令只输出一个字符串，将该输出重定向到一个文件。例如，如果只运行</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tangxtang&quot;</span><br></pre></td></tr></table></figure>

<p>只会在屏幕上看到 ‘samuel’ 的印刷。现在运行：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>将看到自己创建的文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>如果运行以下命令：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat tangxtang.txt</span><br></pre></td></tr></table></figure>

<p>将看到以下内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat tangxtang.txt</span><br><span class="line">tangxtang</span><br></pre></td></tr></table></figure>

<p>现在，使用姓氏创建另一个名为 ‘tang.txt’ 的文件。可以使用相同的技术来创建 ‘tang.txt：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;pardo&quot; &gt; tang.txt</span><br></pre></td></tr></table></figure>

<p>将这两个文件移动到以一个新文件夹，然后压缩该文件夹，然后对其进行加密！压缩文件夹只会使多个文件或文件夹显示为单个文件，他们占用的磁盘空间会更少，但压缩不提供任何安全性。任何人都可以简单的解压它并查看原始内容。但是，加密会阻止在没有密钥的情况下获取原始内容。要进行该实验，先创建一个名为my info的目录：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_info</span><br></pre></td></tr></table></figure>

<p>并使用命令 mv （mv 表示移动） 将两个文件移动到内部：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv tangxtang.txt my_info/</span><br><span class="line">mv tang.txt my_info/</span><br></pre></td></tr></table></figure>

<p>导航到文件夹“my_info”并确保它包含文件。现在，回到my_info文件夹之外，通过运行将文件夹压缩成一个 zip 文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r my_info.zip my_info/</span><br></pre></td></tr></table></figure>

<p>请注意，my_info.zip 是为压缩文件选择的名称，而 ‘-r’ 表示递归，在本例中，这意味着想要压缩文件夹中的所有内容。如果运行应该会看到文件夹和压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info  my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在通过运行以下命令删除文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r my_info</span><br></pre></td></tr></table></figure>

<p>‘rm’ 表示删除，’-r’ 表示递归，表示想要删除文件夹中的所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r my_info</span><br></pre></td></tr></table></figure>

<p>现在，如果运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>应该只看到压缩文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info.zip</span><br></pre></td></tr></table></figure>

<p>可以通过运行以下命令轻松解压缩文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip my_info.zip</span><br></pre></td></tr></table></figure>

<p>并获取原始文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">my_info  my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在，创建一个受加密保护的 zip 文件，这样它就不能在没有密钥的情况下解压缩。在这种情况下，“key”和“password”这两个词是同义词。</p>
<p>首先删除已经通过运行创建的 .zip 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm my_info.zip</span><br></pre></td></tr></table></figure>

<p>现在，使用以下命令使用密码创建加密的 zip：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip --encrypt -r my_protected_info.zip my_info/</span><br></pre></td></tr></table></figure>

<p>系统将要求输入密码并验证密码，因此请记住使用的密码，以便稍后能够解密它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip --encrypt -r my_protected_info.zip my_info/</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">  adding: my_info/ (stored 0%)</span><br><span class="line">  adding: my_info/my_name.txt (stored 0%)</span><br><span class="line">  adding: my_info/my_lastname.txt (stored 0%)</span><br></pre></td></tr></table></figure>

<p>如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip my_protected_info.zip</span><br></pre></td></tr></table></figure>

<p>它会询问密码，只有输入正确的密码，才会找回原始内容！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Archive:  my_protected_info.zip</span><br><span class="line">   creating: my_info/</span><br><span class="line">[my_protected_info.zip] my_info/my_name.txt password:</span><br><span class="line"> extracting: my_info/my_name.txt</span><br><span class="line"> extracting: my_info/my_lastname.txt</span><br></pre></td></tr></table></figure>

<p>没有密码就无法获取原始内容，因为它用于对内容执行作以获取生成的加密文件。此时，可能不知道发生了什么。有许多加密算法，这些算法是从古罗马时代开始创建的。如今，旧的数据加密方法很容易被打破。如今，即使是相对较新的数据加密方法也很容易被破解。其中一些现在被认为是牢不可破的，但将来会损坏。</p>
<h3 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h3><p>“密码”是指一种秘密或伪装的编写消息的方式。它可以被认为与加密相同。一种在古罗马发明并以皇帝尤利乌斯·凯撒 （Julius Caesar） 的名字命名的密码方法是凯撒密码，他将其用于私人通信。此密码只是将一个单词的每个字母替换为另一个字母，该字母在字母表中的位置具有一定数量。这个 “一定数量的位置” 称为 shift 。</p>
<p>例如，如果有单词 “hello” 并且想使用 Caesar 密码对其进行加密，并且偏移量为 3，会将 ‘h’ 替换为 ‘k’，因为 ‘k’ 在字母表中的位置更高 3 位，出于同样的原因，将 ‘e’ 替换为 ‘h’，依此类推。将要加密的原始文本称为明文或明文。使用 Caesar’s 加密 ‘hello’ （偏移量为 3）的结果如下：</p>
<p>明文 → h e l l o</p>
<p>加密文本 → k h o o r</p>
<p><strong>“解密”是指从加密文本中获取明文。</strong>对于 Caesar 的密码，只需执行相同的作，但要相反;将字母表中的每个字母减去 3 个位置。</p>
<p>请注意，<strong>当在加密某些内容时添加位置后到达字母表的末尾时，只是重叠了字母表</strong>。例如，要加密字母 ‘z’，将使用字母 ‘c’ 对其进行加密。</p>
<p>Caesar 的密码是一种<strong>替换密码</strong>，因为它将每个字母替换为其他字母。在替换密码中，不一定需要用另一个字母替换一个字母。如果知道如何反转它，可以使用任何符号。</p>
<p>将使用一个 python 代码，该代码使用 Caesar 密码仅加密和解密小写字母。这是它的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">def caesar_encrypt(text):</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 遍历for循环中文本的每个字符</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line"></span><br><span class="line">        # 通过word获取ASCII值</span><br><span class="line">        char_position = ord(text[i])</span><br><span class="line"></span><br><span class="line">        #减去97得到一个从1到26的字符</span><br><span class="line">        char_position = char_position - 97</span><br><span class="line"></span><br><span class="line">        # 偏移量为 3</span><br><span class="line">        new_char_position = char_position + 3</span><br><span class="line"></span><br><span class="line">        # 确保位置不超过26</span><br><span class="line">        new_char_position = new_char_position % 26</span><br><span class="line"></span><br><span class="line">        # 转换回ASCII值</span><br><span class="line">        new_char_position = new_char_position + 97</span><br><span class="line"></span><br><span class="line">        #将ASCII值转换为字符并将其连接到最终结果</span><br><span class="line">        result = result + chr(new_char_position)</span><br><span class="line"></span><br><span class="line">        print(result)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def caesar_decrypt(cipher_text):</span><br><span class="line">    result = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    #遍历for循环中文本的每个字符</span><br><span class="line">    for i in range(len(cipher_text)):</span><br><span class="line"></span><br><span class="line">        # 通过word获取ASCII值</span><br><span class="line">        char_position = ord(cipher_text[i])</span><br><span class="line"></span><br><span class="line">        # 减去97得到一个从1到26的字符</span><br><span class="line">        char_position = char_position - 97</span><br><span class="line"></span><br><span class="line">        # 偏移量为 3</span><br><span class="line">        new_char_position = char_position - 3</span><br><span class="line"></span><br><span class="line">        # 确保位置不超过26</span><br><span class="line">        new_char_position = new_char_position % 26</span><br><span class="line"></span><br><span class="line">        # 转换回ASCII值</span><br><span class="line">        new_char_position = new_char_position + 97</span><br><span class="line"></span><br><span class="line">        #将ASCII值转换为字符并将其连接到最终结果</span><br><span class="line">        result = result + chr(new_char_position)</span><br><span class="line"></span><br><span class="line">        print(result)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">text = &quot;picoctf&quot;</span><br><span class="line">print(f&quot;Plain Text: &#123;text&#125;&quot;)</span><br><span class="line">cipher_text = caesar_encrypt(text)</span><br><span class="line">print(f&quot;Encrypted: &#123;cipher_text&#125;&quot;)</span><br><span class="line">print(f&quot;Decrypted: &#123;caesar_decrypt(cipher_text)&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>应该会看到以下输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Plain Text: picoctf</span><br><span class="line">s</span><br><span class="line">sl</span><br><span class="line">slf</span><br><span class="line">slfr</span><br><span class="line">slfrf</span><br><span class="line">slfrfw</span><br><span class="line">slfrfwi</span><br><span class="line">Encrypted: slfrfwi</span><br><span class="line">p</span><br><span class="line">pi</span><br><span class="line">pic</span><br><span class="line">pico</span><br><span class="line">picoc</span><br><span class="line">picoct</span><br><span class="line">picoctf</span><br><span class="line">Decrypted: picoctf</span><br></pre></td></tr></table></figure>

<h3 id="换位密码"><a href="#换位密码" class="headerlink" title="换位密码"></a>换位密码</h3><p>在换位密码中，不会用其他符号替换字母，而只是改变在明文上的显示顺序。例如，可以决定加密算法只是将字母向右移动并重叠。通过将单词 ‘pico’ 的字母向右旋转一个位置来加密单词 ‘pico’。</p>
<p>明文 → p i c o</p>
<p>加密文本 → o p i c</p>
<p>这是一种非常简单的换位。但是可以有一个进行更复杂的换调的映射。例如，可以决定使用以下映射以 6 个字母为块进行转置来加密文本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202504261633232.png"></p>
<p>数字表示字母的位置。使用该映射，对单词 ‘pico’ 进行加密。由于 pico 只有 4 个字母，可以简单地使用填充来完成，直到 6 个字母。在这个例子中，将使用符号 * 作为填充，所以有：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%BA%94%E7%94%A8%E5%B8%A6%E5%A1%AB%E5%85%85%E7%9A%84%E6%98%A0%E5%B0%84.png"></p>
<p>加密的单词是 ‘c*ip*o’，使用任意定义的映射。假设想要加密一个长文本。在这种情况下，只需每 6 个字符应用相同的映射。</p>
<p>到目前为止，已经了解了转置和替换密码的工作原理。如果它们只自己使用，它们很容易破解。另一方面，如果有人发现了用来加密的算法，加密就永远被打破了！改善这种情况的一种方法是使用基于密钥的加密算法。</p>
<h3 id="密钥密码"><a href="#密钥密码" class="headerlink" title="密钥密码"></a>密钥密码</h3><p>密码学中有一条原则叫做 Kerckhoffs 原则，它指出：“即使关于系统的所有内容（除了密钥）都是公共知识，密码系统也应该是安全的”。</p>
<p>该原则声称要克服这样一个事实，即一旦敌人知道加密算法，加密就会被破坏。解决方案是使用密钥。一种用于使用密钥加密数据的旧算法是“Vigenere”。它看起来肯定比之前学习的算法更强大。尽管它现在很容易破碎，但在当时它被认为是牢不可破的。</p>
<p>为了了解 Vigenere 的工作原理，将加密明文:</p>
<p>“I LOVE PITTSBURGH”</p>
<p>首先，删除空格，因为 Vigenere 表没有空格。但是，即使文本没有空格，人类也可以轻松识别文本中的单词。得到：</p>
<p>“ILOVEPITTSBURGH”</p>
<p>现在，可以选择一个密钥。在这个示例中，将使用密钥“PICOCTF”。由于文本比密钥长，只需重复密钥几次，直到长度相同，具体方式如下：</p>
<p>明文：ILOVEPITTSBURGH</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p><strong>明文的第一个字母与密钥的第一个字母配对。</strong>因此，得到配对（’I’，’P’）。现在，在下面给出的维吉尼亚密码表中，使用第 i 行和第 p 列。该列和该行的交叉单元格将是加密后的字母，在这种情况下是 X。对剩余的字母重复同样的操作，最终会得到以下结果：</p>
<p>明文：ILOVEPITTSBURGH</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p>加密文本：XTQJGINIBUPWKLW</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/Vigenere%E8%A1%A8.png"></p>
<p>现在来看看解密是如何工作的。假设只有 key 和 encrypted：</p>
<p>密钥：PICOCTFPICOCTFP</p>
<p>加密文本：XTQJGINIBUPWKLW</p>
<p>取键的第一个字母，即 ‘P’，然后转到 vigenere 表中的该行。然后在 ‘P’ 行中，找到加密文本的第一个字母，即 ‘X’。对应于 ‘X’ 的列是明文的第一个字母，在例子中是 ‘I’。对每个角色重复相同的过程，直到得到 ‘ILOVEPITSBURGH’。</p>
<p>即使没有电脑，Vigenere 也很容易被打破。著名的科学传播者 Simon Singh 在他的网站上有一个破解 Vigenere 的好工具：</p>
<p><a target="_blank" rel="noopener" href="https://www.simonsingh.net/The_Black_Chamber/vigenere_cracking_tool.html">https://www.simonsingh.net/The_Black_Chamber/vigenere_cracking_tool.html</a></p>
<p>破解密码本身就是一个称为密码分析的领域。密码分析和密码学构成了更大的领域，称为密码学。</p>
<h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><p>在现代密码学中存在对称和非对称密码学的概念。对称加密意味着使用相同的密钥进行加密和解密，就像刚刚在 Vigenere 上所做的那样。在非对称加密中，有两个密钥。一个用于加密，称为公钥，另一个用于解密，称为私钥。非对称加密技术很有用，因为它可用于解决密钥交换问题。此外，它还可用于提供完整性和不可否认性的数字签名。</p>
<h4 id="对称加密示例：AES"><a href="#对称加密示例：AES" class="headerlink" title="对称加密示例：AES"></a>对称加密示例：AES</h4><p>当今对称加密的常用算法是 AES，意思是“高级加密标准”。此算法使用固定长度的 key 组合替换和转置。固定长度的 key 意味着算法只能有一定大小的 key。但是，AES 有不同的版本，每个版本可以支持不同大小的密钥长度。最常见的版本是 AES 128 和 AES 256，它们的密钥长度分别为 128 位和 AES 256。AES 算法被认为是安全的。但是，如果实现存在缺陷，则可以成功攻击该实现。例如，破解 AES 加密的一种著名方法是 Padding Oracle Attack，它可以成功破解 SSL，这是一种广泛用于保护 HTTP 流量的加密协议。然而，这不是 AES 的弱点，而是它使用方式的弱点。</p>
<p>AES 有不同的作模式。将分析其中两个，以说明它们在使用过程中可能出现的漏洞。这些作模式是 “ECB” 和 “CBC”。</p>
<h5 id="作模式-ECB"><a href="#作模式-ECB" class="headerlink" title="作模式 ECB"></a>作模式 ECB</h5><p><strong>ECB 表示 电子密码簿。</strong>在这种作模式下，根据密钥长度独立加密明文的块。例如，如果使用 AES 128，将明文分成 128 位的块，并使用 AES 独立加密它们。这会导致问题，因为它会泄露加密文本中的结构。</p>
<p>假设正在发送加密文本，并且知道前 128 位包含名称，后 128 位包含日期。假设是一名攻击者，在不同日期捕获了一些加密邮件。即使不知道密钥，也可以交换第二个消息块以篡改日期。</p>
<p>ECB 的另一个问题是，如果将相同的消息发送两次，任何攻击者都可以看到相同的消息正在再次发送。安全的加密算法不应泄露有关消息的任何信息。知道过去发送了相同的消息可用于了解有关通信的详细信息。<strong>建议永远不要使用 ECB。</strong></p>
<h5 id="作模式-CBC"><a href="#作模式-CBC" class="headerlink" title="作模式 CBC"></a>作模式 CBC</h5><p>更安全的作模式是 CBC，即密码块链接。在此模式下，包含其他元素。第一个是初始化向量，一个与键大小相同的随机值。在 AES 中，密钥大小与块大小相同。请记住，在 AES 中，必须将明文分隔为与密钥大小相同的块。在开始加密之前，在第一个明文块和初始化向量之间进行 XOR，然后开始使用 AES 和选择的密钥进行加密。每条消息的初始化向量都不同，因此如果两次发送相同的消息，它会因初始化向量而有所不同。必须将初始化向量附加到消息中。在此作模式中添加的另一个元素是，不单独加密区块，而是使用一个区块中的加密文本，并将其与要加密的下一个明文区块进行 XOR 运算。然后，使用 AES 和密钥来加密该结果。在下图中，显示了刚才解释的图形表示，请注意，带有叉号的圆圈表示 XOR：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/CBC%E5%9B%BE.png"></p>
<p> AES 中，明文的大小必须与块大小的倍数相同。例如，如果你有一个恰好短于块的明文，则需要向明文添加填充，以便它至少匹配一个块。如果明文大于一个块，但小于两个块，则需要向明文添加填充，直到它与两个块的大小相同。在 AES 中，有一种常见的填充方式，称为 PKCS #7 的标准。在 AES 128 中，正如我们之前所说，块大小为 128 位，相当于 16 字节。假设要加密消息：</p>
<p>“HELLOPICOCTF”</p>
<p>由于该消息是 12 字节，因此我们需要添加 4 字节的填充来完成块的大小。在 PKCS#7 中，使用字节添加填充，其中包含需要填充的字节值。在我们的示例中，由于我们需要填充 4 个字节才能完成 16 个字节，因此我们将像这样填充：</p>
<p>“HELLOPICOCTF”+“\x04\x04\x04\x04”</p>
<p>请注意，“\x” 是一种表示在字符串中我们想在字节上使用确切数字的方法，即使它不是可打印的 ASCII。现在，假设我们要加密一条 15 字节的消息，如下所示：</p>
<p>“GOODBYEPICOCTF!”</p>
<p>使用 PKCS#7 填充后，结果是：</p>
<p>“GOODBYEPICOCTF!”+”\x01”</p>
<p>填充消息 “BYEPICOCTF” 后会有什么结果？</p>
<p>“BYEPICOCTF”+”\x06\x06\x06\x06\x06\x06”</p>
<p>是对的。</p>
<h4 id="非对称加密示例：RSA"><a href="#非对称加密示例：RSA" class="headerlink" title="非对称加密示例：RSA"></a>非对称加密示例：RSA</h4><p>请记住，非对称加密意味着使用一个密钥进行加密（公钥），使用另一个密钥进行解密（私钥）。假设想与非对称加密进行秘密通信。在这种情况下，将生成公有密钥和私有密钥对。然后，将公钥提供给任何想要向自己发送加密消息的人。他们将使用自己的公钥加密消息，当自己收到加密消息时，自己是唯一可以解密它的人，因为自己是唯一拥有私钥的人。这就是为什么它被称为 “private”。请注意，自己的公钥可以是公共知识，并且没有人能够解密消息。如果自己想向某人发送加密消息，该人必须提供他们的公钥。</p>
<p>一种非常广泛使用的非对称加密算法是 RSA。它被称为 RSA，因为它的发明者是：Ronald <strong>R</strong>ivest、Adi <strong>S</strong>hamir 和 Leonard <strong>A</strong>dleman。为了了解它的工作原理，将使用 RSA 算法和为此示例生成的公钥-私钥对进行加密和解密;这看起来有点神奇。之后，将了解一些概念，学习生成密钥，并使用生成的密钥进行加密和解密。</p>
<p>在加密之前，如果还不知道，则需要了解它是如何工作的模运算。其实很简单。取模运算可查找一个数字除以另一个数字后的余数。例如，8 mod 3 &#x3D; 2，因为 3 适合 8 两次，并且有一个 2 的提醒。由于 RSA 使用非常基本的算术，因此准备查看该示例。在 RSA 中，公钥是一对数字，也是私钥。消息可以是可以表示为数字的任何内容。在计算机中，正如所知，一切都是一个数字。加密的文本（也称为密文）将是另一个数字。总之，这是在 RSA 中需要加密和解密的：</p>
<p>RSA 公钥：是一对数字  (e,n)</p>
<p>RSA 私钥：是一对数字  (d,n)</p>
<p>消息: m</p>
<p>密文: c</p>
<p>加密: m^e^ mod n &#x3D; c</p>
<p>解密: c^d^  mod n &#x3D; m</p>
<p>基本上，’d’ 是私钥的私有值，因为 ‘n’ 也在公钥中。正如刚才看到的，公式非常简单。要加密消息，只需将消息发挥到 ‘e’ 的幂，然后对 ‘n’ 执行模数作。要解密，请将密文取到 ‘d’ 的幂，然后对 ‘n’ 进行模运算，这将产生原始消息。在此示例中，密钥的数量非常小，这在现实生活中是不安全的。RSA 仅在使用较大值时是安全的。到 2019 年，只有当密钥是至少需要 2048 位的数字时，RSA 才被认为是安全的。大约是 <strong>617 位数字</strong>。这是 617 位数字的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764</span><br></pre></td></tr></table></figure>

<p>这当然是一个非常大的数字。但是，要了解它的工作原理，最好使用较小的数字。让看一个例子：</p>
<p>公钥 （e，n） → （11,117）</p>
<p>私钥 （d，n） → （35,117）</p>
<p>消息 m –&gt; 10</p>
<p>到目前为止，有一个 e&#x3D;11 的公钥和一个 d&#x3D;35 的私钥。信息是 10，要加密 10，执行以下作：</p>
<p>10^11^ mod 117</p>
<p>结果是 82 次。所以，有：</p>
<p>10^11^ mod 117 &#x3D; 82</p>
<p>密文 → 82</p>
<p>现在，对于解密，执行以下作：</p>
<p>82^35^ mod 117 &#x3D; 10</p>
<p>明文 → 10</p>
<p>这有点神奇。RSA 私有密钥和公有密钥是通过使它们具有此属性的步骤生成的。密钥生成的过程相对简单。只需要了解它的某些部分来展示攻击。</p>
<p>请注意，“在数论中，如果两个整数 a 和 b 除以它们的唯一正整数（因数）是 1，则称它们为相对素数、互素数或互质（也写为互质）。因此，任何除以一个的素数都不会除以另一个。这相当于它们的最大公约数 （gcd） 是 1“。乘法逆元是用来将另一个数相乘并得到 1 的数字。</p>
<p>例如，在非整数算术中（在 RSA 中我们只使用整数算术），8 的乘法逆元是 1&#x2F;8，因为 8 * 1&#x2F;8&#x3D;1。但是，在整数算术中，没有分数。但是我可以有一个乘法逆模 n，这意味着如果有一个数字，将其乘以它的乘法逆数，取模 n，结果将是 1。</p>
<p>例如，3 模 4 中的乘法逆元是 3，为什么？因为如果你乘以 3*3，得到 9，而 9 以 4 为模数，是 1。现在，已准备好查看密钥生成而不会丢失。就是这样：</p>
<ul>
<li>生成两个大的互质数 p 和 q。</li>
<li>找到 n &#x3D; pq 和 phi &#x3D; （p-1） （q-1）</li>
<li>选择 e，使 1 &lt; e &lt; phi，e 是 phi 的互质</li>
<li>找到 d，它是 e 模 phi 的乘法逆元。</li>
<li>这对 （e， n） 是公钥</li>
<li>这对 （d， n） 是私钥</li>
</ul>
<p>这相对简单！要查找乘法逆元，可以使用扩展欧几里得算法 （EEA）。在谷歌中很容易找到它的在线实现。</p>
<p>公钥 （e，n） → （11,117）</p>
<p>私钥 （d，n） → （35,117）</p>
<p>这是以同样的方式生成的。首先，选择了两个互质数。选择的号码是：</p>
<p>p &#x3D; 13</p>
<p>q&#x3D;9</p>
<p>它们是互质的，因为它们的最大公约数是 1。然后</p>
<p>n&#x3D;13*9&#x3D;117</p>
<p>phi&#x3D;（13-1）（9-1）&#x3D;96</p>
<p>要选择 e，我们任意选择一个大于 1 且小于 phi 的数字，它与 phi 互质。数字 11 符合这些要求。所以</p>
<p>e&#x3D;11</p>
<p>现在，要获得 ‘d’ 应用 EEA.我们可以在这个网站上做到这一点：</p>
<p><a target="_blank" rel="noopener" href="https://planetcalc.com/3298/">https://planetcalc.com/3298/</a></p>
<h5 id="攻击-RSA"><a href="#攻击-RSA" class="headerlink" title="攻击 RSA"></a>攻击 RSA</h5><p>如果 RSA 有一个小的 ‘n’，它很容易被破坏。这在现实生活中并不经常发生，除非程序员决定实现他们自己的 RSA 版本。程序员不应该自己实现密码学，使用经过行业测试的库是一般规则。RSA 的安全性基于这样一个事实，即没有有效的算法来分解大的“n”，因此攻击者无法从公钥生成私钥。如果 ‘n’ 太小，则可以对其进行因式分解。</p>
<p>将了解如何通过从公众处恢复私钥来破解 RSA。在现实生活中，公钥位于数字证书中，该证书是一个包含与公钥所有者相关的数据以及公钥本身的软件包。数字证书通常以 base64 编码，这是一种将二进制文件编码为可打印文本的方法。以下是以 base64 编码的数字证书示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIB6zCB1AICMDkwDQYJKoZIhvcNAQECBQAwEjEQMA4GA1UEAxMHUGljb0NURjAe</span><br><span class="line">Fw0xOTA3MDgwNzIxMThaFw0xOTA2MjYxNzM0MzhaMGcxEDAOBgNVBAsTB1BpY29D</span><br><span class="line">VEYxEDAOBgNVBAoTB1BpY29DVEYxEDAOBgNVBAcTB1BpY29DVEYxEDAOBgNVBAgT</span><br><span class="line">B1BpY29DVEYxCzAJBgNVBAYTAlVTMRAwDgYDVQQDEwdQaWNvQ1RGMCIwDQYJKoZI</span><br><span class="line">hvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQABMA0GCSqGSIb3DQEBAgUAA4IBAQAH</span><br><span class="line">al1hMsGeBb3rd/Oq+7uDguueopOvDC864hrpdGubgtjv/hrIsph7FtxM2B4rkkyA</span><br><span class="line">eIV708y31HIplCLruxFdspqvfGvLsCynkYfsY70i6I/dOA6l4Qq/NdmkPDx7edqO</span><br><span class="line">T/zK4jhnRafebqJucXFH8Ak+G6ASNRWhKfFZJTWj5CoyTMIutLU9lDiTXng3rDU1</span><br><span class="line">BhXg04ei1jvAf0UrtpeOA6jUyeCLaKDFRbrOm35xI79r28yO8ng1UAzTRclvkORt</span><br><span class="line">b8LMxw7e+vdIntBGqf7T25PLn/MycGPPvNXyIsTzvvY/MXXJHnAqpI5DlqwzbRHz</span><br><span class="line">q16/S1WLvzg4PsElmv1f</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<p>将该文本复制到 Webshell 的文本文件中，并将其命名为 “weak_n_certificate”。要破解具有弱 n 的 RSA，必须做的第一件事是从证书中提取 n。请记住，n 是模数，e 是指数。 可以使用以下命令提取这些值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in weak_n_certificate -text -noout</span><br></pre></td></tr></table></figure>

<p>在这种情况下，</p>
<p>n&#x3D; 4966306421059967</p>
<p>e&#x3D; 65537</p>
<p>正如在命令的输出中看到的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 12345 (0x3039)</span><br><span class="line">        Signature Algorithm: md2WithRSAEncryption</span><br><span class="line">        Issuer: CN = PicoCTF</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jul  8 07:21:18 2019 GMT</span><br><span class="line">            Not After : Jun 26 17:34:38 2019 GMT</span><br><span class="line">        Subject: OU = PicoCTF, O = PicoCTF, L = PicoCTF, ST = PicoCTF, C = US, CN = PicoCTF</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (53 bit)</span><br><span class="line">                Modulus: 4966306421059967 (0x11a4d45212b17f)</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">    Signature Algorithm: md2WithRSAEncryption</span><br><span class="line">         07:6a:5d:61:32:c1:9e:05:bd:eb:77:f3:aa:fb:bb:83:82:eb:</span><br><span class="line">         9e:a2:93:af:0c:2f:3a:e2:1a:e9:74:6b:9b:82:d8:ef:fe:1a:</span><br><span class="line">         c8:b2:98:7b:16:dc:4c:d8:1e:2b:92:4c:80:78:85:7b:d3:cc:</span><br><span class="line">         b7:d4:72:29:94:22:eb:bb:11:5d:b2:9a:af:7c:6b:cb:b0:2c:</span><br><span class="line">         a7:91:87:ec:63:bd:22:e8:8f:dd:38:0e:a5:e1:0a:bf:35:d9:</span><br><span class="line">         a4:3c:3c:7b:79:da:8e:4f:fc:ca:e2:38:67:45:a7:de:6e:a2:</span><br><span class="line">         6e:71:71:47:f0:09:3e:1b:a0:12:35:15:a1:29:f1:59:25:35:</span><br><span class="line">         a3:e4:2a:32:4c:c2:2e:b4:b5:3d:94:38:93:5e:78:37:ac:35:</span><br><span class="line">         35:06:15:e0:d3:87:a2:d6:3b:c0:7f:45:2b:b6:97:8e:03:a8:</span><br><span class="line">         d4:c9:e0:8b:68:a0:c5:45:ba:ce:9b:7e:71:23:bf:6b:db:cc:</span><br><span class="line">         8e:f2:78:35:50:0c:d3:45:c9:6f:90:e4:6d:6f:c2:cc:c7:0e:</span><br><span class="line">         de:fa:f7:48:9e:d0:46:a9:fe:d3:db:93:cb:9f:f3:32:70:63:</span><br><span class="line">         cf:bc:d5:f2:22:c4:f3:be:f6:3f:31:75:c9:1e:70:2a:a4:8e:</span><br><span class="line">         43:96:ac:33:6d:11:f3:ab:5e:bf:4b:55:8b:bf:38:38:3e:c1:</span><br><span class="line">         25:9a:fd:5f</span><br></pre></td></tr></table></figure>

<p>因式分解 n 很容易。如果你在 google 上搜索 “integer factorization online”，第一个结果是这个：</p>
<p><a target="_blank" rel="noopener" href="https://www.alpertron.com.ar/ECM.HTM">https://www.alpertron.com.ar/ECM.HTM</a></p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希通常用于在数据库中存储密码。当用户登录时，将计算密码的哈希值，并将其与存储的哈希值进行比较。如果它们匹配，则知道用户输入了正确的密码。请注意，哈希的一个基本属性是不可能从哈希中获取原始文本。因此，如果用户有权访问数据库，系统管理员将无法获知用户的实际密码。在数据泄露的情况下，当数据库泄露时，攻击者将无法获取用户的真实密码。</p>
<p>哈希如何受到攻击？对于密码，攻击者可以通过计算多个单词（例如英语词典中的所有单词）的哈希值来创建一个表，该表将多个密码映射到其哈希值。这样，如果攻击者在数据库中找到密码的哈希值，并且该密码是英语词典中的一个单词，则可以通过在表中查找它来将其映射回原始密码。但是，如果用户选择了安全密码，则此攻击将不起作用，因为该安全密码具有复杂性，不会出现在字典中。请注意，有一些常用密码列表，其中包含多种语言的单词及其变体，例如“Hello_12345”。安全密码应为随机字符，以防止此攻击。</p>
<p>质询：以下密码哈希值已从数据库中泄露，并且您知道用户没有使用强密码。</p>
<p>CD0894152aa5eec36ec79eb2bcb90ca40f056804530f40732b4957a496b23dc8</p>
<p>在 google 上搜索名为“rockyou”的密码列表并生成哈希值以查找与泄露的哈希值对应的密码！</p>
<p>提示：可以使用 python 生成哈希。哈希算法为 SHA256。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>当访问浏览器并访问网站时，网站的信息将以数据包的形式下载。今天的 Internet 速度很快，可能会觉得网站一下子就出现了。但是如果下载一个大文件，可以看到它需要一些时间。发生这种情况是因为文件被分解为计算机中接收的数据包，并开始累积，直到它们全部被接收并在下载完成时符合整个文件。每个数据包都包含对应于每个层的一块。在此处查看层：<a target="_blank" rel="noopener" href="https://primer.picoctf.org/#network_layers">网络层</a>。</p>
<h3 id="嗅探和攻击示例"><a href="#嗅探和攻击示例" class="headerlink" title="嗅探和攻击示例"></a>嗅探和攻击示例</h3><p>在一个名为 Wireshark 的工具中，我们可以“嗅探”网络上传输的数据包。用于指代 Wireshark 等工具的技术术语是“嗅探器”。</p>
<p>如果尚未安装，请在此处获取有关安装 Wireshark 的说明：<a target="_blank" rel="noopener" href="https://primer.picoctf.org/#installing_wireshark">安装 Wireshark</a>。</p>
<p>安装并打开它后，应该会看到一个类似于以下内容的窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/Wireshark%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2.png"></p>
<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><h2 id="环境与工具"><a href="#环境与工具" class="headerlink" title="环境与工具"></a>环境与工具</h2><h3 id="工具链："><a href="#工具链：" class="headerlink" title="工具链："></a><strong>工具链</strong>：</h3><ul>
<li><strong>反汇编工具</strong>：IDA Pro（主力）、Ghidra（免费替代）、Binary Ninja</li>
<li><strong>调试器</strong>：x64dbg（Windows）、GDB（Linux，配合Pwngdb插件）</li>
<li><strong>其他工具</strong>：PEiD&#x2F;Detect It Easy（查壳）、010 Editor（二进制分析）、Cutter（逆向辅助）</li>
<li><strong>动态分析</strong>：Cheat Engine（内存修改）、Process Monitor（行为监控）</li>
</ul>
<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a><strong>环境</strong>：</h3><ul>
<li>虚拟机或Docker（隔离实验环境）</li>
<li>Windows&#x2F;Linux双系统（覆盖常见题型）</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>掌握x86&#x2F;x64基础指令（<code>mov</code>, <code>push/pop</code>, <code>call/ret</code>, <code>cmp/jmp</code>）</li>
<li>理解函数调用约定（<code>cdecl</code>, <code>stdcall</code>, <code>fastcall</code>）</li>
<li>熟悉栈帧结构（EBP&#x2F;RBP、ESP&#x2F;RSP）</li>
</ul>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="背景知识介绍"><a href="#背景知识介绍" class="headerlink" title="背景知识介绍"></a><strong>背景知识介绍</strong></h5><ol>
<li><strong>计算机基础原理</strong><br>  计算机是通过执行二进制指令来运行的程序。理解计算机的基本工作原理，如CPU、内存、输入输出设备等，是学习汇编的基础。二进制指令是计算机能够直接执行的最低级语言，而汇编语言则是对这些二进制指令的符号化表示。</li>
<li><strong>操作系统基础</strong><br>  操作系统管理计算机的硬件和软件资源。汇编语言与操作系统密切相关，因为不同的操作系统可能使用不同的函数调用约定和栈帧结构。了解操作系统的基本概念，如进程、线程、内存管理等，有助于理解汇编程序的执行环境。</li>
<li><strong>数据表示与存储</strong><br>  计算机中的数据以二进制形式存储和处理。理解数据的表示方式（如整数、浮点数、字符等）以及它们在内存中的存储方式（如大端序、小端序）对汇编编程至关重要。例如，x86架构通常使用小端序存储数据。</li>
<li><strong>寄存器与内存模型</strong><br>  寄存器是CPU内部的高速存储单元，用于临时存储数据和指令。x86&#x2F;x64架构中有多个寄存器（如EAX、EBX、ECX、EDX等），每个寄存器有特定的用途。理解寄存器的作用以及它们与内存之间的交互是汇编编程的核心。</li>
<li><strong>机器码与汇编指令的关系</strong><br>  汇编指令是对人类友好的指令表示，而机器码是计算机能够直接执行的二进制代码。每条汇编指令都对应一条或多条机器码指令。理解这两者之间的关系有助于更好地掌握汇编语言的本<strong>质。</strong></li>
</ol>
<h5 id="知识点详细讲解"><a href="#知识点详细讲解" class="headerlink" title="知识点详细讲解"></a><strong>知识点详细讲解</strong></h5><p><strong>1. x86&#x2F;x64基础指令</strong></p>
<ul>
<li><strong>mov</strong>: 用于将数据从一个位置移动到另一个位置。例如，<code>mov eax, 5</code> 将整数5加载到EAX寄存器中。</li>
<li><strong>push&#x2F;pop</strong>: 用于将数据压入栈或从栈中弹出。<code>push eax</code> 将EAX寄存器的值压入栈顶，<code>pop eax</code> 将栈顶的值弹出到EAX寄存器。</li>
<li><strong>call&#x2F;ret</strong>: <code>call</code> 用于调用一个函数，<code>ret</code> 用于从函数返回。<code>call label</code> 会将当前指令地址压入栈，然后跳转到<code>label</code>处执行代码；<code>ret</code> 会从栈中弹出地址并跳转回去。</li>
<li><strong>cmp&#x2F;jmp</strong>: <code>cmp</code> 用于比较两个操作数，<code>jmp</code> 用于无条件跳转。例如，<code>cmp eax, ebx</code> 会比较EAX和EBX寄存器的值，<code>je label</code> 会在相等时跳转到<code>label</code>。</li>
</ul>
<p><strong>2. 函数调用约定</strong></p>
<ul>
<li><strong>cdecl (C语言调用约定)</strong>: 调用者负责清理栈。参数从右到左压入栈，调用者在函数返回后清理栈。</li>
<li><strong>stdcall (标准调用约定)</strong>: 被调用函数负责清理栈。参数同样从右到左压入栈，但被调用函数会在返回前清理栈。</li>
<li><strong>fastcall</strong>: 使用寄存器传递前两个参数，剩余参数通过栈传递。这种约定提高了函数调用的效率。</li>
</ul>
<p><strong>3. 栈帧结构</strong></p>
<ul>
<li><strong>EBP&#x2F;RBP (基址指针)</strong>: 用于指向当前栈帧的底部。在函数调用时，EBP&#x2F;RBP通常用于保存上一个栈帧的基址，以便在函数返回时恢复。</li>
<li><strong>ESP&#x2F;RSP (栈指针)</strong>: 指向当前栈顶。在函数调用时，ESP&#x2F;RSP会随着<code>push</code>和<code>pop</code>指令的变化而移动。</li>
<li>栈帧是函数调用时在栈上分配的一块内存区域，用于存储局部变量、参数和返回地址。</li>
</ul>
<h5 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h5><p><strong>问题描述</strong>：编写一个简单的汇编程序，计算两个整数的和并返回结果。<br> <strong>分析</strong>：我们需要定义一个函数，接受两个整数作为参数，计算它们的和并返回结果。由于涉及函数调用，我们需要遵循调用约定（这里使用cdecl）。<br> <strong>为什么用该知识点</strong>：这个例子涉及x86&#x2F;x64基础指令（如<code>mov</code>、<code>push</code>、<code>call</code>、<code>ret</code>）、函数调用约定（cdecl）以及栈帧结构的使用。<br> <strong>应用过程</strong>：</p>
<ol>
<li>定义函数<code>add_two_numbers</code>，参数为<code>a</code>和<code>b</code>。</li>
<li>在函数内部，将<code>a</code>和<code>b</code>相加，结果存储在EAX寄存器中。</li>
<li>使用<code>ret</code>指令返回，调用者负责清理栈。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 调用add_two_numbers(5, 10)</span><br><span class="line">    push 10      ; 第二个参数</span><br><span class="line">    push 5       ; 第一个参数</span><br><span class="line">    call add_two_numbers</span><br><span class="line">    add esp, 8   ; 清理栈（2个参数，每个4字节）</span><br><span class="line">    ; 结果在EAX中</span><br><span class="line">    ; 退出程序</span><br><span class="line">    mov eax, 1   ; 系统调用号（exit）</span><br><span class="line">    int 0x80     ; 调用内核</span><br><span class="line"></span><br><span class="line">add_two_numbers:</span><br><span class="line">    push ebp     ; 保存上一个栈帧</span><br><span class="line">    mov ebp, esp ; 设置当前栈帧</span><br><span class="line">    mov eax, [ebp+8] ; 获取第一个参数</span><br><span class="line">    add eax, [ebp+12] ; 加上第二个参数</span><br><span class="line">    pop ebp     ; 恢复上一个栈帧</span><br><span class="line">    ret         ; 返回</span><br></pre></td></tr></table></figure>

<p><strong>计算结果</strong>：EAX寄存器中存储的值为15，即5 + 10的结果。</p>
<h4 id="疑问和解惑"><a href="#疑问和解惑" class="headerlink" title="疑问和解惑"></a><strong>疑问和解惑</strong></h4><h5 id="Q：代码解释"><a href="#Q：代码解释" class="headerlink" title="Q：代码解释"></a><strong>Q：代码解释</strong></h5><p>1**. 程序入口 <code>_start</code>（程序从这里开始执行）**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ; 调用 add_two_numbers(5, 10)</span><br><span class="line">    push 10      ; 把第二个参数（10）放到&quot;栈&quot;（类似一叠盘子）</span><br><span class="line">    push 5       ; 把第一个参数（5）放到栈顶</span><br><span class="line">    call add_two_numbers ; 告诉电脑：&quot;现在去执行 add_two_numbers 函数&quot;</span><br><span class="line">    add esp, 8   ; 清理栈（丢掉之前放的2个参数）</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>push</code>**：想象你有一叠盘子（栈），<code>push 10</code> 就是把数字10写在一个盘子上，放到最上面。</li>
<li>**<code>call</code>**：相当于说：“现在去执行<code>add_two_numbers</code>这个函数，等下记得回来”。</li>
<li>**<code>add esp, 8</code>**：之前放了两个参数（每个占4字节），现在把栈顶指针<code>esp</code>向上移动8字节，相当于“丢掉这两个盘子”。</li>
</ul>
<p><strong>2. 函数 <code>add_two_numbers</code>（实现加法）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_two_numbers:</span><br><span class="line">    push ebp     ; 保存之前的&quot;基准指针&quot;（记住原来的盘子叠到哪里）</span><br><span class="line">    mov ebp, esp ; 设定新的基准指针（现在以这里为起点找参数）</span><br><span class="line">    mov eax, [ebp+8]  ; 拿到第一个参数（5）</span><br><span class="line">    add eax, [ebp+12] ; 加上第二个参数（10）</span><br><span class="line">    pop ebp      ; 恢复之前的基准指针</span><br><span class="line">    ret          ; 返回（回到 call 的下一条指令）</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>push ebp</code>**：保存旧的“基准位置”（就像在书里夹个书签，方便之后回来）。</li>
<li>**<code>mov ebp, esp</code>**：用<code>ebp</code>记住当前栈顶的位置，方便找到参数。</li>
<li>**<code>[ebp+8]</code> 和 <code>[ebp+12]</code>**：从<code>ebp</code>的位置向上数8和12字节，拿到之前压入的参数（5和10）。</li>
<li>**<code>add eax</code>**：把两个参数相加，结果存在<code>eax</code>寄存器（相当于计算5+10&#x3D;15）。</li>
<li>**<code>ret</code>**：返回到<code>call</code>之后的位置继续执行。</li>
</ul>
<p><strong>3. 退出程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 结果在EAX中（这里是15）</span><br><span class="line">mov eax, 1   ; 告诉系统：&quot;我要退出&quot;</span><br><span class="line">int 0x80     ; 通知内核执行退出</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>mov eax, 1</code>**：把系统调用号1（代表“退出程序”）放到<code>eax</code>寄存器。</li>
<li>**<code>int 0x80</code>**：触发一个中断，通知操作系统执行退出操作。</li>
</ul>
<p><strong>通俗比喻</strong></p>
<ul>
<li><strong>栈（Stack）</strong>：像一叠盘子，<code>push</code>是放盘子，<code>pop</code>是拿盘子。</li>
<li><strong>函数调用</strong>：就像暂停手头工作，去处理另一个任务（比如去厨房倒水），处理完再回来。</li>
<li><strong>寄存器</strong>：<code>eax</code>是临时存放结果的“盒子”，<code>esp</code>和<code>ebp</code>是记录盘子叠放位置的“指针”。</li>
</ul>
<h5 id="Q：“偏移量”是怎么来的"><a href="#Q：“偏移量”是怎么来的" class="headerlink" title="Q：“偏移量”是怎么来的"></a><strong>Q：“偏移量”是怎么来的</strong></h5><p><strong>关键点：栈的结构会随着函数调用自动变化</strong></p>
<p>当调用函数 <code>call add_two_numbers</code> 时，除了你手动压入的参数（<code>5</code> 和 <code>10</code>），<strong>CPU 还会自动在栈里存入其他东西</strong>。</p>
<p><strong>第一步：参数压栈（你手动操作的）</strong></p>
<p>假设初始栈顶指针是 <code>esp</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 10     ; 栈顶向下移动4字节，参数2存入10，压栈，esp = 0x0FFC</span><br><span class="line">push 5      ; 栈顶再向下移动4字节，参数1存入5，压栈，esp = 0x0FF8</span><br></pre></td></tr></table></figure>

<p>此时栈的结构（从高地址到低地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF8    | 5	← esp 当前指向这里</span><br><span class="line">0x0FFC    | 10</span><br><span class="line">0x1000    | ...   ← 之前的数据</span><br></pre></td></tr></table></figure>

<p><strong>第二步：调用函数 <code>call add_two_numbers</code></strong></p>
<p>当执行 <code>call</code> 指令时，<strong>CPU 会自动把返回地址（即 <code>call</code> 下一条指令的地址）压入栈</strong>，占4字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call add_two_numbers  ; 1. 压入返回地址，esp = 0x0FF4</span><br><span class="line">						; 2. 跳转到函数 add_two_numbers</span><br></pre></td></tr></table></figure>

<p>此时栈的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF4    | 返回地址（指向 add esp, 8 的地址）</span><br><span class="line">0x0FF8    | 5</span><br><span class="line">0x0FFC    | 10</span><br></pre></td></tr></table></figure>

<p><strong>第三步：进入函数 <code>add_two_numbers</code></strong></p>
<p>函数开头有两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp     ; 保存旧的基址指针（ebp），栈顶再向下移动4字节</span><br><span class="line">mov ebp, esp ; 将当前栈顶（esp）设为新的基址指针（ebp）</span><br></pre></td></tr></table></figure>

<p>此时栈的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF0    | 旧的ebp（0x2000）  ← ebp 和 esp 都指向这里</span><br><span class="line">0x0FF4    | 返回地址（指向 add esp, 8 的地址）</span><br><span class="line">0x0FF8    | 5</span><br><span class="line">0x0FFC    | 10</span><br></pre></td></tr></table></figure>

<p><strong>现在，通过 <code>ebp</code> 访问参数</strong></p>
<p>因为 <code>ebp</code> 记录了当前栈帧的基准位置，所以：</p>
<ul>
<li>**<code>[ebp+8]</code>**：从 <code>ebp</code> 向上数8字节，即 <code>旧的ebp值（4字节） + 返回地址（4字节）</code>，此时到达第一个参数 <code>5</code>。</li>
<li>**<code>[ebp+12]</code>**：再向上数4字节（因为每个参数占4字节），到达第二个参数 <code>10</code>。</li>
</ul>
<p>图解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">ebp      | 旧的ebp值（保存的）</span><br><span class="line">ebp+4    | 返回地址</span><br><span class="line">ebp+8    | 5    ← 第一个参数</span><br><span class="line">ebp+12   | 10   ← 第二个参数</span><br></pre></td></tr></table></figure>

<p><strong>为什么是 <code>+8</code> 和 <code>+12</code>？</strong></p>
<ul>
<li>**<code>+8</code>**：跳过 <code>旧的ebp值（4字节）</code> 和 <code>返回地址（4字节）</code>，共8字节。</li>
<li>**<code>+12</code>**：在 <code>+8</code> 的基础上再跳过第一个参数（4字节），到达第二个参数。</li>
</ul>
<p><strong>旧的ebp和返回地址的最终去向</strong></p>
<p><strong>步骤 4：函数执行完毕，恢复旧的ebp和返回地址</strong></p>
<p>函数结束时，执行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ebp   ; 1. 将栈顶的值（旧的ebp 0x2000）弹出到ebp，esp = 0x0FF4</span><br><span class="line">ret       ; 2. 弹出返回地址到EIP（程序计数器），esp = 0x0FF8</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<p>虽然两个参数本身占8字节（5和10各占4字节），但调用函数时<strong>栈里还存入了返回地址和旧的ebp值</strong>，导致实际偏移量需要加上这些额外数据占用的空间（共8字节）。这就是为什么参数的位置是 <code>[ebp+8]</code> 和 <code>[ebp+12]</code>。</p>
<h5 id="Q：栈顶指针移动的方向"><a href="#Q：栈顶指针移动的方向" class="headerlink" title="Q：栈顶指针移动的方向"></a><strong>Q：栈顶指针移动的方向</strong></h5><p><strong>两个核心概念：</strong></p>
<ol>
<li><strong>栈的增长方向</strong>：栈在内存中是<strong>从高地址向低地址</strong>增长的（想象一个倒置的桶，数据从上往下堆积）。</li>
<li><strong>指针移动方向</strong>：当栈顶指针 <code>esp</code> <strong>减小</strong>时，栈在“扩展”（压入数据）；当 <code>esp</code> <strong>增大</strong>时，栈在“收缩”（弹出或清理数据）。</li>
</ol>
<p><strong>详细分析 <code>add esp, 8</code> 的作用：</strong></p>
<p><strong>1. 调用函数前的栈结构</strong></p>
<p>假设初始栈顶指针 <code>esp</code> 指向地址 <code>0x1000</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 10       ; esp 减小4字节 → 0x0FFC，存入10（地址 0x0FFC）</span><br><span class="line">push 5        ; esp 再减小4字节 → 0x0FF8，存入5（地址 0x0FF8）</span><br></pre></td></tr></table></figure>

<p>此时栈的结构（地址从高到低排列）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF8   | 5    ← esp 当前指向这里（栈顶）</span><br><span class="line">0x0FFC   | 10</span><br><span class="line">0x1000   | ...  ← 之前的数据</span><br></pre></td></tr></table></figure>

<p><strong>2. 调用函数 <code>call add_two_numbers</code></strong></p>
<p><code>call</code> 指令会自动将<strong>返回地址</strong>压入栈（占4字节），然后跳转到函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call add_two_numbers  ; esp 再减小4字节 → 0x0FF4，存入返回地址（地址 0x0FF4）</span><br></pre></td></tr></table></figure>

<p>此时栈结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF4   | 返回地址   ← esp 当前指向这里</span><br><span class="line">0x0FF8   | 5</span><br><span class="line">0x0FFC   | 10</span><br></pre></td></tr></table></figure>

<p><strong>3. 函数内部保存 <code>ebp</code></strong></p>
<p>进入函数后，保存旧的基址指针 <code>ebp</code>：</p>
<p>assembly</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp       ; esp 减小4字节 → 0x0FF0，存入旧的ebp（地址 0x0FF0）</span><br><span class="line">mov ebp, esp   ; 将 ebp 设为当前 esp 的值（0x0FF0）</span><br></pre></td></tr></table></figure>

<p>此时栈结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF0   | 旧的ebp    ← ebp 和 esp 都指向这里</span><br><span class="line">0x0FF4   | 返回地址</span><br><span class="line">0x0FF8   | 5         ← 第一个参数</span><br><span class="line">0x0FFC   | 10        ← 第二个参数</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>为什么 <code>add esp, 8</code> 是“向上移动”？</strong></p>
<ul>
<li><strong>关键点</strong>：<code>add esp, 8</code> 的作用是<strong>清理栈上之前压入的两个参数（5 和 10）</strong>。</li>
<li><strong>具体过程</strong>：<ol>
<li>函数返回后，<code>esp</code> 的值为 <code>0x0FF0</code>（指向保存的 <code>ebp</code>）。</li>
<li>执行 <code>pop ebp</code> 后，<code>esp</code> 会增加4字节 → <code>0x0FF4</code>（指向返回地址）。</li>
<li>执行 <code>ret</code> 后，<code>esp</code> 再增加4字节 → <code>0x0FF8</code>（此时 <code>esp</code> 指向参数 <code>5</code>）。</li>
<li>最后执行 <code>add esp, 8</code>，将 <code>esp</code> 增加8字节 → <code>0x1000</code>（回到最初的位置）。</li>
</ol>
</li>
</ul>
<p><strong>图解 <code>add esp, 8</code> 的效果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用函数前：esp = 0x1000</span><br><span class="line">压入参数后：esp = 0x0FF8</span><br><span class="line">清理参数后：esp = 0x1000（通过 add esp,8 实现）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>“向上移动”的本质</strong>：<code>esp</code> 的值从 <code>0x0FF8</code> 增加到 <code>0x1000</code>，对应内存地址<strong>从低到高</strong>（即栈“收缩”了，释放了参数占用的空间）。</li>
</ul>
<hr>
<p><strong>为什么参数的位置是 <code>[ebp+8]</code> 和 <code>[ebp+12]</code>？</strong></p>
<ul>
<li><p>**<code>ebp</code> 的值是 <code>0x0FF0</code>**（保存旧ebp后的栈顶）。</p>
</li>
<li><p>参数 <code>5</code> 的地址是 <code>0x0FF8</code>，相对于 <code>ebp</code> 的偏移量是：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0FF8 - 0x0FF0 = 8 字节 → [ebp+8]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数 <code>10</code> 的地址是 <code>0x0FFC</code>，偏移量是：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0FFC - 0x0FF0 = 12 字节 → [ebp+12]</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>总结</strong></p>
<ul>
<li><strong>栈的增长方向</strong>：从高地址向低地址（压入数据时 <code>esp</code> 减小）。</li>
<li><strong>清理栈的本质</strong>：通过 <code>add esp, N</code> <strong>增大 <code>esp</code> 的值</strong>，让栈顶指针回到高位，释放不再需要的数据。</li>
<li><strong>“向上移动”是逻辑上的</strong>：虽然内存地址数值上变大了，但实际是让栈“收缩”，回到调用前的状态。</li>
</ul>
<h5 id="Q-调用过程中旧的ebp和返回地址是如何处理"><a href="#Q-调用过程中旧的ebp和返回地址是如何处理" class="headerlink" title="Q:调用过程中旧的ebp和返回地址是如何处理"></a>Q:调用过程中旧的ebp和返回地址是如何处理</h5><p><strong>旧的ebp和返回地址是函数调用过程中栈管理的关键</strong>，它们确保了函数执行完毕后能正确返回到调用位置，并恢复之前的栈状态。</p>
<p><strong>完整函数调用流程的栈变化</strong></p>
<p>假设初始状态：<code>esp</code>（栈顶指针）指向地址 <code>0x1000</code>，<code>ebp</code>（基址指针）指向某个位置（比如 <code>0x2000</code>）。</p>
<p><strong>步骤 1：压入参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 10       ; 参数2（10）压栈，esp = 0x0FFC（地址减小4字节）</span><br><span class="line">push 5        ; 参数1（5）压栈，esp = 0x0FF8</span><br></pre></td></tr></table></figure>

<p>此时栈结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF8   | 5     ← esp 当前指向这里</span><br><span class="line">0x0FFC   | 10</span><br><span class="line">0x1000   | ...   ← 之前的数据</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：调用函数 <code>call add_two_numbers</code></strong></p>
<p><code>call</code> 指令会<strong>自动将返回地址（即 <code>call</code> 下一条指令的地址）压入栈</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call add_two_numbers  ; 1. 压入返回地址，esp = 0x0FF4</span><br><span class="line">                      ; 2. 跳转到函数 add_two_numbers</span><br></pre></td></tr></table></figure>

<p>此时栈结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF4   | 返回地址（指向 `add esp, 8` 的地址） ← esp</span><br><span class="line">0x0FF8   | 5</span><br><span class="line">0x0FFC   | 10</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：函数内部保存旧的ebp</strong></p>
<p>进入函数后，首先保存旧的 <code>ebp</code>，并设置新的栈帧基址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_two_numbers:</span><br><span class="line">    push ebp        ; 将旧的ebp（0x2000）压栈，esp = 0x0FF0</span><br><span class="line">    mov ebp, esp    ; 将ebp设为当前esp的值（0x0FF0）</span><br></pre></td></tr></table></figure>

<p>此时栈结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x0FF0   | 旧的ebp（0x2000）  ← ebp 和 esp 都指向这里</span><br><span class="line">0x0FF4   | 返回地址</span><br><span class="line">0x0FF8   | 5</span><br><span class="line">0x0FFC   | 10</span><br></pre></td></tr></table></figure>

<p><strong>旧的ebp和返回地址的最终去向</strong></p>
<p><strong>步骤 4：函数执行完毕，恢复旧的ebp和返回地址</strong></p>
<p>函数结束时，执行以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ebp   ; 1. 将栈顶的值（旧的ebp 0x2000）弹出到ebp，esp = 0x0FF4</span><br><span class="line">ret       ; 2. 弹出返回地址到EIP（程序计数器），esp = 0x0FF8</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li><strong>旧的ebp（0x2000）</strong>：通过 <code>pop ebp</code> 恢复，<code>ebp</code> 重新指向调用前的基址。</li>
<li><strong>返回地址</strong>：通过 <code>ret</code> 弹出到 <code>EIP</code>，程序继续执行 <code>call</code> 的下一条指令（即 <code>add esp, 8</code>）。</li>
</ul>
<p><strong>步骤 5：清理参数（<code>add esp, 8</code>）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add esp, 8  ; esp = 0x0FF8 + 8 = 0x1000</span><br></pre></td></tr></table></figure>

<p>此时栈顶指针 <code>esp</code> 回到初始位置 <code>0x1000</code>，栈结构恢复如初：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址      | 值</span><br><span class="line">0x1000   | ...   ← 初始状态</span><br></pre></td></tr></table></figure>

<p><strong>关键点总结</strong></p>
<ol>
<li><strong>旧的ebp</strong>：<ul>
<li>通过 <code>push ebp</code> 保存到栈中。</li>
<li>在函数结束时通过 <code>pop ebp</code> <strong>恢复</strong>，确保调用者的栈帧不被破坏。</li>
</ul>
</li>
<li><strong>返回地址</strong>：<ul>
<li>由 <code>call</code> 指令自动压入栈。</li>
<li>通过 <code>ret</code> 指令弹出到 <code>EIP</code>，<strong>让程序回到调用位置继续执行</strong>。</li>
</ul>
</li>
<li><strong>参数清理</strong>：<ul>
<li>由调用者通过 <code>add esp, 8</code> 清理栈空间（因为参数是调用者压入的）。</li>
</ul>
</li>
<li><strong>栈指针（esp）的移动</strong>：<ul>
<li>压栈时 <code>esp</code> <strong>减小</strong>（栈向低地址扩展）。</li>
<li>弹栈或清理时 <code>esp</code> <strong>增大</strong>（栈向高地址收缩）。</li>
</ul>
</li>
</ol>
<p><strong>通俗比喻</strong></p>
<ul>
<li><strong>旧的ebp</strong>：就像你在看书时夹了一个书签，去厨房倒杯水（执行函数），回来后通过书签找到之前读到的位置。</li>
<li><strong>返回地址</strong>：相当于你告诉自己：“倒完水后，记得回到沙发继续看书”。</li>
<li><strong>栈清理</strong>：倒完水后，把用过的杯子和水壶收拾好（清理参数），保持厨房整洁。</li>
</ul>
<p><strong>最终栈状态</strong></p>
<p>函数调用完全结束后，栈恢复到调用前的状态，旧的ebp和返回地址<strong>已被安全移除</strong>，程序继续执行后续指令。这就是栈帧管理的精妙之处！</p>
<h4 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a><strong>扩展知识点</strong></h4><ol>
<li><strong>汇编器与链接器</strong><br>  汇编器将汇编代码转换为机器码，链接器将多个目标文件合并为一个可执行文件。理解它们的工作原理有助于更好地掌握汇编编程的完整流程。</li>
<li><strong>逆向工程</strong><br>  通过分析可执行文件的机器码，还原出汇编代码甚至高级语言代码。逆向工程在安全、破解、调试等领域有重要应用。</li>
<li><strong>中断与异常处理</strong><br>  中断是CPU响应外部事件的一种机制，异常是CPU内部错误或特殊条件的处理。理解中断和异常处理有助于编写更健壮的汇编程序。</li>
<li><strong>多线程与并发编程</strong><br>  在汇编语言中实现多线程和并发编程需要深入理解CPU的上下文切换、锁机制、同步原语等。这是高级汇编编程的重要内容。</li>
<li><strong>优化技术</strong><br>  汇编语言允许程序员直接控制CPU指令的执行，因此可以通过优化指令顺序、减少内存访问、利用CPU特性等手段提升程序性能。</li>
</ol>
<h3 id="C语言逆向"><a href="#C语言逆向" class="headerlink" title="C语言逆向"></a>C语言逆向</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li>变量存储（栈、堆、全局区）</li>
<li>函数调用、循环和分支结构的汇编对应</li>
<li>简单逆向练习（如CrackMe题：尝试<a target="_blank" rel="noopener" href="https://crackmes.one/">Easy CrackMe</a>）</li>
</ul>
<h4 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h4><h5 id="背景知识介绍-1"><a href="#背景知识介绍-1" class="headerlink" title="背景知识介绍"></a><strong>背景知识介绍</strong></h5><ol>
<li><strong>计算机内存结构</strong>：计算机内存可以粗略分为代码区、数据区和未使用区。数据区又细分为栈区、堆区和静态存储区（包括全局区和静态局部变量区）。理解这些区域的划分和各自用途，是掌握变量存储的基础。</li>
<li><strong>函数调用栈</strong>：函数调用时，系统会在栈上为该函数创建一个栈帧，用于存储函数的局部变量、参数、返回地址等。随着函数的嵌套调用，栈会不断增长；函数返回时，对应的栈帧会被销毁，栈空间得以回收。这一过程是理解函数调用与栈关系的关键。</li>
<li><strong>动态内存管理</strong>：堆区是程序中用于动态内存分配的区域。通过malloc、calloc、realloc等函数，我们可以在运行时申请所需大小的内存块；使用完毕后，需要通过free函数释放，以避免内存泄漏。动态内存管理是编程中一项重要技能。</li>
<li><strong>汇编语言基础</strong>：汇编语言是与机器语言紧密相关的编程语言，它直接操作计算机硬件，包括寄存器、内存等。了解汇编语言的基本语法和指令集，有助于我们理解C语言代码如何被翻译成机器指令，以及这些指令如何在CPU上执行。</li>
<li><strong>逆向工程概念</strong>：逆向工程是指通过对目标程序的分析，推导出其源代码或逻辑结构的过程。在C语言逆向中，我们通常需要分析程序的二进制文件（如可执行文件或库文件），从中提取出有用的信息，如函数调用关系、变量布局等。这是理解C语言逆向基础的重要背景。</li>
</ol>
<h6 id="知识点详细讲解-1"><a href="#知识点详细讲解-1" class="headerlink" title="知识点详细讲解"></a>知识点详细讲解</h6><p><strong>变量存储</strong></p>
<ul>
<li><strong>栈区</strong>：栈是一种后进先出的数据结构，用于存储函数的局部变量、参数以及函数调用时的维护信息（如返回地址）。每当进入一个函数，系统就会在栈上为该函数分配一个栈帧；函数返回时，栈帧被销毁，栈空间得以回收。由于栈的先进后出特性，使得局部变量的生命周期与其所在函数的执行时间严格对应。此外，栈区的操作非常高效，因为只需要移动栈指针即可完成变量的分配和释放。</li>
<li><strong>堆区</strong>：堆是程序中一块预留的内存空间，用于动态内存分配。与栈不同，堆区的内存分配不受函数调用范围的限制，可以跨越多个函数甚至整个程序生命周期。通过malloc等函数申请的内存块，在没有被free释放之前，将一直有效。然而，这也意味着程序员需要手动管理堆区的内存，包括及时释放不再使用的内存块，以避免内存泄漏和碎片化问题。</li>
<li><strong>全局区</strong>：全局区用于存储全局变量和静态变量。这些变量在程序启动时即已分配内存，并在整个程序运行期间都存在。全局变量在所有文件中可见（需通过extern声明），而静态变量仅在其定义的作用域内可见但具有全局生命周期。全局区的内存分配和释放由操作系统负责，程序员无需显式管理。</li>
</ul>
<p><strong>函数调用与汇编对应</strong></p>
<p>当C语言中的函数被调用时，背后发生了一系列与汇编指令相关的动作。以x86架构为例，函数调用时通常会进行以下操作：</p>
<ul>
<li><strong>压栈</strong>：将函数的参数、返回地址以及调用者的上下文（如寄存器值）压入栈中。这些信息构成了被调函数的栈帧。</li>
<li><strong>跳转</strong>：通过call指令跳转到被调函数的起始地址执行代码。此时，CPU的指令指针寄存器（如EIP）指向被调函数的第一条指令。</li>
<li><strong>执行函数体</strong>：在函数体内，可以通过栈指针（如ESP）访问局部变量和参数；通过寄存器进行计算和数据处理。</li>
<li><strong>返回准备</strong>：函数执行完毕前，需要恢复调用者的上下文（如从栈中弹出寄存器值），并将返回值（如果有的话）放入指定的寄存器（如EAX）或内存位置。</li>
<li><strong>返回</strong>：通过ret指令从栈中弹出返回地址并跳转回去执行调用者代码。此时，被调函数的栈帧被销毁，栈空间得以回收。</li>
</ul>
<h6 id="实例分析：Easy-CrackMe"><a href="#实例分析：Easy-CrackMe" class="headerlink" title="实例分析：Easy CrackMe"></a>实例分析：Easy CrackMe</h6><p>为了更好地理解上述知识点，将通过一个简单的CrackMe题目来演示如何运用这些知识进行逆向分析。</p>
<p><strong>1. 问题描述</strong></p>
<p>假设我们有一个简单的C程序（CrackMe题），其功能是要求用户输入一个密码，如果密码正确则输出“Congratulations!”，否则输出“Try again!”。任务是通过逆向分析找出正确的密码。</p>
<p><strong>2. 分析步骤</strong></p>
<ul>
<li><strong>获取二进制文件</strong>：首先，我们需要获取该C程序的二进制文件（如可执行文件或库文件）。这通常是通过编译源代码得到的。</li>
<li><strong>反汇编</strong>：使用反汇编工具（如IDA Pro、Ghidra等）打开二进制文件，将其转化为汇编代码以便分析。这一步将帮助我们理解程序的逻辑结构和函数调用关系。</li>
<li><strong>查找关键函数</strong>：在反汇编后的代码中查找与用户输入和密码验证相关的函数。通常这些函数会包含字符串比较、条件判断等逻辑。通过分析这些函数的汇编代码，我们可以推断出密码的存储位置和比较方式。</li>
<li><strong>定位密码字符串</strong>：根据字符串比较函数的参数或硬编码的字符串常量定位到密码字符串所在的内存地址。这一步可能需要结合数据区分析和调试技巧来完成。</li>
<li><strong>验证密码</strong>：一旦找到密码字符串就可以尝试输入该密码看是否能够成功通过验证。如果程序输出“Congratulations!”则说明密码正确；否则需要重新分析或尝试其他可能的密码组合。</li>
</ul>
<p><strong>3. 示例应用</strong></p>
<p>假设通过反汇编分析我们发现密码字符串存储在数据区的某个位置且为明文存储（如”.data section”中的某个字符串常量）。我们可以直接读取该字符串作为密码尝试输入；如果程序验证通过则说明分析成功。当然实际情况可能更复杂一些比如密码可能经过加密处理或者隐藏在其他位置需要通过更深入的分析才能找到。但无论如何只要掌握了正确的分析方法和工具就一定能够找到解决问题的办法。</p>
<h6 id="扩展知识点-1"><a href="#扩展知识点-1" class="headerlink" title="扩展知识点"></a>扩展知识点</h6><ul>
<li><strong>调试技术</strong>：调试是逆向工程中不可或缺的一部分。通过调试工具（如GDB、WinDbg等）可以实时观察程序的运行状态、寄存器值、内存变化等信息从而帮助分析人员更准确地理解程序逻辑和定位问题所在。掌握调试技术对于提高逆向工程的效率和准确性具有重要意义。</li>
<li><strong>加密与解密技术</strong>：在逆向工程中经常会遇到加密和解密的问题。了解常见的加密算法（如AES、DES等）和解密技术可以帮助分析人员更好地理解和处理加密数据从而突破某些保护机制获取关键信息。此外还需要关注加密算法的实现细节和可能存在的安全漏洞以便在必要时进行利用或修复。</li>
<li><strong>漏洞挖掘与利用</strong>：漏洞挖掘与利用是信息安全领域中的一个重要分支也是逆向工程的一个重要应用场景。通过逆向工程技术可以发现软件中的漏洞并对其进行详细分析；同时结合漏洞利用技术可以实现对目标系统的渗透测试或攻击模拟从而评估系统的安全性并提出改进建议。需要注意的是漏洞挖掘与利用应遵守法律法规和道德规范不得用于非法目的。</li>
<li><strong>自动化脚本编写</strong>：在逆向工程中经常需要处理大量的重复性工作如日志分析、数据提取等。此时编写自动化脚本（如Python、Perl等）可以大大提高分析效率减少人为错误。掌握一定的脚本编程能力对于逆向工程师来说是一项非常重要的技能可以帮助他们更好地应对复杂的分析任务和挑战。</li>
<li><strong>跨平台逆向工程</strong>：随着移动互联网和物联网的快速发展应用程序越来越多地运行在不同的操作系统和硬件平台上。因此掌握跨平台逆向工程技能变得尤为重要。这包括了解不同平台的系统架构、指令集、调试工具以及逆向工程技术的差异等以便能够针对不同平台进行有效的逆向分析和攻击模拟。同时还需要关注新兴技术和趋势如人工智能、区块链等对逆向工程的影响和挑战以便及时调整自己的技能和知识结构适应行业发展的需求。</li>
</ul>
<h3 id="静态与动态分析"><a href="#静态与动态分析" class="headerlink" title="静态与动态分析"></a>静态与动态分析</h3><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><ul>
<li>使用IDA Pro分析控制流图（CFG）</li>
<li>识别关键函数（如<code>main</code>、<code>check_flag</code>）</li>
<li>修改反汇编结果（IDA Patch功能）</li>
</ul>
<h5 id="详解-2"><a href="#详解-2" class="headerlink" title="详解"></a>详解</h5><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><ul>
<li>设置断点、观察寄存器&#x2F;内存变化</li>
<li>修改执行流程（如跳过<code>jz</code>跳转）</li>
<li>实战：调试带简单加密的CrackMe（如异或加密）</li>
</ul>
<h5 id="详解-3"><a href="#详解-3" class="headerlink" title="详解"></a>详解</h5><h4 id="常见加密算法识别"><a href="#常见加密算法识别" class="headerlink" title="常见加密算法识别"></a>常见加密算法识别</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li>固定异或（<code>xor eax, 0x1234</code>）</li>
<li>常量比较（如<code>strcmp</code>后的<code>test eax, eax</code>）</li>
<li>识别Base64、TEA、RC4、AES的特征代码</li>
</ul>
<h5 id="详解-4"><a href="#详解-4" class="headerlink" title="详解"></a>详解</h5><h2 id="IDA-pro"><a href="#IDA-pro" class="headerlink" title="IDA pro"></a>IDA pro</h2><p>参考：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-285604.htm#msg_header_h1_1">IDA Pro 9 安装和插件配置-安全工具-看雪</a></p>
<h3 id="IDA-Pro-9-0-241217-SP1"><a href="#IDA-Pro-9-0-241217-SP1" class="headerlink" title="IDA Pro 9.0.241217 SP1"></a>IDA Pro 9.0.241217 SP1</h3><p>打包了配置好的IDA9 SP1,设置IDAPython路径即可使用</p>
<p>附件:</p>
<ul>
<li><p>IDAPlugins.zip</p>
</li>
<li><p>IdaPro9Beta-Keygen-iRabbit.py</p>
</li>
<li><p>IDA Professional 9.0.7z</p>
<p>  链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1eCmxbP6nNHm5qz41rFbetg?pwd=5hdq">https://pan.baidu.com/s/1eCmxbP6nNHm5qz41rFbetg?pwd=5hdq</a></p>
</li>
</ul>
<p>参考如下步骤</p>
<ol>
<li>运行ida-pro_90sp1_x64win.exe安装ida</li>
<li>修改IdaPro9Beta-Keygen-iRabbit.py文件的部分内容,复制到ida根目录</li>
<li>python运行keygen,自动修补</li>
<li>修改patched文件后缀,替换ida.dll和ida32.dll(注意保存原始文件)</li>
</ol>
<h3 id="IDA-Pro-9-1-250226"><a href="#IDA-Pro-9-1-250226" class="headerlink" title="IDA Pro 9.1.250226"></a>IDA Pro 9.1.250226</h3><p>相比之下9.1修了不少bug,分析程序更快更丝滑,还有signatures-bundle和IDA Feeds可以使用</p>
<p>实测9.0的patch脚本可用于9.1,并且大部分9.0的插件可用于9.1,由于二者配置方法类似便不多赘述</p>
<p>更新部分如下(2025&#x2F;04&#x2F;14):</p>
<ol>
<li><p>初始化IDA</p>
<p> 参考Binwalker师傅编写的7.7绿色版的IDA_InitTool</p>
<p> 使用python实现禁用IDA自动更新和设置IDAPython路径的功能(默认使用嵌入的python3.11.9</p>
</li>
<li><p>配置和使用IDA Feeds插件</p>
<p> 泄露文件中包括了符号库signatures-bundles-9.1.zip,物尽其用配置了一波该插件</p>
</li>
<li><p>配置和使用IDA MCP插件</p>
<p> 实测自动化分析效果和WPeChatGPT差不多,但能看到分析过程,需要注意消耗的token更多</p>
</li>
</ol>
<p>提供配置好的IDA9.1压缩包,初次使用前运行InitIDA.exe后即可使用(WPeChatgpt需要手动配置api和模型)<br>IDA Professional 9.1.7z 链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/16Hk9FjEygb1yohUzblxdFw?pwd=8put">https://pan.baidu.com/s/16Hk9FjEygb1yohUzblxdFw?pwd=8put</a> 提取码: 8put</p>
<h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1945680&highlight=Frida">Frida 安装 - 吾爱破解 </a></p>
<p>逆向过程中，借助<strong>Frida</strong> 可以更快的实现软件的逆向破解，Frida不仅可以实现Android应用的逆向，对于IOS应用，Windows应用同样可以实现不错的效果本文可能由于frida 代码的不断更新，可能出现某些错误或者过时，大家尽量以官方文档为主：</p>
<ul>
<li>frida-server 安装（Android）: <a target="_blank" rel="noopener" href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>frida-tools 安装：<a target="_blank" rel="noopener" href="https://frida.re/docs/installation/">https://frida.re/docs/installation/</a></li>
<li>frida 官方网站: <a target="_blank" rel="noopener" href="https://frida.re/">https://frida.re/</a></li>
<li>frida 官方文档：<a target="_blank" rel="noopener" href="https://frida.re/docs/">https://frida.re/docs/</a></li>
</ul>
<p>本次安装涉及Frida 的两个组件，一个是安装到手机或模拟器中的: <code>frida-server</code>，另外就是装在电脑上用于逆向分析的：<code>frida-tools</code>。</p>
<h4 id="frida-server-安装"><a href="#frida-server-安装" class="headerlink" title="frida-server 安装"></a><code>frida-server</code> 安装</h4><p>frida-server 本质上是一个二进制文件，将其拷贝到需要进行hook的系统中运行即可，下面以Android系统为例：</p>
<p>首先需要从 <strong>github</strong> 的仓库中下载编译好的 frida-server 文件。仓库地址：<a target="_blank" rel="noopener" href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>从Release中下载对应版本的文件即可。frida-server的命名规则为：<code>frida-server-&#123;版本号&#125;-&#123;支持的系统&#125;-&#123;CPU架构&#125;.&#123;压缩文件扩展名&#125;</code></p>
<p>认准自己手机或模拟器的架构下载即可。例如我是 arm64 的 Android 手机，那么我就下载 <code>frida-server-16.4.5-android-arm64.xz</code> 即可</p>
<p>下载到合适的frida-server后，使用<code>adb push</code>命令将二进制文件推送到目标设备中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>如果推送不成功，也可以先推送到 <code>/sdcard/</code> 目录后，再使用 <code>adb shell</code>将 frida-server 复制到 <code>/data/local/tmp/</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">mv /sdcard/frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>推送完成后，使用：<code>adb shell</code>命令进入shell，并赋予 <code>frida-server</code> 可执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure>

<p>上述工作都做完后，可以启动 <code>frida-server</code>了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">./frida-server</span><br></pre></td></tr></table></figure>

<p><code>frida-server</code>启动后不会有任何屏幕的提示信息。请注意这个命令行窗口不要关闭，如果命令窗口关闭后，<code>frida-server</code> 也会关闭</p>
<h4 id="frida-tools-安装"><a href="#frida-tools-安装" class="headerlink" title="frida-tools 安装"></a><code>frida-tools</code> 安装</h4><p>需要注意的是，上文提到的 frida-server 需与 frida 版本保持一致，安装 <code>frida-tools</code> 时又会自动安装 <code>frida</code> 。那么如何得知 <code>frida-tools</code> 版本呢？</p>
<p>首先打开 frida 仓库：<a target="_blank" rel="noopener" href="https://github.com/frida/frida">https://github.com/frida/frida</a>, 在 Release 中寻找 frida 版本并查找到 frida 的发布日期</p>
<p>获取到 frida 发布日期后，打开 frida-tools 仓库：<a target="_blank" rel="noopener" href="https://github.com/frida/frida-tools">https://github.com/frida/frida-tools</a> 寻找上述 frida 发布日期的相同或之后的一个 frida-tools 版本，请记住这个版本号！</p>
<p>以 Windows 系统为例，电脑中需要存在Python环境：</p>
<p>使用以下命令安装 <code>frida-tools</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">pip3 install frida-tools==&#123;frida-tools版本号&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>安装 <code>frida-tools</code> 时会自动安装 <code>frida</code> 所以不要像网上某些教程教的一样分别安装, 不然有可能会出现安装失败或安装后运行时报错等问题！</p>
</blockquote>
<p>如果安装时出现网络连接问题，或者一些与网络相关的错误，请多试几遍，也可使用以下方法：</p>
<ul>
<li>使用 <code>-i</code> 参数指定软件源：<code>pip3 install frida-tools==&#123;frida-tools版本号&#125; -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>使用 <code>--proxy</code> 参数: <code>pip3 install frida-tools==&#123;frida-tools版本号&#125; --proxy=&#39;socks5://127.0.0.1:7890&#39;</code></li>
</ul>
<p>安装完成后，使用命令<code>frida-ps</code> 命令验证是否安装成功：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  ----------------------------</span></span><br><span class="line"><span class="function">  832  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">27076  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">30132  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">22788  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">21040  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">30480  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function"> 1872  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">13060  <span class="title">conhost.exe</span></span></span><br><span class="line"><span class="function"> 1880  <span class="title">dllhost.exe</span></span></span><br><span class="line"><span class="function"> 8544  <span class="title">explorer.exe</span></span></span><br><span class="line"><span class="function">13700  <span class="title">frida</span>-<span class="title">ps.exe</span></span></span><br><span class="line"><span class="function">15032  <span class="title">nvcontainer.exe</span></span></span><br><span class="line"><span class="function">26740  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">27464  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">26948  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 2076  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 9824  <span class="title">sihost.exe</span></span></span><br><span class="line"><span class="function"> 9860  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9868  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9928  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">11208  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">20020  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">10020  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">10084  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<p>执行命令后出现的就是当前机器的进程列表，证明 <code>frida-tools</code> 单独运行是没问题的。那么如何测试是否能正确的与运行在手机或模拟器中的<code>frida-server</code>通信呢？</p>
<p>将手机与电脑连接后，按照上文说的启动 <code>frida-server</code> ，在命令行中使用 <code>frida-ps -U</code>命令查看手机进程：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span> -<span class="title">U</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  --------------------------------------------</span></span><br><span class="line"><span class="function">  683  <span class="title">ATFWD</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">24558  <span class="title">adbd</span></span></span><br><span class="line"><span class="function">  672  <span class="title">adsprpcd</span></span></span><br><span class="line"><span class="function">  686  <span class="title">alipayservice</span></span></span><br><span class="line"><span class="function">11860  <span class="title">android.process.acore</span></span></span><br><span class="line"><span class="function">22740  <span class="title">android.process.contacts</span></span></span><br><span class="line"><span class="function">11653  <span class="title">android.process.media</span></span></span><br><span class="line"><span class="function">  690  <span class="title">audiod</span></span></span><br><span class="line"><span class="function">  664  <span class="title">bspCriticalLog</span></span></span><br><span class="line"><span class="function">  662  <span class="title">cnd</span></span></span><br><span class="line"><span class="function">  680  <span class="title">cnss</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">12137  <span class="title">com.amap.android.location</span></span></span><br><span class="line"><span class="function">12262  <span class="title">com.android.incallui</span></span></span><br><span class="line"><span class="function">24490  <span class="title">com.android.keyguard</span></span></span><br><span class="line"><span class="function">22711  <span class="title">com.android.mms</span></span></span><br><span class="line"><span class="function">12125  <span class="title">com.android.phone</span></span></span><br><span class="line"><span class="function">14538  <span class="title">com.android.providers.downloads</span></span></span><br></pre></td></tr></table></figure>

<p>如果执行结果如上所示，那么基本上 frida 安装已经成功了，如果出现错误，请仔细检查以上的所有步骤是否正确。</p>
<h2 id="Ghidra"><a href="#Ghidra" class="headerlink" title="Ghidra"></a>Ghidra</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2020073&highlight=Ghidra">逆向分析工具GhidraMCP 吾爱破解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1793425&highlight=Ghidra">《Ghidra简介及使用方法》学习 - 吾爱破解</a></p>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a><strong>下载地址</strong>：</h3><p>从 GitHub Releases 下载对应系统的压缩包（如 <code>ghidra_11.0_PUBLIC_YYYYMMDD.zip</code>）。</p>
<p><strong>解压文件</strong>：</p>
<ul>
<li><p><strong>Windows</strong>：使用 WinRAR、7-Zip 或系统自带解压工具。</p>
</li>
<li><p><strong>Linux&#x2F;macOS</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip ghidra_11.0_PUBLIC_*.zip -d ~/ghidra</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h3><h4 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a><strong>Java 环境</strong></h4><p>Ghidra 需要 **Java 11+**（推荐 OpenJDK 11）：</p>
<ul>
<li><p><strong>Windows&#x2F;macOS</strong>：</p>
<ul>
<li>下载并安装 <a target="_blank" rel="noopener" href="https://adoptium.net/">Adoptium Temurin JDK 11</a>。</li>
</ul>
</li>
<li><p><strong>Linux</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk  # Ubuntu/Debian</span><br><span class="line">sudo dnf install java-11-openjdk # Fedora</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证-Java-版本"><a href="#验证-Java-版本" class="headerlink" title="验证 Java 版本"></a><strong>验证 Java 版本</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version  # 输出应包含 &quot;openjdk 11.0.x&quot;</span><br></pre></td></tr></table></figure>

<h3 id="启动-Ghidra"><a href="#启动-Ghidra" class="headerlink" title="启动 Ghidra"></a><strong>启动 Ghidra</strong></h3><p><strong>Windows</strong></p>
<ol>
<li>进入解压后的目录 <code>ghidra_11.0/</code>。</li>
<li>双击运行 **<code>ghidraRun.bat</code>**（可能需要管理员权限）</li>
</ol>
<h4 id="Linux-macOS"><a href="#Linux-macOS" class="headerlink" title="Linux&#x2F;macOS"></a><strong>Linux&#x2F;macOS</strong></h4><ol>
<li><p>打开终端，进入解压目录：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/ghidra/ghidra_11.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋予执行权限并启动：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ghidraRun</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="首次配置"><a href="#首次配置" class="headerlink" title="首次配置"></a><strong>首次配置</strong></h3><ol>
<li><strong>选择工作目录</strong>：<ul>
<li>首次启动时，Ghidra 会提示设置项目目录（默认 <code>~/ghidra_projects</code>）。</li>
</ul>
</li>
<li><strong>接受许可协议</strong>：<ul>
<li>阅读并同意 Ghidra 的许可条款。</li>
</ul>
</li>
</ol>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><p><strong>（1）创建项目</strong></p>
<ol>
<li>点击 **<code>File &gt; New Project</code>**。</li>
<li>选择 **”Non-Shared Project”**（个人项目），输入项目名称（如 <code>MyFirstProject</code>）。</li>
</ol>
<p><strong>（2）导入文件</strong></p>
<ol>
<li>在项目窗口中，右键点击项目名 → **<code>Import File</code>**。</li>
<li>选择要分析的二进制文件（如 <code>.exe</code>、<code>.elf</code>、<code>.dll</code>）。</li>
<li>保持默认选项，点击 **”Import”**。</li>
</ol>
<p><strong>（3）分析代码</strong></p>
<ol>
<li>双击导入的文件，Ghidra 会提示是否分析 → 点击 **”Yes”**。</li>
<li>选择分析选项（默认勾选所有），点击 **”Analyze”**：<ul>
<li><strong>反编译</strong>：查看伪代码（按 <code>F</code> 聚焦到函数）。</li>
<li><strong>字符串搜索</strong>：在 <code>Defined Strings</code> 列表查找线索（如 <code>flag&#123;</code>）。</li>
<li><strong>交叉引用（XRefs）</strong>：右键点击函数或变量 → **”References”**。</li>
</ul>
</li>
</ol>
<p><strong>（4）常用快捷键</strong></p>
<ul>
<li><code>F</code>：聚焦到当前函数。</li>
<li><code>G</code>：跳转到地址。</li>
<li><code>Ctrl + F</code>：在当前视图搜索文本。</li>
<li><code>;</code>：添加注释。</li>
</ul>
<hr>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a><strong>高级功能</strong></h3><p><strong>（1）脚本与插件</strong></p>
<ul>
<li><strong>脚本</strong>：在 <code>Window &gt; Script Manager</code> 中运行 Python 脚本（如自动解密算法）。</li>
<li><strong>插件</strong>：将插件放入 <code>ghidra_11.0/Ghidra/Extensions</code> 目录并重启。</li>
</ul>
<p><strong>（2）版本控制</strong></p>
<ul>
<li>支持通过 Git 管理项目（需手动配置）。</li>
</ul>
<p><strong>（3）反编译优化</strong></p>
<ul>
<li>在反编译窗口右键 → <strong>“Rename Variable”</strong> 或 <strong>“Retype Variable”</strong> 提高可读性。</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><p><strong>（1）启动报错 “No suitable Java version found”</strong></p>
<ul>
<li><strong>原因</strong>：未安装 Java 11 或环境变量配置错误。</li>
<li><strong>解决</strong>：<ul>
<li>检查 <code>java -version</code> 是否为 JDK 11。</li>
<li>手动指定 Java 路径（编辑 <code>ghidraRun</code> 脚本）。</li>
</ul>
</li>
</ul>
<p><strong>（2）分析卡死</strong></p>
<ul>
<li><strong>原因</strong>：大文件分析内存不足。</li>
<li><strong>解决</strong>：<ul>
<li>修改 <code>ghidraRun</code> 中的内存参数（如 <code>MAXMEM=4096M</code>）。</li>
</ul>
</li>
</ul>
<p><strong>（3）中文乱码</strong></p>
<ul>
<li><strong>解决</strong>：<ul>
<li>在反汇编视图右键 → <strong>“Options &gt; Listing Fields”</strong> → 修改字体为支持中文的字体（如宋体）。</li>
</ul>
</li>
</ul>
<h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a><strong>学习资源</strong></h3><ul>
<li><strong>官方文档</strong>：<br>  <a target="_blank" rel="noopener" href="https://ghidra-sre.org/">https://ghidra-sre.org/</a></li>
<li><strong>入门教程</strong>：<br>  <a target="_blank" rel="noopener" href="https://ghidra.re/ghidra_docs/Introductory_Tutorial.html">Ghidra 官方入门指南</a></li>
<li><strong>社区支持</strong>：<br>  <a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra/discussions">Ghidra 官方论坛</a></li>
</ul>
<h2 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h2><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><p>安装radare2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y gcc make cmake curl git  gcc-multilib</span><br><span class="line">git clone https://github.com/radare/radare2.git</span><br><span class="line">cd radare2</span><br><span class="line">./sys/install.sh</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line"></span><br><span class="line">make uninstall</span><br><span class="line">make purge</span><br></pre></td></tr></table></figure>

<h3 id="window环境"><a href="#window环境" class="headerlink" title="window环境"></a>window环境</h3><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-225529.htm">在Windows平台下的使用radare2进行调试-外文翻译-看雪</a></p>
<p>在Windows上安装Radare2并配置r2pipe库的步骤如下：</p>
<h3 id="下载正确的文件"><a href="#下载正确的文件" class="headerlink" title="下载正确的文件"></a><strong>下载正确的文件</strong></h3><p>访问 <a target="_blank" rel="noopener" href="https://github.com/radareorg/radare2/releases/tag/5.9.8">Radare2 5.9.8 发布页面</a>，在 <strong>Assets</strong> 部分找到以下文件：</p>
<ul>
<li><strong><code>radare2-5.9.8-w64.zip</code></strong><ul>
<li>这是 <strong>64 位 Windows 系统</strong>的预编译版本，适用于天选2笔记本（现代笔记本通常为 64 位系统）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><strong>安装步骤</strong></h3><ol>
<li><p><strong>下载文件</strong>：点击 <code>radare2-5.9.8-w64.zip</code> 下载压缩包。</p>
</li>
<li><p><strong>解压文件</strong>：将压缩包解压到任意目录（例如 <code>C:\radare2</code>）。</p>
</li>
<li><p><strong>配置环境变量</strong>：</p>
<ul>
<li>将 Radare2 的 <code>bin</code> 目录（如 <code>C:\radare2\bin</code>）添加到系统 <code>PATH</code> 环境变量。</li>
<li><strong>步骤</strong>：<ol>
<li>右键点击“此电脑” → 属性 → 高级系统设置 → 环境变量 → 编辑系统变量 <code>Path</code> → 添加 <code>C:\radare2\bin</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>验证安装</strong>：</p>
<ul>
<li><p>打开命令提示符（CMD 或 PowerShell），输入：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2 -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出应显示版本信息：<code>radare2 5.9.8 ...</code>。</p>
</li>
</ul>
</li>
<li><p>打开命令提示符（CMD）或PowerShell，并导航至Radare2所在目录。使用以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd C:\radare2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该目录下执行以下命令来运行Radare2：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p>这将启动Radare2交互式环境。</p>
<p> 验证Radare2是否正确安装。在Radare2交互式环境中，输入<code>?</code>或<code>help</code>命令查看帮助文档。</p>
<p> 接下来，您可以通过pip来安装r2pipe库。请确保您已经安装了Python和pip。</p>
<p> 打开命令提示符或PowerShell，并运行以下命令来安装r2pipe库：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install r2pipe</span><br></pre></td></tr></table></figure>

<p> 安装完成后，您可以在Python脚本中导入并使用r2pipe库与已安装的Radare2进行交互了。</p>
</li>
</ol>
<p>以上是在Windows上安装和配置Radare 2及r2pipe库的基本步骤。根据系统和安装方式，可能会有细微差异，请参考官方文档或社区支持寻求更详细的帮助。</p>
<p>安装程序都将radare2.exe以及其他工具放在C：&#x2F;users &#x2F;username &#96;&#96;&#x2F; AppData目录中。 我必须从命令行将目录切换到该文件夹才能使用可执行文件。 为了从命令行的任何位置访问该文件，必须将该目录添加到$ PATH环境变量中。 这计算机用来查找可以从系统的任何位置运行的命令和应用程序的变量。<br>要设置你的$ PATH变量，你可以通过以下两种方法之一来完成。 您可以通过转到系统属性 -&gt;高级 -&gt;环境变量来使用Windows GUI进行更改，单击路径变量并单击编辑。 然后你可以添加你的radare2文件的目录。</p>
<h3 id="命令行使用方法"><a href="#命令行使用方法" class="headerlink" title="命令行使用方法"></a>命令行使用方法</h3><p>Radare2 在命令行下有一些小工具可供使用：</p>
<ul>
<li>radare2：十六进制编辑器和调试器的核心，通常通过它进入交互式界面。</li>
<li>rabin2：从可执行二进制文件中提取信息。</li>
<li>rasm2：汇编和反汇编。</li>
<li>rahash2：基于块的哈希工具。</li>
<li>radiff2：二进制文件或代码差异比对。</li>
<li>rafind2：查找字节模式。</li>
<li>ragg2：r_egg 的前端，将高级语言编写的简单程序编译成x86、x86-64和ARM的二进制文件。</li>
<li>rarun2：用于在不同环境中运行程序。</li>
<li>rax2：数据格式转换。</li>
</ul>
<h4 id="radare2-r2"><a href="#radare2-r2" class="headerlink" title="radare2&#x2F;r2"></a>radare2&#x2F;r2</h4><p>参数很多，这里最重要是 <code>file</code>。如果想 attach 到一个进程上，则使用 <code>pid</code>。常用参数如下：</p>
<ul>
<li><code>-A</code>：相当于在交互界面输入了 <code>aaa</code>。</li>
<li><code>-c</code>：运行 radare 命令。（<code>r2 -A -q -c &#39;iI~pic&#39; file</code>）</li>
<li><code>-d</code>：调试二进制文件或进程。</li>
<li><code>-a</code>,<code>-b</code>,<code>-o</code>：分别指定体系结构、位数和操作系统，通常是自动的，但也可以手动指定。</li>
<li><code>-w</code>：使用可写模式打开。</li>
</ul>
<h4 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h4><p>拿到一个二进制文件时，第一步就是获取关于它的基本信息，这时候就可以使用 rabin2。rabin2 可以获取包括 ELF、PE、Mach-O、Java CLASS 文件的区段、头信息、导入导出表、数据段字符串、入口点等信息，并且支持多种格式的输出。</p>
<p>下面介绍一些常见的用法：</p>
<ul>
<li><code>-I</code>：最常用的参数，它可以打印出二进制文件信息，其中我们需要重点关注其使用的安全防护技术，如 canary、pic、nx 等。（<code>file</code>、<code>chekcsec -f</code>）</li>
<li><code>-e</code>：得到二进制文件的入口点。（｀readelf -h&#96;）</li>
<li><code>-i</code>：获得导入符号表，RLT中的偏移等。（<code>readelf -r</code>）</li>
<li><code>-E</code>：获得全局导出符号表。</li>
<li><code>-s</code>：获得符号表。（<code>readelf -s</code>）</li>
<li><code>-l</code>：获得二进制文件使用到的动态链接库。（<code>ldd</code>）</li>
<li><code>-z</code>：从 ELF 文件的 .rodare 段或 PE 文件的 .text 中获得字符串。（<code>strings -d</code>）</li>
<li><code>-S</code>：获得完整的段信息。（<code>readelf -S</code>）</li>
<li><code>-c</code>：列出所有类，在分析 Java 程序是很有用。</li>
</ul>
<p>最后还要提到的一个参数 <code>-r</code>，它可以将得到的信息以 radare2 可读的形式输出，在后续的分析中可以将这样格式的信息输入 radare2，这是非常有用的。</p>
<h4 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h4><p>rasm2 是一个内联汇编、反汇编程序。它的主要功能是获取给定机器指令操作码对应的字节。</p>
<p>下面是一些重要的参数：</p>
<ul>
<li><code>-L</code>：列出目标体系结构所支持的插件，输出中的第一列说明了插件提供的功能（a&#x3D;asm, d&#x3D;disasm, A&#x3D;analyze, e&#x3D;ESIL）。</li>
<li><code>-a</code>：知道插件的名字后，就可以使用 -a&#96; 来进行设置。</li>
<li><code>-b</code>：设置CPU寄存器的位数。</li>
<li><code>-d</code>：反汇编十六进制对字符串。</li>
<li><code>-D</code>：反汇编并显示十六进制对和操作码。</li>
<li><code>-C</code>：汇编后以 C 语言风格输出。</li>
<li><code>-f</code>：从文件中读入汇编代码。</li>
</ul>
<h4 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h4><p>rahash2 用于计算检验和，支持字节流、文件、字符串等形式和多种算法。</p>
<p>重要参数：</p>
<ul>
<li><code>-a</code>：指定算法。默认为 sha256，如果指定为 all，则使用所有算法。</li>
<li><code>-b</code>：指定块的大小（而不是整个文件）</li>
<li><code>-B</code>：打印处每个块的哈希</li>
<li><code>-s</code>：指定字符串（而不是文件）</li>
<li><code>-a entropy</code>：显示每个块的熵（<code>-B -b 512 -a entropy</code>）</li>
</ul>
<h4 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h4><p>radiff2 是一个基于偏移的比较工具。</p>
<p>重要参数：</p>
<ul>
<li><p><code>-s</code>：计算文本距离并得到相似度。</p>
</li>
<li><p><code>－AC</code>：这两个参数通常一起使用，从函数的角度进行比较。</p>
</li>
<li><pre><code>  -g
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	：得到给定的符号或两个偏移的图像对比。</span><br><span class="line"></span><br><span class="line">	- 如：`radiff2 -g main a.out b.out | xdot -`（需要安装xdot）</span><br><span class="line"></span><br><span class="line">- `-c`：计算不同点的数量。</span><br><span class="line"></span><br><span class="line">#### rafind2</span><br><span class="line"></span><br><span class="line">rafind2 用于在二进制文件中查找字符模式。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-s`：查找特定字符串。</span><br><span class="line">- `-e`：使用正则匹配。</span><br><span class="line">- `-z`：搜索以`\0`结束的字符串。</span><br><span class="line">- `-x`：查找十六进制字符串。</span><br><span class="line"></span><br><span class="line">#### ragg2</span><br><span class="line"></span><br><span class="line">ragg2 可以将高级语言编写的简单程序编译成 x86、x86-64 或 ARM 的二进制文件。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-a`：设置体系结构。</span><br><span class="line">- `-b`：设置体系结构位数(32/64)。</span><br><span class="line">- `-P`：生成某种模式的字符串，常用于输入到某程序中并寻找溢出点。</span><br><span class="line">- -r：使用原始字符而不是十六进制对。</span><br><span class="line">	- ragg2 -P 50 -r`</span><br><span class="line">- -i：生成指定的 shellcode。查看-L。</span><br><span class="line">	- `ragg2 -a x86 -b 32 -i exec`</span><br><span class="line">- `-e`：使用指定的编码器。查看 `-L`。</span><br><span class="line"></span><br><span class="line">#### rarun2</span><br><span class="line"></span><br><span class="line">rarun2 是一个可以使用不同环境、参数、标准输入、权限和文件描述符的启动器。</span><br><span class="line"></span><br><span class="line">常用的参数设置：</span><br><span class="line"></span><br><span class="line">- `program`</span><br><span class="line">- `arg1`, `arg2`,…</span><br><span class="line">- `setenv`</span><br><span class="line">- `stdin`, `stdout`</span><br><span class="line"></span><br><span class="line">#### rax2</span><br><span class="line"></span><br><span class="line">rax2 是一个格式转换工具，在二进制、八进制、十六进制数字和字符串之间进行转换。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-e`：交换字节顺序</span><br><span class="line">- `-s`：十六进制-&gt;字符</span><br><span class="line">- `-S`：字符-&gt;十六进制</span><br><span class="line">- `-D`, `-E`：base64 解码和编码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **GDB（Linux）**</span><br><span class="line"></span><br><span class="line">1. 安装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  sudo apt install gdb
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 基础命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  gdb ./target         # 加载程序
  break main           # 在main函数下断点
  run                 # 运行
  ni                  # 单步执行
  info registers      # 查看寄存器
</code></pre>
</li>
</ul>
<h2 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h2><p>x64dbg 是一款开源的、目前仍在积极开发中的 x32&#x2F;x64 位动态调试器。其界面及操作方法与 <a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-350397-1-1.html">OllyDbg</a> 类似，和 OllyDbg 不同的是它可以对 64 位程序进行调试。此外，其开放式的设计给了此软件很强的生命力。通过爱好者们不断的修改和扩充，使其功能越来越强大。<br>该调试器(目前)有三部分：DBG、GUI、Bridge：<br>DBG 是调试器的调试部分。它处理调试技术(使用 TitanEngine 引擎，近来还新增了 Gleebug 引擎)，并为 GUI 提供数据。<br>GUI 是调试器的图形部分。它建立在 Qt 上，并提供用户交互界面。<br>Bridge 是 DBG 和 GUI 部分的通信库(将来也许是在更多的部件之间)。Bridge 可用于在新建功能上工作，而无需更新代码的其他部分。</p>
<p><strong>汉化修订说明：</strong></p>
<ol>
<li>对 x64dbg 帮助文档的主要内容进行了汉化，并按照最新版进行了修订、补译。对界面字体以及布局重新进行了设置。将默认调用在线英文帮助更改为调用本地中文帮助文件。</li>
<li>为帮助用户更好地了解 x64dbg 反汇编后的 CPU 汇编指令信息，对汇编指令的“助记符摘要”全部进行了汉化。对“助记符帮助”进行了部分汉化。汇编指令的汉化参考了“清华大学出版社”出版的《汇编语言程序设计教程》(第4版) 中术语，因此可能与其他软件的汉化术语略有不同。</li>
<li>对 Scylla 插件等进行了全面汉化。</li>
<li>对 x64dbg 官方中文版的汉化错误及不一致处进行了修订，并与帮助文档的关键词进行了统一。</li>
<li>对中文版界面的字体进行了重新设置，使其更为美观。</li>
<li>对“暗黑”主题界面颜色的默认值进行了调整，使代码显示更为清晰。并对主题的“选项&gt;外观”对话框中的“颜色”和“字体”标签的排列错位进行了调整。</li>
<li>本次更新集成了可在“CPU”界面搜索中文字符串引用的 x64dbg_tol 插件。</li>
<li>本次更新版本修改了启动条件，改为直接以管理员权限启动。</li>
<li>本次去除了新版本主程序的数字签名，解决了某些 DLL 文件的非标字串不能汉化的问题。</li>
</ol>
<p>在x64dbg中设置条件断点 – by elecs@看雪学院<br><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-251385.htm">https://bbs.pediy.com/thread-251385.htm</a></p>
<p>x64dbg Plugin Manager 第三方人员开发的插件管理器<br><a target="_blank" rel="noopener" href="https://github.com/horsicq/x64dbg-Plugin-Manager">https://github.com/horsicq/x64dbg-Plugin-Manager</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://x64dbg.com/">https://x64dbg.com/</a></p>
<p>x64dbg官方下载地址（软件原版已经自带简体中文语言）<br><a target="_blank" rel="noopener" href="https://github.com/x64dbg/x64dbg/releases">https://github.com/x64dbg/x64dbg/releases</a><br><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/x64dbg/files/snapshots">https://sourceforge.net/projects/x64dbg/files/snapshots</a></p>
<p>x64dbg 简体中文版(Jan 6 2024)： <a target="_blank" rel="noopener" href="https://www.lanzouu.com/iuFXx1l65ush">https://www.lanzouu.com/iuFXx1l65ush</a></p>
<h2 id="HxD-Hex-Editor"><a href="#HxD-Hex-Editor" class="headerlink" title="HxD Hex Editor"></a>HxD Hex Editor</h2><p>HxD Hex Editor 是一款功能强大的十六进制编辑器和磁盘编辑器，它可以让你直接查看和编辑二进制文件的内容。你可以使用HxD Hex Editor来分析、修改和处理各种数据格式，包括程序文件、磁盘映像、内存转储以及其他二进制文件。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://mh-nexus.de/en/hxd">HxD | https://mh-nexus.de/en/hxd</a></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><ol>
<li><p>以十六进制表示方式显示文件内容，并允许直接编辑其中的字节</p>
</li>
<li><p>支持将数据按特定数据类型进行解析和显示，方便对结构化数据进行编辑和分析。</p>
<p> 视图  &gt;&gt;  位置显示数制、数据显示、字节分组大小</p>
</li>
<li><p>可用于比较两个文件的差异，以找出变更或修改的部分。</p>
<p> 将两个图像的数据进行对比</p>
</li>
<li><p>可以执行文本或二进制数据的搜索和替换操作，帮助定位和修改特定的数据。</p>
<p> 搜索  &gt;&gt;  搜索（Ctrl+F）……</p>
</li>
<li><p>支持将数据导入到文件中或将文件导出为不同的数据格式</p>
<p> 文件 &gt;&gt;  导出  &gt;&gt;  ……</p>
</li>
<li><p>能够处理非常大的文件，并且在编辑和浏览时保持快速响应。</p>
</li>
</ol>
<p>了解更多详情：<a target="_blank" rel="noopener" href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a></p>
<p>用途<br>HxD Hex Editor通常用于以下几个方面：</p>
<p>1）帮助软件开发人员进行反汇编、调试和逆向工程。查看和修改程序的二进制代码，以理解其内部结构、修复漏洞或进行功能定制。</p>
<p>2）对于受损的文件或存储介质，HxD Hex Editor可以帮助您直接浏览并修复数据错误。查看和编辑二进制数据来识别并修复文件中的损坏部分，如磁盘映像、内存转储等。</p>
<p>3）HxD Hex Editor提供了强大的数据分析和处理功能，一些游戏会使用二进制文件格式来存储游戏数据。</p>
<h2 id="010editor"><a href="#010editor" class="headerlink" title="010editor"></a>010editor</h2><p>16进制文件编辑工具，以16进制方式打开文件。</p>
<p><strong>总的（包含linux和windows以及破解软件）：</strong><br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu">https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu</a><br>提取码：1ynu</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/NS_ice/article/details/132398846">010editor的安装与基本操作-CSDN博客</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Spontaneous_0/article/details/142087893">2024CTF入门指南、CTF夺旗赛及刷题网站-CSDN博客</a></p>
<h6 id="CTF-引言"><a href="#CTF-引言" class="headerlink" title="CTF 引言"></a><a target="_blank" rel="noopener" href="https://primer.picoctf.org/#_input_and_output">CTF 引言</a></h6> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://tangxtang1119.github.io/2025/04/26/CTF/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag">信息安全</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/04/27/oup/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            oup
          
        </div>
      </a>
    
    
      <a href="/2025/04/24/Android/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Android</div>
      </a>
    
  </nav>

   
 
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2025
        <i class="ri-heart-fill heart_icon"></i> 唐小唐
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/yuhangyuan.ico" alt="tangxtang"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=2658106011&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>