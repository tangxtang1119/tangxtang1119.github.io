<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础总结</title>
    <url>/2025/05/01/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="一、基础语法结构"><a href="#一、基础语法结构" class="headerlink" title="一、基础语法结构"></a>一、基础语法结构</h2><h3 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1. 变量与数据类型"></a>1. 变量与数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;                  <span class="comment">// 整数（4字节）</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">9.99</span>;           <span class="comment">// 双精度浮点</span></span><br><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;              <span class="comment">// 单个字符</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isOpen</span> <span class="operator">=</span> <span class="literal">true</span>;         <span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用数据类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Android&quot;</span>;       <span class="comment">// 字符串</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;       <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>

<h3 id="2-控制流程"><a href="#2-控制流程" class="headerlink" title="2. 控制流程"></a>2. 控制流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">40</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;补考&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;挂科&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环结构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);      <span class="comment">// 0,1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(j++);    <span class="comment">// 0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、面向对象核心"><a href="#二、面向对象核心" class="headerlink" title="二、面向对象核心"></a>二、面向对象核心</h2><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象使用</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">p.sayHello();  <span class="comment">// 输出: Hello, I&#x27;m Alice</span></span><br></pre></td></tr></table></figure>

<h3 id="2-继承与多态"><a href="#2-继承与多态" class="headerlink" title="2. 继承与多态"></a>2. 继承与多态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);  <span class="comment">// 方法重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态示例</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">myDog.sound();  <span class="comment">// 输出: 汪汪汪</span></span><br></pre></td></tr></table></figure>

<h2 id="三、关键语法特性"><a href="#三、关键语法特性" class="headerlink" title="三、关键语法特性"></a>三、关键语法特性</h2><h3 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1. 访问修饰符"></a>1. 访问修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>类内</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
</tr>
<tr>
<td><code>public</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>默认</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
</tbody></table>
<h3 id="2-接口与抽象类"><a href="#2-接口与抽象类" class="headerlink" title="2. 接口与抽象类"></a>2. 接口与抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口（100%抽象）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;  <span class="comment">// 隐式 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类（可包含实现）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123; <span class="comment">/* 具体实现 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;总会执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、集合框架"><a href="#五、集合框架" class="headerlink" title="五、集合框架"></a>五、集合框架</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用集合类</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 有序可重复</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();     <span class="comment">// 无序唯一</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合操作</span></span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="六、其他逆向重点"><a href="#六、其他逆向重点" class="headerlink" title="六、其他逆向重点"></a>六、其他逆向重点</h2><h3 id="1-反射机制（逆向关键）"><a href="#1-反射机制（逆向关键）" class="headerlink" title="1. 反射机制（逆向关键）"></a>1. 反射机制（逆向关键）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;secretMethod&quot;</span>);</span><br><span class="line">method.invoke(clazz.newInstance());</span><br></pre></td></tr></table></figure>

<h3 id="2-泛型（反编译常见）"><a href="#2-泛型（反编译常见）" class="headerlink" title="2. 泛型（反编译常见）"></a>2. 泛型（反编译常见）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Integer&gt;&gt; complexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步执行&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h2 id="七、内存管理基础"><a href="#七、内存管理基础" class="headerlink" title="七、内存管理基础"></a><strong>七、内存管理基础</strong></h2><ol>
<li><strong>栈内存</strong>：存储基本类型变量和方法调用</li>
<li><strong>堆内存</strong>：存储对象实例</li>
<li><strong>方法区</strong>：存储类信息、常量池</li>
<li><strong>垃圾回收</strong>：自动回收无引用对象（<code>System.gc()</code>建议回收）</li>
</ol>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a><strong>学习建议</strong></h2><ol>
<li><strong>重点掌握</strong>：类与对象、继承多态、集合框架</li>
<li><strong>逆向关联</strong>：反射机制、异常处理、接口特性</li>
<li><strong>实践方法</strong>：通过修改开源项目的代码观察运行结果</li>
</ol>
<p><strong>附：逆向工程中常见的Java代码特征</strong></p>
<ul>
<li><code>private static final</code> 修饰的密钥字段</li>
<li><code>try-catch</code> 包裹的核心逻辑</li>
<li><code>native</code> 声明的JNI方法</li>
<li><code>synchronized</code> 同步代码块</li>
</ul>
<p>结合APK反编译后的实际代码进行对照学习，理解语法到字节码的转换逻辑。</p>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="一、基本特性与优势"><a href="#一、基本特性与优势" class="headerlink" title="一、基本特性与优势"></a>一、基本特性与优势</h2><ul>
<li><strong>简洁性</strong>：语法精简，减少模板代码（如省略分号、简化类定义）。</li>
<li><strong>空安全</strong>：编译期检查空指针，从语法层面避免 <code>NullPointerException</code>。</li>
<li><strong>函数式编程</strong>：支持 Lambda 表达式、高阶函数、协程等。</li>
<li><strong>面向对象</strong>：保留类、继承、接口等 OOP 特性，同时更灵活。</li>
<li><strong>与 Java 互操作</strong>：可直接调用 Java 代码，Java 也可调用 Kotlin 代码，无缝兼容 Android 现有项目。</li>
</ul>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h3><p>Kotlin 变量分为<strong>可变</strong>（<code>var</code>）和<strong>不可变</strong>（<code>val</code>，类似 Java 的 <code>final</code>），无需显式声明类型（类型推断）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可变变量（推荐优先使用）</span></span><br><span class="line"><span class="keyword">val</span> name: String = <span class="string">&quot;Kotlin&quot;</span>  <span class="comment">// 显式声明类型</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span>  <span class="comment">// 类型推断为 Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">90</span>  <span class="comment">// 类型推断为 Int</span></span><br><span class="line">score = <span class="number">95</span>  <span class="comment">// 可修改</span></span><br></pre></td></tr></table></figure>

<h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h3><p>与 Java 类似，但<strong>无基本类型与包装类之分</strong>，全部是对象，支持直接调用方法：</p>
<ul>
<li>数值类型：<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code></li>
<li>字符：<code>Char</code>（单引号，如 <code>&#39;A&#39;</code>）</li>
<li>布尔：<code>Boolean</code>（<code>true</code>&#x2F;<code>false</code>）</li>
<li>字符串：<code>String</code>（双引号，支持模板语法 <code>$&#123;&#125;</code>）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">10L</span>  <span class="comment">// 加 L 表示 Long 类型</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">3.14f</span>  <span class="comment">// 加 f 表示 Float 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串模板</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="keyword">val</span> info = <span class="string">&quot;Language: <span class="variable">$name</span>, Version: <span class="subst">$&#123;<span class="number">1.9</span> + <span class="number">0.1</span>&#125;</span>&quot;</span>  <span class="comment">// 输出 &quot;Language: Kotlin, Version: 2.0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-函数定义"><a href="#3-函数定义" class="headerlink" title="3. 函数定义"></a>3. 函数定义</h3><p>用 <code>fun</code> 关键字定义，语法：&#96;fun 函数名(参数: 类型): 返回值类型 { … }</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单表达式函数（简化写法，自动推断返回值）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiply</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b  <span class="comment">// 等价于返回 a*b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值（返回 Unit，类似 Java 的 void，可省略）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHi</span><span class="params">()</span></span> &#123;  <span class="comment">// 省略 Unit</span></span><br><span class="line">    println(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特色参数</strong>：</p>
<ul>
<li><p>默认参数：给参数设置默认值，调用时可省略</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;Guest&quot;</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet()  <span class="comment">// 输出 &quot;Hello, Guest&quot;</span></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment">// 输出 &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名参数：调用时指定参数名，增强可读性</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span> = a + b + c</span><br><span class="line">add(b = <span class="number">2</span>, a = <span class="number">1</span>, c = <span class="number">3</span>)  <span class="comment">// 按名称传参，结果 6</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a>三、控制流</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h3><ul>
<li><p><code>if</code>可作为<strong>表达式</strong>（有返回值），替代 Java 的<code>三元运算符</code>：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b  <span class="comment">// 等价于 Java 的 a &gt; b ? a : b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多分支用 <code>if-else if-else</code>，逻辑同 Java。</p>
</li>
</ul>
<h3 id="2-when-表达式（替代-Java-的-switch）"><a href="#2-when-表达式（替代-Java-的-switch）" class="headerlink" title="2. when 表达式（替代 Java 的 switch）"></a>2. when 表达式（替代 Java 的 switch）</h3><p>更灵活，支持任意类型匹配，且可作为表达式返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(x: <span class="type">Any</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">&quot;Int 类型，值为 1&quot;</span></span><br><span class="line">        <span class="string">&quot;hello&quot;</span> -&gt; <span class="string">&quot;String 类型&quot;</span></span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Boolean</span> -&gt; <span class="string">&quot;Boolean 类型&quot;</span>  <span class="comment">// 类型匹配（is 类似 Java 的 instanceof）</span></span><br><span class="line">        <span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; <span class="string">&quot;在 10-20 范围内&quot;</span>  <span class="comment">// 范围匹配</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;未知类型&quot;</span>  <span class="comment">// 必须包含 else（除非覆盖所有可能）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h3><ul>
<li><p><code>for</code> 循环：遍历集合或范围（<code>..</code> 表示闭区间）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历范围</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;  <span class="comment">// 1 到 5（包含 5）</span></span><br><span class="line">    print(i)  <span class="comment">// 输出 12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while</code> 和 <code>do-while</code>：与 Java 语法完全一致。</p>
</li>
</ul>
<h2 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h2><h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><p>默认是<strong>不可继承的</strong>（<code>final</code>），需用 <code>open</code> 关键字标记才能被继承：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 类成员变量</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可继承的类（open 修饰）</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;动物进食&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul>
<li><p><strong>主构造函数</strong>：类名后直接声明，简洁用于初始化参数</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> name: String) &#123;  <span class="comment">// 主构造函数参数</span></span><br><span class="line">    <span class="comment">// 初始化代码块（主构造函数执行时调用）</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student 初始化：id=<span class="variable">$id</span>, name=<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：val stu = Student(1, &quot;Tom&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>次构造函数</strong>：用 <code>constructor</code> 关键字，需调用主构造函数（<code>this</code>）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 次构造函数（必须调用主构造函数）</span></span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Int</span>, name: String) : <span class="keyword">this</span>(id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-数据类（data-class）"><a href="#3-数据类（data-class）" class="headerlink" title="3. 数据类（data class）"></a>3. 数据类（data class）</h3><p>专门用于存储数据的类，自动生成 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等方法，简化实体类定义（Android 中常用于网络数据模型）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">val</span> user = User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">println(user)  <span class="comment">// 自动生成 toString()：User(id=1, name=Alice, age=25)</span></span><br><span class="line"><span class="keyword">val</span> user2 = user.copy(age = <span class="number">26</span>)  <span class="comment">// 复制对象并修改部分属性</span></span><br></pre></td></tr></table></figure>

<h3 id="4-密封类（sealed-class）"><a href="#4-密封类（sealed-class）" class="headerlink" title="4. 密封类（sealed class）"></a>4. 密封类（sealed class）</h3><p>用于<strong>受限的类层次结构</strong>（子类固定），常用于状态管理（如 UI 状态：加载中、成功、失败）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> <span class="keyword">data</span>: String) : Result()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> message: String) : Result()</span><br><span class="line"><span class="keyword">object</span> Loading : Result()  <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时，when 语句可自动推断所有子类，无需 else</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleResult</span><span class="params">(result: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (result) &#123;</span><br><span class="line">        <span class="keyword">is</span> Success -&gt; println(<span class="string">&quot;成功：<span class="subst">$&#123;result.data&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> Error -&gt; println(<span class="string">&quot;错误：<span class="subst">$&#123;result.message&#125;</span>&quot;</span>)</span><br><span class="line">        Loading -&gt; println(<span class="string">&quot;加载中...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、继承与接口"><a href="#五、继承与接口" class="headerlink" title="五、继承与接口"></a>五、继承与接口</h2><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><p>用 <code>:</code> 表示继承，父类需用 <code>open</code> 修饰，重写方法需用 <code>override</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;  <span class="comment">// 可重写的方法（open 修饰）</span></span><br><span class="line">        println(<span class="string">&quot;动物叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="type">Animal</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;  <span class="comment">// 重写父类方法（override 修饰）</span></span><br><span class="line">        println(<span class="string">&quot;汪汪叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><p>用 <code>interface</code> 定义，支持<strong>默认方法实现</strong>，类用 <code>:</code> 实现接口（可多实现）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimable</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法（无实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法（有实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;在水中呼吸&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="type">Swimable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;鱼游来游去&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、空安全（核心特性）"><a href="#六、空安全（核心特性）" class="headerlink" title="六、空安全（核心特性）"></a>六、空安全（核心特性）</h2><p>Kotlin 区分<strong>可空类型</strong>（可能为 <code>null</code>）和<strong>非空类型</strong>（不可为 <code>null</code>），编译期避免空指针：</p>
<h4 id="1-可空类型标记"><a href="#1-可空类型标记" class="headerlink" title="1. 可空类型标记"></a>1. 可空类型标记</h4><p>在类型后加 <code>?</code> 表示可空：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String = <span class="string">&quot;abc&quot;</span>  <span class="comment">// 非空类型，不能赋值 null</span></span><br><span class="line">str = <span class="literal">null</span>  <span class="comment">// 编译报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nullableStr: String? = <span class="string">&quot;xyz&quot;</span>  <span class="comment">// 可空类型</span></span><br><span class="line">nullableStr = <span class="literal">null</span>  <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<h4 id="2-安全操作符"><a href="#2-安全操作符" class="headerlink" title="2. 安全操作符"></a>2. 安全操作符</h4><ul>
<li><p>**安全调用 <code>?.</code>**：若对象为 <code>null</code>，则表达式返回 <code>null</code>（不崩溃）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> length = nullableStr?.length  <span class="comment">// 若 nullableStr 为 null，length 为 null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**Elvis 操作符 <code>?:</code>**：若左侧为 <code>null</code>，则返回右侧默认值</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> len = nullableStr?.length ?: <span class="number">0</span>  <span class="comment">// 若为 null，返回 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**非空断言 <code>!!</code>**：强制认为对象非空，若为 <code>null</code> 则抛出 <code>NullPointerException</code>（谨慎使用）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> len = nullableStr!!.length  <span class="comment">// 若 nullableStr 为 null，崩溃</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、集合框架"><a href="#七、集合框架" class="headerlink" title="七、集合框架"></a>七、集合框架</h2><p>Kotlin 集合分为<strong>不可变</strong>（默认，只读）和<strong>可变</strong>（可读写），通过不同函数创建：</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>不可变（只读）</th>
<th>可变（可读写）</th>
</tr>
</thead>
<tbody><tr>
<td>列表</td>
<td><code>listOf()</code></td>
<td><code>mutableListOf()</code></td>
</tr>
<tr>
<td>集合</td>
<td><code>setOf()</code></td>
<td><code>mutableSetOf()</code></td>
</tr>
<tr>
<td>映射</td>
<td><code>mapOf()</code></td>
<td><code>mutableMapOf()</code></td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可变列表（无法添加/删除元素）</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变列表</span></span><br><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">mutableList.add(<span class="number">4</span>)  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射（键值对）</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;version&quot;</span> to <span class="number">1.9</span>)</span><br><span class="line">println(map[<span class="string">&quot;name&quot;</span>])  <span class="comment">// 输出 &quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>集合操作</strong>（函数式风格）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> evenNumbers = numbers.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;  <span class="comment">// 过滤偶数：[2,4]</span></span><br><span class="line"><span class="keyword">val</span> squares = numbers.map &#123; it * it &#125;  <span class="comment">// 求平方：[1,4,9,16,25]</span></span><br><span class="line"><span class="keyword">val</span> sum = numbers.reduce &#123; acc, num -&gt; acc + num &#125;  <span class="comment">// 累加：15</span></span><br></pre></td></tr></table></figure>

<h2 id="八、扩展函数"><a href="#八、扩展函数" class="headerlink" title="八、扩展函数"></a>八、扩展函数</h2><p>无需继承，直接给现有类添加新方法（如给 <code>String</code> 加 <code>isEmail</code> 方法）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 String 扩展一个判断是否为邮箱的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isEmail</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contains(<span class="string">&quot;@&quot;</span>) &amp;&amp; contains(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">val</span> email = <span class="string">&quot;test@example.com&quot;</span></span><br><span class="line">println(email.isEmail())  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p><strong>Android 中常用</strong>：给 <code>Context</code> 扩展 <code>toast</code> 方法，简化弹窗：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">toast</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Activity 中直接调用</span></span><br><span class="line">toast(<span class="string">&quot;Hello Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="九、Lambda-表达式与高阶函数"><a href="#九、Lambda-表达式与高阶函数" class="headerlink" title="九、Lambda 表达式与高阶函数"></a>九、Lambda 表达式与高阶函数</h3><h3 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h3><p>匿名函数，语法：<code>&#123; 参数 -&gt; 函数体 &#125;</code>，常用于简化回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接收 Lambda 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    action()  <span class="comment">// 执行 Lambda</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：传递 Lambda</span></span><br><span class="line">doSomething &#123;</span><br><span class="line">    println(<span class="string">&quot;执行操作&quot;</span>)  <span class="comment">// 输出 &quot;执行操作&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h3><p>参数或返回值为函数的函数（如集合的 <code>filter</code>、<code>map</code>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数：参数为 (Int) -&gt; Boolean 类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">filterNumbers</span><span class="params">(numbers: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, predicate: (<span class="type">Int</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate(num)) &#123;  <span class="comment">// 调用传入的函数</span></span><br><span class="line">            result.add(num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：传递 Lambda 作为参数</span></span><br><span class="line"><span class="keyword">val</span> nums = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> evenNums = filterNumbers(nums) &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;  <span class="comment">// 过滤偶数：[2,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="十、协程（Coroutines）"><a href="#十、协程（Coroutines）" class="headerlink" title="十、协程（Coroutines）"></a>十、协程（Coroutines）</h2><p>Kotlin 用于<strong>异步编程</strong>的核心特性，解决回调地狱，让异步代码像同步代码一样直观（Android 中用于网络请求、数据库操作等耗时任务）：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>需添加依赖（<code>kotlinx-coroutines-core</code>），用 <code>launch</code> 启动协程，<code>suspend</code> 标记 suspend 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动协程（在主线程的协程作用域中）</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;  <span class="comment">// 启动一个新协程</span></span><br><span class="line">            delay(<span class="number">1000</span>)  <span class="comment">// 暂停 1 秒（非阻塞，不阻塞主线程）</span></span><br><span class="line">            println(<span class="string">&quot;协程执行完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;主线程继续执行&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2. 关键概念"></a>2. 关键概念</h3><ul>
<li><strong>协程作用域（CoroutineScope）</strong>：管理协程生命周期（如 Android 中的 <code>lifecycleScope</code>）。</li>
<li><strong>suspend 函数</strong>：只能在协程或其他 suspend 函数中调用，可包含耗时操作。</li>
<li><strong>非阻塞</strong>：协程暂停时，线程可执行其他任务，提高效率。</li>
</ul>
<h3 id="十一、与-Java-互操作"><a href="#十一、与-Java-互操作" class="headerlink" title="十一、与 Java 互操作"></a>十一、与 Java 互操作</h3><ul>
<li><strong>调用 Java 代码</strong>：直接使用，无需额外处理（如调用 <code>java.util.ArrayList</code>）。</li>
<li>Java 调用 Kotlin 代码：<ul>
<li>Kotlin 类默认是 <code>final</code>，Java 需用 <code>open</code> 修饰才能继承。</li>
<li>顶层函数（不在类中的函数）会被编译为 <code>文件名Kt</code> 类的静态方法。</li>
</ul>
</li>
</ul>
<h1 id="Android四大组件的核心概念"><a href="#Android四大组件的核心概念" class="headerlink" title="Android四大组件的核心概念"></a>Android四大组件的核心概念</h1><h2 id="一、Activity（活动）"><a href="#一、Activity（活动）" class="headerlink" title="一、Activity（活动）"></a>一、Activity（活动）</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>用户交互界面单元</strong>，每个屏幕对应一个Activity</li>
<li>通过<strong>Intent</strong>实现页面跳转（正向&#x2F;逆向均需重点监控）</li>
</ul>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul>
<li><strong>生命周期</strong>：<code>onCreate()</code> → <code>onStart()</code> → <code>onResume()</code> → <code>onPause()</code> → <code>onStop()</code> → <code>onDestroy()</code></li>
<li><strong>启动模式</strong>：standard&#x2F;singleTop&#x2F;singleTask&#x2F;singleInstance（逆向时关注任务栈管理）</li>
<li><strong>布局绑定</strong>：通过<code>setContentView()</code>关联XML布局</li>
</ul>
<h3 id="逆向关注点"><a href="#逆向关注点" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>查找<strong>Launcher Activity</strong>（应用入口）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<code>startActivityForResult()</code>跨组件通信</li>
<li>Hook <code>onActivityResult()</code>获取数据回传逻辑</li>
</ul>
<h2 id="二、Service（服务）"><a href="#二、Service（服务）" class="headerlink" title="二、Service（服务）"></a>二、Service（服务）</h2><h3 id="核心定义-1"><a href="#核心定义-1" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>后台运行组件</strong>，无界面（常驻&#x2F;耗时操作）</li>
<li>两种启动方式：<ul>
<li>**startService()**（长期运行，如音乐播放）</li>
<li>**bindService()**（IPC跨进程通信）</li>
</ul>
</li>
</ul>
<h3 id="生命周期差异"><a href="#生命周期差异" class="headerlink" title="生命周期差异"></a>生命周期差异</h3><ul>
<li><strong>启动式</strong>：<code>onCreate()</code> → <code>onStartCommand()</code> → <code>onDestroy()</code></li>
<li><strong>绑定式</strong>：<code>onCreate()</code> → <code>onBind()</code> → <code>onUnbind()</code> → <code>onDestroy()</code></li>
</ul>
<h3 id="逆向关注点-1"><a href="#逆向关注点-1" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>识别<strong>Foreground Service</strong>（通知栏常驻，需反编译检查通知配置）</li>
<li>分析<code>IntentService</code>的消息处理机制</li>
<li>检测<code>startForeground()</code>防杀保活手段</li>
<li>定位跨进程通信的<strong>AIDL接口</strong></li>
</ul>
<hr>
<h2 id="三、BroadcastReceiver（广播接收器）"><a href="#三、BroadcastReceiver（广播接收器）" class="headerlink" title="三、BroadcastReceiver（广播接收器）"></a>三、BroadcastReceiver（广播接收器）</h2><h3 id="核心定义-2"><a href="#核心定义-2" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>系统&#x2F;应用事件监听器</strong>（如网络变化、短信接收）</li>
<li>两种注册方式：<ul>
<li><strong>静态注册</strong>：AndroidManifest.xml声明（系统广播）</li>
<li><strong>动态注册</strong>：代码中<code>registerReceiver()</code>（应用内广播）</li>
</ul>
</li>
</ul>
<h3 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h3><ol>
<li>发送广播：<code>sendBroadcast(intent)</code></li>
<li>匹配接收器：通过<code>IntentFilter</code>筛选</li>
<li>执行<code>onReceive()</code>逻辑</li>
</ol>
<h3 id="逆向关注点-2"><a href="#逆向关注点-2" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>监控<strong>敏感广播</strong>（如<code>BOOT_COMPLETED</code>开机自启）</li>
<li>分析有序广播的优先级滥用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter android:priority=<span class="string">&quot;1000&quot;</span>&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Hook <code>abortBroadcast()</code>拦截广播传递链</li>
</ul>
<hr>
<h2 id="四、ContentProvider（内容提供者）"><a href="#四、ContentProvider（内容提供者）" class="headerlink" title="四、ContentProvider（内容提供者）"></a>四、ContentProvider（内容提供者）</h2><h3 id="核心定义-3"><a href="#核心定义-3" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>跨应用数据共享</strong>的标准化接口（数据库&#x2F;文件）</li>
<li>通过<strong>URI</strong>标识数据源：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content:<span class="comment">//com.example.provider/user/1</span></span><br><span class="line">↑          ↑                ↑     ↑</span><br><span class="line">协议       包名             表名  记录ID</span><br></pre></td></tr></table></figure>

<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul>
<li><code>query()</code>：查询数据</li>
<li><code>insert()</code>：插入数据</li>
<li><code>update()</code>：更新数据</li>
<li><code>delete()</code>：删除数据</li>
<li><code>getType()</code>：返回MIME类型</li>
</ul>
<h3 id="逆向关注点-3"><a href="#逆向关注点-3" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>解析<code>&lt;provider&gt;</code>声明中的<strong>权限控制</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;provider </span><br><span class="line">    android:authorities=<span class="string">&quot;com.example.provider&quot;</span></span><br><span class="line">    android:readPermission=<span class="string">&quot;READ_DATA&quot;</span></span><br><span class="line">    android:writePermission=<span class="string">&quot;WRITE_DATA&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>追踪<code>ContentResolver</code>的CRUD操作路径</li>
<li>检测<strong>URI注入漏洞</strong>（未校验外部输入）</li>
</ul>
<h2 id="五、四大组件共性特征"><a href="#五、四大组件共性特征" class="headerlink" title="五、四大组件共性特征"></a>五、四大组件共性特征</h2><h3 id="1-清单文件声明"><a href="#1-清单文件声明" class="headerlink" title="1. 清单文件声明"></a>1. 清单文件声明</h3><p>所有组件必须在<code>AndroidManifest.xml</code>注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.MainActivity&quot;</span>/&gt;</span><br><span class="line">&lt;service android:name=<span class="string">&quot;.MyService&quot;</span>/&gt;</span><br><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyReceiver&quot;</span>/&gt;</span><br><span class="line">&lt;provider android:name=<span class="string">&quot;.MyProvider&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-Intent通信机制"><a href="#2-Intent通信机制" class="headerlink" title="2. Intent通信机制"></a>2. Intent通信机制</h3><ul>
<li><strong>显式Intent</strong>：明确指定组件类名（逆向易追踪）</li>
<li><strong>隐式Intent</strong>：通过Action&#x2F;Category匹配（需反编译查看过滤条件）</li>
</ul>
<h3 id="3-逆向工程切入点"><a href="#3-逆向工程切入点" class="headerlink" title="3. 逆向工程切入点"></a>3. 逆向工程切入点</h3><ul>
<li><strong>入口分析</strong>：定位Launcher Activity和开机广播接收器</li>
<li><strong>协议破解</strong>：监控ContentProvider的数据读写格式</li>
<li><strong>Hook位置</strong>：选择组件生命周期方法注入代码（如Activity的<code>onCreate()</code>）</li>
</ul>
<h2 id="逆向实战技巧"><a href="#逆向实战技巧" class="headerlink" title="逆向实战技巧"></a>逆向实战技巧</h2><ol>
<li><p><strong>快速定位组件</strong>：</p>
<ul>
<li>使用<code>apktool</code>反编译后，在<code>AndroidManifest.xml</code>搜索组件声明</li>
<li>通过<code>jadx-gui</code>查看组件的Java&#x2F;Kotlin实现类</li>
</ul>
</li>
<li><p><strong>动态行为监控</strong>：</p>
<ul>
<li><p>使用<code>logcat</code>过滤组件生命周期日志：</p>
</li>
<li><pre><code class="java">adb logcat | grep -E &quot;ActivityManager|BroadcastRecord&quot;
</code></pre>
</li>
<li><p>Frida Hook <code>android.app.Activity</code>的<code>onCreate()</code>方法</p>
</li>
</ul>
</li>
</ol>
<p>3.<strong>安全漏洞挖掘</strong>：</p>
<ul>
<li>检测<code>exported=true</code>的暴露组件（未授权访问风险）</li>
<li>分析Intent传递的Bundle数据是否缺少校验</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓系统基础</title>
    <url>/2025/08/08/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>理论：Linux 内核、Framework 层（四大组件：Activity&#x2F;Service&#x2F;Broadcast&#x2F;ContentProvider）、APK 结构（classes.dex&#x2F;res&#x2F;AndroidManifest.xml）。</strong></p>
<p>安卓系统就像一座功能强大得“智能大楼”，而<strong>Linux内核、Framework层、APK结构</strong>就是这座大楼得“地基、基础设施、和具体房间”。现使用生活中得例子一步步拆解。</p>
<h2 id="一、Linux内核：安卓得“地基和水电管道”"><a href="#一、Linux内核：安卓得“地基和水电管道”" class="headerlink" title="一、Linux内核：安卓得“地基和水电管道”"></a>一、Linux内核：安卓得“地基和水电管道”</h2><h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>可以把安卓系统想象成一座大楼，而 <strong>Linux 内核</strong> 就是这座大楼的 “地基” 和 “水电管道系统”。它是安卓系统最底层的核心，负责连接手机的硬件（比如 CPU、内存、电池、摄像头等）和上层的软件（比如你的微信、抖音），让硬件能正常工作。</p>
<h4 id="具体作用（用生活例子说）："><a href="#具体作用（用生活例子说）：" class="headerlink" title="具体作用（用生活例子说）："></a>具体作用（用生活例子说）：</h4><ul>
<li><strong>“交通指挥”</strong>：管理手机里的 “程序任务”（比如同时开微信和抖音），确保它们不打架、不卡顿（专业叫 “进程管理”）。</li>
<li><strong>“水电分配”</strong>：给每个应用分配手机的内存、电量等资源，避免某个应用 “霸占” 太多资源导致手机卡死（专业叫 “内存管理、电源管理”）。</li>
<li><strong>“硬件翻译官”</strong>：手机的摄像头、触摸屏、麦克风等硬件都是 “哑巴”，需要内核来 “翻译” 软件的指令（比如你点屏幕 “拍照”），让硬件听懂并执行（专业叫 “硬件驱动”）。</li>
</ul>
<p>简单说：没有 Linux 内核，手机的硬件就是一堆废铁，上层的任何应用都跑不起来。</p>
<h3 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h3><p>在安卓系统中，<strong>Linux 内核</strong>是整个系统的底层核心，负责硬件与软件之间的 “桥梁” 作用，提供基础的系统资源管理和硬件抽象能力。从专业角度来说，它的核心功能和作用可以概括为以下几个方面：</p>
<h4 id="1-硬件抽象层（Hardware-Abstraction）"><a href="#1-硬件抽象层（Hardware-Abstraction）" class="headerlink" title="1. 硬件抽象层（Hardware Abstraction）"></a>1. <strong>硬件抽象层（Hardware Abstraction）</strong></h4><p>Linux 内核通过 “驱动程序（Drivers）” 对手机的硬件设备（如 CPU、内存、摄像头、触摸屏、传感器、电池、存储芯片等）进行抽象。</p>
<ul>
<li>上层的 Framework 框架和应用程序不需要直接操作硬件的物理接口（如寄存器、电路信号），而是通过内核提供的标准化接口（如系统调用、设备文件）与硬件交互。</li>
<li>例如：当应用需要调用摄像头拍照时，它不会直接发送电信号到摄像头传感器，而是通过内核的摄像头驱动程序，由驱动程序完成硬件的具体控制。</li>
</ul>
<h4 id="2-进程与线程管理"><a href="#2-进程与线程管理" class="headerlink" title="2. 进程与线程管理"></a>2. <strong>进程与线程管理</strong></h4><p>内核负责对系统中的 “进程（Process）” 和 “线程（Thread）” 进行调度和管理，确保多任务高效运行：</p>
<ul>
<li><strong>进程调度</strong>：通过调度算法（如安卓优化的 CFS 调度器）为每个进程分配 CPU 时间片，避免某个进程独占资源，保证系统流畅性（比如同时运行微信、音乐和浏览器时，内核协调它们的 CPU 使用权）。</li>
<li><strong>进程隔离</strong>：通过 “进程 ID（PID）” 和内存隔离机制，确保不同应用的进程相互独立，一个应用崩溃不会影响其他应用或系统核心。</li>
<li><strong>线程管理</strong>：支持多线程并发，允许单个应用内的多个任务（如 UI 渲染、后台数据加载）并行执行，提升应用响应速度。</li>
</ul>
<h4 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. <strong>内存管理</strong></h4><p>内核负责手机内存（RAM）的分配、回收和保护：</p>
<ul>
<li><strong>内存分配</strong>：为应用、框架和系统进程分配内存空间，通过虚拟内存技术（VM）让每个进程 “认为自己独占内存”，实际由内核统一管理物理内存。</li>
<li><strong>内存回收</strong>：当内存不足时，通过 “低内存杀手（Low Memory Killer，LMK）” 机制，按优先级回收后台进程的内存（如先杀长时间不用的后台应用，保留前台应用和系统核心进程）。</li>
<li><strong>内存保护</strong>：通过权限控制和地址空间隔离，防止进程非法访问其他进程或内核的内存区域，避免数据泄露或恶意攻击。</li>
</ul>
<h4 id="4-文件系统管理"><a href="#4-文件系统管理" class="headerlink" title="4. 文件系统管理"></a>4. <strong>文件系统管理</strong></h4><p>内核提供文件系统支持，负责数据的存储和访问：</p>
<ul>
<li>支持多种存储介质（如手机内置闪存、SD 卡）和文件系统格式（如 ext4、FAT32），统一抽象为 “文件” 接口，让上层应用可以通过 “读 &#x2F; 写文件” 的方式操作存储设备。</li>
<li>管理文件的权限（如哪些应用可以读写某个文件）、路径和 metadata（如创建时间、大小），确保数据存储的有序性和安全性。</li>
</ul>
<h4 id="5-设备与电源管理"><a href="#5-设备与电源管理" class="headerlink" title="5. 设备与电源管理"></a>5. <strong>设备与电源管理</strong></h4><p>针对移动设备特性，安卓对 Linux 内核进行了定制，强化了设备和电源管理能力：</p>
<ul>
<li><strong>电源管理</strong>：通过 “休眠 &#x2F; 唤醒” 机制（如 CPU 降频、屏幕休眠）减少待机功耗；支持 “动态电压频率调节（DVFS）”，根据应用负载自动调整 CPU 频率（如玩游戏时提频，待机时降频），平衡性能和耗电。</li>
<li><strong>设备状态监控</strong>：实时监控硬件状态（如电池电量、温度、网络连接），并向上层反馈（如通过广播通知低电量）。</li>
</ul>
<h4 id="6-网络与安全机制"><a href="#6-网络与安全机制" class="headerlink" title="6. 网络与安全机制"></a>6. <strong>网络与安全机制</strong></h4><ul>
<li><strong>网络管理</strong>：内核集成网络协议栈（如 TCP&#x2F;IP、WiFi、蓝牙协议），负责数据的封装、传输和路由，让应用可以通过网络接口（如 Socket）实现联网功能（如上网、发消息）。</li>
<li><strong>安全基础</strong>：基于 Linux 的 “用户 - 组 - 权限” 模型（如文件权限 rwx、进程 UID&#x2F;GID），为系统提供基础安全隔离；后续安卓的 SELinux（安全增强型 Linux）也是基于内核实现的强制访问控制。</li>
</ul>
<h2 id="二、Framework-层：安卓的-“基础设施和规则手册”"><a href="#二、Framework-层：安卓的-“基础设施和规则手册”" class="headerlink" title="二、Framework 层：安卓的 “基础设施和规则手册”"></a>二、Framework 层：安卓的 “基础设施和规则手册”</h2><h3 id="易理解-1"><a href="#易理解-1" class="headerlink" title="易理解"></a>易理解</h3><p>在 Linux 内核之上，有一层叫 <strong>Framework（框架）层</strong>，它相当于大楼的 “基础设施管理系统” 和 “规则手册”。它封装了很多现成的工具和功能，给开发者提供 “现成的轮子”，让开发者不用从零开始写代码，就能快速开发出应用。</p>
<p>其中最核心的就是 <strong>四大组件</strong>，它们是安卓应用的 “基本功能模块”，就像大楼里的 “电梯、水管、广播系统、储物间”，各司其职。</p>
<h4 id="1-Activity：手机上的-“屏幕界面”"><a href="#1-Activity：手机上的-“屏幕界面”" class="headerlink" title="1. Activity：手机上的 “屏幕界面”"></a>1. Activity：手机上的 “屏幕界面”</h4><p>Activity 是你能直接看到的 “界面”，比如微信的聊天界面、抖音的视频播放界面、手机的设置界面，每个界面都是一个 Activity。</p>
<ul>
<li><strong>特点</strong>：一个应用可以有多个 Activity（比如微信有 “聊天列表页”“聊天详情页”“朋友圈页”），它们之间可以跳转（比如点微信好友头像，从列表页跳到详情页）。</li>
<li><strong>生活类比</strong>：就像大楼里的 “一个个房间”，每个房间有自己的功能（卧室睡觉、客厅看电视），你可以在房间之间走动（跳转）。</li>
</ul>
<h4 id="2-Service：后台默默工作的-“隐形员工”"><a href="#2-Service：后台默默工作的-“隐形员工”" class="headerlink" title="2. Service：后台默默工作的 “隐形员工”"></a>2. Service：后台默默工作的 “隐形员工”</h4><p>Service 是在后台 “偷偷干活” 的组件，你看不到它，但它一直在运行。</p>
<ul>
<li><p>例子</p>
<p>  ：</p>
<ul>
<li>你听音乐时，按 Home 键退出音乐 APP 界面（Activity 关闭了），但音乐还在播放，这就是 Service 在后台继续工作；</li>
<li>手机下载文件时，你切到其他 APP，下载不会停，也是 Service 在后台运行。</li>
</ul>
</li>
<li><p><strong>生活类比</strong>：就像大楼里的 “空调系统”，你看不到它的机器，但它一直在后台制冷 &#x2F; 制热，即使你在不同房间走动，它也不停。</p>
</li>
</ul>
<h4 id="3-BroadcastReceiver：手机里的-“广播通知员”"><a href="#3-BroadcastReceiver：手机里的-“广播通知员”" class="headerlink" title="3. BroadcastReceiver：手机里的 “广播通知员”"></a>3. BroadcastReceiver：手机里的 “广播通知员”</h4><p>BroadcastReceiver 是 “接收和传递消息” 的组件，就像大楼里的 “广播喇叭”，任何应用或系统都可以发 “广播”，它负责接收并处理消息。</p>
<ul>
<li><p>例子</p>
<p>  ：</p>
<ul>
<li>手机没电时，系统发一条 “低电量广播”，你的 APP 可以收到后提醒你 “快充电”；</li>
<li>收到短信时，系统发一条 “新短信广播”，短信 APP 收到后显示通知。</li>
</ul>
</li>
<li><p><strong>生活类比</strong>：就像小区的 “广播通知”，物业（系统）或住户（应用）发通知，大家（对应的 Receiver）听到后做反应（比如收快递、做核酸）。</p>
</li>
</ul>
<h4 id="4-ContentProvider：应用间的-“数据共享桥梁”"><a href="#4-ContentProvider：应用间的-“数据共享桥梁”" class="headerlink" title="4. ContentProvider：应用间的 “数据共享桥梁”"></a>4. ContentProvider：应用间的 “数据共享桥梁”</h4><p>ContentProvider 是让不同应用之间 “安全共享数据” 的组件。比如你的通讯录应用里的联系人，其他应用（比如微信添加好友时）需要读取，就通过 ContentProvider 实现。</p>
<ul>
<li><strong>特点</strong>：它像一个 “数据管家”，只允许被授权的应用访问数据，避免数据泄露（比如你可以设置微信是否能读取通讯录）。</li>
<li><strong>生活类比</strong>：就像小区的 “快递柜”，快递员（数据产生的应用，比如通讯录）把快递（数据）放进柜子，你授权的人（其他应用，比如微信）凭验证码（权限）才能取。</li>
</ul>
<h3 id="专业知识-1"><a href="#专业知识-1" class="headerlink" title="专业知识"></a>专业知识</h3><h4 id="1-Activity（活动）"><a href="#1-Activity（活动）" class="headerlink" title="1.Activity（活动）"></a>1.Activity（活动）</h4><h5 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>用户交互的基础界面单元</strong>，应用的每个可视化屏幕通常对应一个 Activity</li>
<li>组件间跳转的核心载体，通过<strong>Intent</strong>实现页面切换（正向开发与逆向分析均需重点关注的交互节点）</li>
</ul>
<h5 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h5><ul>
<li><p><strong>生命周期</strong>：完整生命周期为 <code>onCreate()</code>（初始化）→ <code>onStart()</code>（可见）→ <code>onResume()</code>（可交互）→ <code>onPause()</code>（部分可见）→ <code>onStop()</code>（不可见）→ <code>onDestroy()</code>（销毁），系统通过生命周期方法管理组件状态</p>
</li>
<li><p>启动模式</p>
<p>  ：</p>
<ul>
<li><code>standard</code>（默认，每次启动新建实例）</li>
<li><code>singleTop</code>（栈顶复用，避免重复创建）</li>
<li><code>singleTask</code>（栈内唯一，清除其上方实例）</li>
<li><code>singleInstance</code>（独立任务栈，全局唯一）<br>  （逆向时需关注启动模式对任务栈的管理逻辑，影响页面跳转流程）</li>
</ul>
</li>
<li><p><strong>布局绑定</strong>：通过 <code>setContentView()</code> 关联 XML 布局文件，实现界面渲染</p>
</li>
</ul>
<h5 id="逆向关注点"><a href="#逆向关注点" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p>定位应用入口：在<code>AndroidManifest.xml</code>中查找包含以下过滤器的 Activity，即为 Launcher Activity（应用启动第一个页面）：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跨组件数据传递</strong>：分析 <code>startActivityForResult()</code> 与 <code>onActivityResult()</code> 逻辑，获取页面间数据回传细节（如登录凭证、选择结果）</p>
</li>
<li><p><strong>Hook 关键方法</strong>：通过 Hook <code>onCreate()</code> 查看初始化逻辑（如密钥加载、配置读取），Hook <code>onActivityResult()</code> 追踪敏感数据流向</p>
</li>
</ul>
<h4 id="2-Service（服务）"><a href="#2-Service（服务）" class="headerlink" title="2.Service（服务）"></a>2.Service（服务）</h4><h5 id="核心定义-1"><a href="#核心定义-1" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>无界面的后台运行组件</strong>，用于执行长期耗时任务（如下载、音乐播放、数据同步），独立于界面生命周期</li>
<li>两种启动方式：<ul>
<li><code>startService()</code>：启动后独立运行，需主动调用 <code>stopService()</code>：停止（如后台下载）</li>
<li><code>bindService()</code>：与调用组件（如 Activity）绑定，通过 Binder&#x2F;aidl 实现 IPC（跨进程通信），组件销毁时服务解绑</li>
</ul>
</li>
</ul>
<h5 id="生命周期差异"><a href="#生命周期差异" class="headerlink" title="生命周期差异"></a>生命周期差异</h5><ul>
<li><strong>启动式服务</strong>：<code>onCreate()</code>（初始化）→ <code>onStartCommand()</code>（接收启动指令）→ <code>onDestroy()</code>（销毁释放资源）</li>
<li><strong>绑定式服务</strong>：<code>onCreate()</code>（初始化）→ <code>onBind()</code>（返回 Binder 对象）→ <code>onUnbind()</code>（解绑回调）→ <code>onDestroy()</code>（销毁）</li>
</ul>
<h5 id="逆向关注点-1"><a href="#逆向关注点-1" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><strong>前台服务识别</strong>：反编译 <code>AndroidManifest.xml</code> 或代码，查找 <code>startForeground()</code> 调用（前台服务需显示通知，优先级高，常用于保活），分析通知配置与保活逻辑</li>
<li><strong>IntentService 机制</strong>：定位继承 <code>IntentService</code> 的服务，其内部通过 HandlerThread 串行处理任务，需分析 <code>onHandleIntent()</code> 中的后台逻辑（如数据加密、API 请求）</li>
<li><strong>跨进程通信接口</strong>：查找 AIDL 文件（<code>.aidl</code>），解析 <code>onBind()</code> 返回的 Binder 接口，获取进程间交互的敏感数据（如用户信息、权限验证）</li>
</ul>
<h4 id="3-BroadcastReceiver（广播接收器）"><a href="#3-BroadcastReceiver（广播接收器）" class="headerlink" title="3.BroadcastReceiver（广播接收器）"></a>3.BroadcastReceiver（广播接收器）</h4><h5 id="核心定义-2"><a href="#核心定义-2" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>系统 &#x2F; 应用事件的监听组件</strong>，用于接收并响应全局事件（如网络状态变化、短信接收、开机完成）</li>
<li>两种注册方式：<ul>
<li><strong>静态注册</strong>：在 <code>AndroidManifest.xml</code> 中声明，应用未启动时可接收广播（如监听开机广播）</li>
<li><strong>动态注册</strong>：在代码中通过 <code>registerReceiver()</code> 注册，随宿主组件（如 Activity）生命周期生效，需手动调用 <code>unregisterReceiver()</code> 注销</li>
</ul>
</li>
</ul>
<h5 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h5><ol>
<li>发送广播：通过 <code>sendBroadcast(Intent)</code> 或 <code>sendOrderedBroadcast(Intent)</code> 发送事件</li>
<li>匹配接收器：系统根据 <code>IntentFilter</code> 中的 <code>action</code>、<code>category</code> 筛选目标接收器</li>
<li>执行逻辑：匹配成功后触发接收器的 <code>onReceive(Context, Intent)</code> 方法</li>
</ol>
<h5 id="逆向关注点-2"><a href="#逆向关注点-2" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p><strong>敏感广播监控</strong>：重点追踪系统级广播（如 <code>android.intent.action.BOOT_COMPLETED</code> 开机自启、<code>android.provider.Telephony.SMS_RECEIVED</code> 短信接收），分析其 <code>onReceive()</code> 中的逻辑（如自启动触发、短信内容窃取）</p>
</li>
<li><p><strong>有序广播优先级滥用</strong>：检查静态注册<code>&lt;intent-filter&gt;</code></p>
<p>  优先级<code>（android:priority）</code>，高优先级接收器可能通过 <code>abortBroadcast()</code>拦截广播（如恶意应用拦截验证码短信）：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态注册追踪</strong>：在代码中定位 <code>registerReceiver()</code> 调用，分析动态注册的广播类型与响应逻辑（如应用内数据更新通知）</p>
</li>
</ul>
<h4 id="4-ContentProvider（内容提供者）"><a href="#4-ContentProvider（内容提供者）" class="headerlink" title="4.ContentProvider（内容提供者）"></a>4.ContentProvider（内容提供者）</h4><h5 id="核心定义-3"><a href="#核心定义-3" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><p><strong>跨应用数据共享的标准化接口</strong>，用于安全暴露应用内部数据（如数据库、文件）给其他应用访问</p>
</li>
<li><p>通过URI唯一标识数据源，格式为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content:<span class="comment">//com.example.provider/user/1</span></span><br><span class="line">↑          ↑                ↑     ↑</span><br><span class="line">协议       授权名（包名）    数据路径  记录ID</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><ul>
<li><code>query(Uri, String[], String, String[], String)</code>：查询数据（类似 SQL 的 SELECT）</li>
<li><code>insert(Uri, ContentValues)</code>：插入数据（类似 SQL 的 INSERT）</li>
<li><code>update(Uri, ContentValues, String, String[])</code>：更新数据（类似 SQL 的 UPDATE）</li>
<li><code>delete(Uri, String, String[])</code>：删除数据（类似 SQL 的 DELETE）</li>
<li><code>getType(Uri)</code>：返回数据的 MIME 类型（如 <code>vnd.android.cursor.item/user</code>）</li>
</ul>
<h5 id="逆向关注点-3"><a href="#逆向关注点-3" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p>权限控制分析：在 <code>AndroidManifest.xml</code> 中查看 <code>&lt;provider&gt;</code></p>
<p>  声明的读写权限，判断是否存在权限配置宽松（如未声明权限）导致的敏感数据泄露：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.provider&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:readPermission</span>=<span class="string">&quot;com.example.READ_DATA&quot;</span>  // <span class="attr">读权限</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:writePermission</span>=<span class="string">&quot;com.example.WRITE_DATA&quot;</span> // <span class="attr">写权限</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  // 是否允许外部应用访问</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据操作追踪</strong>：通过 Hook <code>ContentResolver</code> 的 <code>query()</code>&#x2F;<code>insert()</code> 等方法，获取其他应用访问本应用数据的路径与内容（如通讯录、相册的访问记录）</p>
</li>
<li><p><strong>URI 注入漏洞检测</strong>：分析 <code>query()</code> 等方法中对输入 URI 的校验逻辑，若未过滤特殊字符（如 <code>../</code>），可能存在目录遍历或 SQL 注入风险</p>
</li>
</ul>
<h2 id="三、APK-结构：安卓应用的-“安装包三件套”"><a href="#三、APK-结构：安卓应用的-“安装包三件套”" class="headerlink" title="三、APK 结构：安卓应用的 “安装包三件套”"></a>三、APK 结构：安卓应用的 “安装包三件套”</h2><h3 id="易理解-2"><a href="#易理解-2" class="headerlink" title="易理解"></a>易理解</h3><p>你在应用商店下载的 APP，本质上是一个后缀为 <code>.apk</code> 的文件（比如 “微信.apk”），它是安卓应用的 “安装包”。这个安装包里装着应用运行的所有 “零件”，核心有三个：</p>
<h4 id="1-classes-dex：应用的-“大脑指令集”"><a href="#1-classes-dex：应用的-“大脑指令集”" class="headerlink" title="1. classes.dex：应用的 “大脑指令集”"></a>1. classes.dex：应用的 “大脑指令集”</h4><p>你写的 Java&#x2F;Kotlin 代码，经过编译后会变成一个叫 <code>classes.dex</code> 的文件，它相当于应用的 “大脑”，里面是计算机能看懂的 “指令”（比如 “点击按钮后跳转到下一页”“计算加法结果”）。</p>
<ul>
<li>生活类比：就像菜谱里的 “步骤说明”，厨师（手机 CPU）按照步骤做菜（运行应用）。</li>
</ul>
<h4 id="2-res：应用的-“素材仓库”"><a href="#2-res：应用的-“素材仓库”" class="headerlink" title="2. res：应用的 “素材仓库”"></a>2. res：应用的 “素材仓库”</h4><p><code>res</code> 是 “资源文件夹”，里面存着应用的所有 “素材”：</p>
<ul>
<li>图片（比如 APP 图标、按钮背景图）；</li>
<li>文字（比如按钮上的 “登录”“注册” 文字，支持多语言翻译）；</li>
<li>布局文件（比如界面里按钮、文字的位置排列，像装修设计图）。</li>
<li>生活类比：就像做菜的 “食材和餐具”，菜谱（classes.dex）需要用这些素材才能做出菜（显示界面）。</li>
</ul>
<h4 id="3-AndroidManifest-xml：应用的-“身份证和说明书”"><a href="#3-AndroidManifest-xml：应用的-“身份证和说明书”" class="headerlink" title="3. AndroidManifest.xml：应用的 “身份证和说明书”"></a>3. AndroidManifest.xml：应用的 “身份证和说明书”</h4><p>这个文件是应用的 “配置清单”，相当于给系统的 “说明书”，告诉系统：</p>
<ul>
<li>这个应用叫什么名字、图标是什么；</li>
<li>它有哪些组件（Activity、Service 等），比如 “登录界面是哪个 Activity”；</li>
<li>它需要什么权限（比如 “允许访问摄像头”“允许读取位置”）。</li>
<li>生活类比：就像商品的 “包装说明”，告诉买家（系统）这是什么商品、怎么用、需要什么条件（比如 “需冷藏” 对应 “需定位权限”）。</li>
</ul>
<h3 id="专业知识-2"><a href="#专业知识-2" class="headerlink" title="专业知识"></a>专业知识</h3><p>在安卓应用的APK结构中，所谓的“安装包三件套”指的是构成APK核心功能的三个关键文件：<strong>AndroidManifest.xml</strong>、<strong>classes.dex</strong>（或多个dex文件）、<strong>resources.arsc</strong>。这三个文件是APK的“骨架”，决定了应用的基本功能、运行逻辑和资源管理方式，也是安卓逆向分析中最核心的分析对象。</p>
<h4 id="1-AndroidManifest-xml：应用的“身份证与说明书”"><a href="#1-AndroidManifest-xml：应用的“身份证与说明书”" class="headerlink" title="1.AndroidManifest.xml：应用的“身份证与说明书”"></a>1.AndroidManifest.xml：应用的“身份证与说明书”</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>它是APK的全局配置文件，记录了应用的“身份信息”和“功能清单”，系统安装和运行应用时首先读取该文件。</p>
<h5 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h5><ul>
<li><p><strong>应用身份</strong>：</p>
<ul>
<li>包名（package）：应用的唯一标识（如<code>com.example.myapp</code>），是系统区分不同应用的依据。</li>
<li>版本信息：<code>versionCode</code>（内部版本号，整数，用于升级判断）和<code>versionName</code>（用户可见版本号，如<code>1.0.0</code>）。</li>
</ul>
</li>
<li><p><strong>组件声明</strong>：</p>
<p>  安卓应用的四大组件（Acivity、Service、BroadcastReceiver、ContentProvider）必须在此声明才能被系统识别和调用。</p>
<ul>
<li>例如：声明启动页Activity（<code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;</code>）及启动模式、意图过滤器（Intent Filter）等。</li>
</ul>
</li>
<li><p><strong>权限声明</strong>：</p>
<p>  应用需要的系统权限（如联网、读写文件、获取位置等），通过<code>&lt;uses-permission&gt;</code>标签声明（如<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code>）。</p>
</li>
<li><p><strong>其他配置</strong>：</p>
<p>  如最低支持的安卓版本（<code>minSdVersion</code>）、目标版本（<code>targetSdkVersion</code>）、应用图标、主题等。</p>
</li>
</ul>
<h5 id="格式与逆向注意"><a href="#格式与逆向注意" class="headerlink" title="格式与逆向注意"></a><strong>格式与逆向注意</strong></h5><ul>
<li>原始APK中<code>androidManifest.xml</code>是<strong>二进制XML格式</strong>（为了压缩和加密），无法直接阅读。</li>
<li>逆向时需要用APKtool等工具反编译为可读的文本XML（如<code>apktool d app.apk</code>），通过分析该文件可快速了解应用的功能范围、权限需求和组件结构。</li>
</ul>
<h4 id="2-classes-dex：应用的-“逻辑大脑”"><a href="#2-classes-dex：应用的-“逻辑大脑”" class="headerlink" title="2.classes.dex：应用的 “逻辑大脑”"></a>2.classes.dex：应用的 “逻辑大脑”</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>它是安卓应用的<strong>可执行字节码文件</strong>，包含了应用的所有业务逻辑（ 如按钮点击事件、网络请求、数据处理等），是应用的核心 。</p>
<h5 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h5><ul>
<li><p><strong>格式特殊性</strong></p>
<p>  不同于Java的<code>class</code>文件，<code>classes.dex</code>是基于<strong>Dalvik&#x2F;ART虚拟机</strong>的字节码格式（Dalvik Executable）。安卓将所有Java代码编译后的<code>class</code>文件合并、优化为一个或多个<code>dex</code>文件（当代码量过大是会拆分出<code>classes2.dex</code>、<code>classes3.dex</code>等），一提高运行效率。</p>
</li>
<li><p><strong>逆向关键</strong></p>
<ul>
<li><code>dex</code>文件是逆向分析的核心目标，通过工具（如<code>dex2jar</code>）可将其转换为Java的<code>jar</code>文件，再用<code>JD-GUI</code>或<code>jadx</code>等工具查看近似的Java源代码（需注意：混淆后的diamagnetic会被重命名为a、b、c等无意义类名，增加分析难度）。</li>
<li>动态调试时（如用<code>IDA Pro</code>或<code>Frida</code>），<code>dex</code>文件的字节码时断点和hook的主要操作对象。</li>
</ul>
</li>
</ul>
<h4 id="3-resources-arsc：资源的“索引字典”"><a href="#3-resources-arsc：资源的“索引字典”" class="headerlink" title="3.resources.arsc：资源的“索引字典”"></a>3.resources.arsc：资源的“索引字典”</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>它是应用的<strong>资源索引表</strong>，用于管理应用中的所有静态资源（字符串、图片、布局文件、颜色、尺寸等），实现资源的高效查找和适配。</p>
<h5 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h5><ul>
<li><p><strong>资源分类与索引</strong>：</p>
<ul>
<li>应用的资源（如<code>res/values/strings.xml</code>中的字符串、<code>res/drawable/</code>中的图片）会被编译为二进制格式，而<code>resources.arsc</code>则记录了这些资源的 ID、类型、路径及对应的语言、分辨率等适配信息。</li>
</ul>
</li>
<li><p><strong>资源适配支持</strong>：</p>
<ul>
<li>安卓系统会根据设备的语言（如中文 &#x2F; 英文）、屏幕分辨率、系统版本等，通过<code>resources.arsc</code>索引到最合适的资源（例如：中文设备优先加载<code>values-zh</code>目录下的字符串）。</li>
</ul>
</li>
</ul>
<h4 id="逆向中的应用"><a href="#逆向中的应用" class="headerlink" title="逆向中的应用"></a>逆向中的应用</h4><ul>
<li>反编译后，<code>resources.arsc</code>会被转换为可读的资源索引信息，结合<code>res</code>目录下的具体资源文件（如图片、布局 XML），可分析应用的 UI 设计、文本内容（如关键提示信息、接口地址等）。</li>
<li>修改<code>resources.arsc</code>和对应资源文件（如替换图标、修改文本）是 “换皮” 类逆向的常用操作。</li>
</ul>
<h4 id="三者的协同关系"><a href="#三者的协同关系" class="headerlink" title="三者的协同关系"></a>三者的协同关系</h4><p>APK 的运行依赖这三个文件的配合：</p>
<ol>
<li>系统通过<code>AndroidManifest.xml</code>识别应用身份、权限和组件，决定如何启动应用；</li>
<li>启动后，通过<code>resources.arsc</code>加载对应的 UI 资源和文本，展示界面；</li>
<li>用户操作（如点击按钮）触发<code>classes.dex</code>中的逻辑代码，完成具体功能（如跳转页面、提交数据）。</li>
</ol>
<h2 id="总结：安卓系统的-“三层关系”"><a href="#总结：安卓系统的-“三层关系”" class="headerlink" title="总结：安卓系统的 “三层关系”"></a>总结：安卓系统的 “三层关系”</h2><p>从底层到上层，就像 “地基→基础设施→房间”：</p>
<ol>
<li><strong>Linux 内核</strong>（地基）：支撑硬件运行，管资源分配；</li>
<li><strong>Framework 层</strong>（基础设施）：提供四大组件等工具，让开发者能快速做应用；</li>
<li><strong>APK</strong>（具体房间）：打包了代码、素材和配置，安装后就是你用的 APP。</li>
</ol>
<p>这样一来，安卓系统就能稳定、高效地运行各种应用啦～</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>四大件</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向工程核心流程</title>
    <url>/2025/08/09/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>安卓逆向工程是分析和修改已编译安卓应用程序（APK）的过程，其核心流程可分为以下关键步骤，结合静态分析、动态调试和工具链协作完成：</p>
<h3 id="一、环境与工具准备"><a href="#一、环境与工具准备" class="headerlink" title="一、环境与工具准备"></a>一、环境与工具准备</h3><ol>
<li><strong>基础工具链</strong><ul>
<li><strong>APKTool</strong>（最新版本 2.6.0）：用于解包 &#x2F; 重新打包 APK，提取资源和 AndroidManifest.xml。</li>
<li><strong>JADX</strong>：将 DEX 字节码反编译为可读 Java 代码，支持图形化界面快速定位逻辑。</li>
<li><strong>dex2jar + JD-GUI</strong>：将 DEX 转为 JAR 文件，配合 JD-GUI 查看反编译结果。</li>
<li><strong>IDA Pro&#x2F;Ghidra</strong>：静态分析 Native 代码（SO 文件），支持 ARM&#x2F;x86 架构反汇编与伪代码生成。</li>
</ul>
</li>
<li><strong>动态调试工具</strong><ul>
<li><strong>Frida</strong>：通过注入脚本 Hook Java&#x2F;Native 函数，实时修改运行时行为。</li>
<li><strong>Xposed</strong>：基于框架的全局 Hook 方案，适合系统级行为拦截。</li>
<li><strong>ZjDroid</strong>：针对加固应用的脱壳工具，支持内存 Dump 和 BakSmali 反编译。</li>
</ul>
</li>
<li><strong>签名与测试</strong><ul>
<li><strong>apksigner</strong>：处理 Android 7.0 + 的 V2&#x2F;V3 签名，确保重打包 APK 可安装。</li>
<li><strong>adb</strong>：与设备 &#x2F; 模拟器通信，执行安装、日志抓取等操作。</li>
</ul>
</li>
</ol>
<h3 id="二、逆向核心流程"><a href="#二、逆向核心流程" class="headerlink" title="二、逆向核心流程"></a>二、逆向核心流程</h3><h4 id="（一）APK-获取与初步分析"><a href="#（一）APK-获取与初步分析" class="headerlink" title="（一）APK 获取与初步分析"></a>（一）APK 获取与初步分析</h4><ol>
<li><strong>获取 APK</strong><ul>
<li>从应用商店下载、通过<code>adb pull</code>提取已安装应用，或通过网络爬虫获取目标 APK。</li>
<li>检查 APK 文件完整性：<code>apksigner verify --verbose app.apk</code>。</li>
</ul>
</li>
<li><strong>基础信息解析</strong><ul>
<li>使用<code>apktool d app.apk</code>解包，查看 AndroidManifest.xml 获取包名、权限、Activity 入口等。</li>
<li>分析资源文件（res 目录）和 Smali 代码结构，初步判断是否混淆或加固。</li>
</ul>
</li>
</ol>
<h4 id="（二）反编译与静态分析"><a href="#（二）反编译与静态分析" class="headerlink" title="（二）反编译与静态分析"></a>（二）反编译与静态分析</h4><ol>
<li><strong>代码反编译</strong><ul>
<li><strong>Java 层</strong>：直接用 JADX 打开 APK，导出 Java 代码进行逻辑梳理。</li>
<li><strong>Smali 层</strong>：通过<code>apktool</code>生成的 smali 文件夹，手工修改字节码（如去除广告、破解 VIP 功能）。</li>
<li><strong>Native 层</strong>：用 IDA Pro 打开 SO 文件，分析 JNI 接口和 ARM 汇编逻辑，定位关键算法（如加密、支付验证）。</li>
</ul>
</li>
<li><strong>代码审计</strong><ul>
<li>搜索敏感关键词（如<code>verifyPurchase</code>、<code>encrypt</code>），定位核心功能模块。</li>
<li>分析类继承关系和方法调用链，绘制 UML 图辅助理解架构。</li>
</ul>
</li>
</ol>
<h4 id="（三）动态调试与脱壳"><a href="#（三）动态调试与脱壳" class="headerlink" title="（三）动态调试与脱壳"></a>（三）动态调试与脱壳</h4><ol>
<li><strong>动态行为监控</strong><ul>
<li>使用<code>adb logcat</code>抓取运行时日志，定位关键日志输出点。</li>
<li>配合 Frida 脚本 Hook 目标函数，打印参数 &#x2F; 返回值，验证静态分析结果。</li>
</ul>
</li>
<li><strong>脱壳处理（针对加固应用）</strong><ul>
<li>动态脱壳：<ul>
<li>启动应用后，通过 Frida 注入脚本拦截<code>ClassLoader</code>的<code>loadClass</code>方法，Dump 内存中的原始 DEX。</li>
<li>示例命令：<code>frida -U -l dump_dex.js -f com.example.app --no-pause</code>。</li>
</ul>
</li>
<li><strong>工具辅助</strong>：ZjDroid 可通过广播命令 Dump 内存中的 DEX 并反编译，支持主流加固方案。</li>
</ul>
</li>
<li><strong>对抗反调试技术</strong><ul>
<li>绕过 Root 检测：修改<code>Build.VERSION.SDK_INT</code>或使用 Magisk 隐藏 Root 标识。</li>
<li>处理模拟器检测：通过 Frida Hook<code>Build.FINGERPRINT</code>返回真实设备信息。</li>
</ul>
</li>
</ol>
<h4 id="（四）代码修改与重打包"><a href="#（四）代码修改与重打包" class="headerlink" title="（四）代码修改与重打包"></a>（四）代码修改与重打包</h4><ol>
<li><strong>功能定制</strong><ul>
<li><strong>Java 层修改</strong>：直接编辑 JADX 导出的代码，重新编译为 DEX（需使用 dx 工具或 Android Studio）。</li>
<li><strong>Smali 层修改</strong>：使用文本编辑器调整 Smali 指令，例如将条件跳转<code>if-eq</code>改为<code>if-ne</code>。</li>
<li><strong>Native 层修改</strong>：在 IDA 中定位关键汇编指令，修改机器码（如将<code>BEQ</code>改为<code>BNE</code>），重新编译 SO 文件。</li>
</ul>
</li>
<li><strong>资源替换</strong><ul>
<li>替换 res 目录中的图片、字符串文件，实现界面汉化或 UI 调整。</li>
<li>注意：部分资源（如 9.png）需用<code>draw9patch</code>工具重新处理。</li>
</ul>
</li>
<li><strong>重新打包与签名</strong><ul>
<li>使用<code>apktool b modified_folder -o modified.apk</code>生成未签名 APK。</li>
<li>签名流程：<ol>
<li>生成密钥：<code>keytool -genkey -v -keystore mykey.jks -alias myalias -keyalg RSA -keysize 2048 -validity 10000</code>。</li>
<li>签名 APK：<code>apksigner sign --ks mykey.jks --out signed.apk modified.apk</code>。</li>
<li>优化对齐：<code>zipalign -v 4 signed.apk aligned.apk</code>。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="（五）测试与验证"><a href="#（五）测试与验证" class="headerlink" title="（五）测试与验证"></a>（五）测试与验证</h4><ol>
<li><strong>安装与运行</strong><ul>
<li>通过<code>adb install -r aligned.apk</code>安装修改后的 APK，启动应用验证功能是否正常。</li>
<li>使用<code>adb shell am start -n com.example.app/.MainActivity</code>直接启动指定 Activity。</li>
</ul>
</li>
<li><strong>稳定性测试</strong><ul>
<li>检查是否存在崩溃（通过<code>adb logcat</code>查看 AndroidRuntime 异常）。</li>
<li>验证关键功能（如支付、网络请求）是否按预期修改。</li>
</ul>
</li>
</ol>
<h3 id="三、高级技巧与注意事项"><a href="#三、高级技巧与注意事项" class="headerlink" title="三、高级技巧与注意事项"></a>三、高级技巧与注意事项</h3><ol>
<li><strong>反混淆与去加密</strong><ul>
<li><strong>字符串解密</strong>：使用<code>dex-oracle</code>工具动态执行加密字符串的解密函数，提取明文。</li>
<li><strong>控制流平坦化</strong>：通过 IDA 脚本或 Ghidra 插件还原混淆后的代码结构。</li>
</ul>
</li>
<li><strong>自动化脚本开发</strong><ul>
<li>编写 Frida 脚本批量 Hook 指定类的所有方法，生成调用关系图谱。</li>
<li>使用 Auto.js 实现自动化测试，模拟用户操作触发逆向目标逻辑。</li>
</ul>
</li>
<li><strong>法律与合规</strong><ul>
<li>确保逆向行为符合《计算机软件保护条例》和应用的最终用户许可协议（EULA），避免用于商业盗版或恶意攻击。</li>
<li>仅对自有应用或明确授权的应用进行逆向分析。</li>
</ul>
</li>
</ol>
<h3 id="四、典型场景解决方案"><a href="#四、典型场景解决方案" class="headerlink" title="四、典型场景解决方案"></a>四、典型场景解决方案</h3><ol>
<li><strong>破解 VIP 功能</strong><ul>
<li>定位支付验证逻辑，修改返回值为<code>true</code>或绕过网络校验。</li>
<li>若涉及 SO 文件，通过 IDA 修改 JNI 函数的返回值（如将<code>0</code>改为<code>1</code>）。</li>
</ul>
</li>
<li><strong>去除广告</strong><ul>
<li>Hook 广告 SDK 的初始化方法（如<code>AdManager.getInstance().init()</code>），拦截广告加载流程。</li>
<li>直接删除 Smali 代码中的广告相关类和方法。</li>
</ul>
</li>
<li><strong>脱壳 360 加固应用</strong><ul>
<li>使用 ZjDroid 的<code>backsmali</code>命令 Dump 内存中的 DEX，结合 Xposed Hook<code>ActivityThread</code>的<code>attach</code>方法绕过检测。</li>
</ul>
</li>
</ol>
<h3 id="五、工具链整合与效率提升"><a href="#五、工具链整合与效率提升" class="headerlink" title="五、工具链整合与效率提升"></a>五、工具链整合与效率提升</h3><ol>
<li><p><strong>流程自动化</strong></p>
<ul>
<li><p>编写 Shell 脚本整合<code>apktool</code>、<code>jarsigner</code>等工具，实现一键解包 - 修改 - 签名。</p>
</li>
<li><p>示例脚本片段：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">apktool d app.apk -o workdir</span><br><span class="line"><span class="comment"># 修改代码...</span></span><br><span class="line">apktool b workdir -o modified.apk</span><br><span class="line">apksigner sign --ks mykey.jks modified.apk</span><br><span class="line">adb install modified.apk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>团队协作</strong></p>
<ul>
<li>使用 Git 管理逆向工程中的代码修改和脚本，配合 Jira 追踪漏洞或功能点。</li>
<li>共享 IDA&#x2F;Ghidra 的签名数据库（.til 文件），加速 SO 文件分析。</li>
</ul>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>安卓逆向工程是技术与法律的双重挑战，需综合运用静态分析、动态调试、工具链协作等手段。核心流程可概括为：<strong>获取 APK → 解包反编译 → 分析与修改 → 重打包签名 → 测试验证</strong>，其中脱壳、反混淆、动态调试是应对复杂应用的关键。建议从简单应用入手，逐步掌握 Smali 语法、ARM 汇编和脚本开发，同时严格遵守法律边界，确保逆向行为的合法性。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向这档子事</title>
    <url>/2025/03/12/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="一、初识APK"><a href="#一、初识APK" class="headerlink" title="一、初识APK"></a>一、初识APK</h1><h2 id="1-双开及其原理"><a href="#1-双开及其原理" class="headerlink" title="1..双开及其原理"></a>1..双开及其原理</h2><p><strong>双开：简单来说，就是手机同时运行两个或多个相同的应用，例如同时运行两个微信</strong></p>
<table>
<thead>
<tr>
<th align="left">原理</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">修改包名</td>
<td align="left">让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td>
</tr>
<tr>
<td align="left">修改Framework</td>
<td align="left">对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td>
</tr>
<tr>
<td align="left">通过虚拟化技术实现</td>
<td align="left">虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td>
</tr>
<tr>
<td align="left">以插件机制运行</td>
<td align="left">利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td>
</tr>
</tbody></table>
<h3 id="2-1-修改包名"><a href="#2-1-修改包名" class="headerlink" title="2.1 修改包名"></a>2.1 修改包名</h3><h4 id="2-1-1-使用工具"><a href="#2-1-1-使用工具" class="headerlink" title="2.1.1 使用工具"></a>2.1.1 使用工具</h4><p>MT管理器和NP管理器，都是Android设备上用于文件管理和系统操作的工具，但它们在功能特点、用户界面以及使用场景上有一些区别。</p>
<p><strong>MT管理器</strong></p>
<p>MT管理器（MT Manager）是一款功能强大的文件管理器，主要用于对APK文件、dex&#x2F;oat&#x2F;smali文件进行编辑，还可以进行文件对比、文本翻译等。它的主要特点包括：</p>
<ul>
<li>支持直接编辑APK文件中的资源文件、smali代码。</li>
<li>提供了丰富的文件操作功能，如复制、粘贴、重命名等。</li>
<li>可以用来汉化应用、修改游戏数据等高级操作。</li>
<li>用户界面相对复杂，更适合有一定技术背景的用户使用。</li>
</ul>
<p><strong>NP管理器</strong></p>
<p>NP管理器（NP Manager）也是一个文件管理器，虽然它也提供了对APK文件的基本编辑能力，但是其主要侧重点在于提供更直观的文件浏览体验和基本的文件管理功能。相比于MT管理器，NP管理器的特点有：</p>
<ul>
<li>界面设计更加简洁直观，适合普通用户进行基础的文件管理任务。</li>
<li>提供了对多种文件格式的支持，如压缩文件(zip, rar)的解压与创建。</li>
<li>功能性上相对于MT管理器来说较为简单，适用于不需要深入编辑apk或系统文件的用户。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>功能深度</strong>：MT管理器在处理复杂的文件编辑和系统级操作方面更为强大；而NP管理器则侧重于提供一个易于使用的文件管理解决方案。</li>
<li><strong>用户界面</strong>：MT管理器的UI更加复杂，包含更多专业化的选项；NP管理器设计得更加友好，适合所有级别的用户。</li>
<li><strong>使用场景</strong>：如果需要对应用程序进行深层次的修改，比如反编译apk文件，则MT管理器是更好的选择。而对于那些仅需要基本文件管理功能的用户来说，NP管理器可能更加合适。</li>
</ul>
<p>根据实际需求应用，有的功能需要VIP……</p>
<h4 id="2-1-2-操作"><a href="#2-1-2-操作" class="headerlink" title="2.1.2 操作"></a>2.1.2 操作</h4><p>将MT管理器、NP管理器以及练手demo安装至安卓模拟器</p>
<p>由于MT管理器双开需要会员，所以选择NP管理器。进入NP管理器软件，点击左上角的三根杠，选择安装包提取。</p>
<p>然后选择需要提取的软件</p>
<p> —&gt; 提取安装包—&gt; 定位 —&gt;点击软件 —&gt;功能—&gt;APK共存</p>
<p>最后确认，此时便有了该软件的安装包，通过带点击下方提取出来的安装包，进行安装，桌面上便有了新的一个demo软件</p>
<p>注意这个地方，提取出来后，两个包的包名不一样</p>
<p>由于该方法是通过修改包名实现的，所以懂了应用的签名信息，如果开发者做了一个签名校验，那就很有可能安装后软件出现闪退奔溃的情况。</p>
<h2 id="3-汉化"><a href="#3-汉化" class="headerlink" title="3.汉化"></a>3.汉化</h2><p><strong>汉化：使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</strong></p>
<p>基本上字符串都是在arsc里，建议一键汉化，然后再润色。<br>少量没汉化到的字符串参考视频中的方法定位去逐个汉化。</p>
<p>流程图</p>
<p>可以使用MT管理器，进入demo的apk文件中，进行搜索需要修改句子对应的文件所在位置，使用搜索，点击高级搜索可以进入全局搜索。查找到文件位置后进入文件，手动修改句子，翻译为中文。真的累。</p>
<p>修改后会出现一个签名改动的问题，可以直接卸载了再安装，或者核心破解。</p>
<h2 id="4-初识AndroidManifest-xml"><a href="#4-初识AndroidManifest-xml" class="headerlink" title="4.初识AndroidManifest.xml"></a>4.初识AndroidManifest.xml</h2><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">versionCode</td>
<td align="left">版本号，主要用来更新，例如:12</td>
</tr>
<tr>
<td align="left">versionName</td>
<td align="left">版本名，给用户看的，例如:1.2</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包名，例如：com.zj.52pj.demo</td>
</tr>
<tr>
<td align="left">uses-permission android:name&#x3D;””</td>
<td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td>
</tr>
<tr>
<td align="left">android:label&#x3D;”@string&#x2F;app_name”</td>
<td align="left">应用名称</td>
</tr>
<tr>
<td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td>
<td align="left">应用图标路径</td>
</tr>
<tr>
<td align="left">android:debuggable&#x3D;”true”</td>
<td align="left">应用是否开启debug权限</td>
</tr>
</tbody></table>
<h1 id="二、初识smail"><a href="#二、初识smail" class="headerlink" title="二、初识smail"></a>二、初识smail</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>吾爱破解</tag>
        <tag>安卓逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>实操·开发简单APP</title>
    <url>/2025/08/11/%E5%AE%9E%E6%93%8D%C2%B7%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95APP/</url>
    <content><![CDATA[<p>内容：写一个“输入密码 → 验证” 的简单APP（含按钮点击事件、密码判断逻辑），生成APK。</p>
<p>工具：Android Studio 2024.2.1 Path 2</p>
<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><ol>
<li>在“ New Project ”界面，选择<strong>Empty  Views Activity</strong>（空活动，最简单的模板），点击“ Next ”。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508110117481.png" alt="New Project"></p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508110119734.png" alt="Empty Views Activity"></p>
<ol start="2">
<li>填写项目信息：<ul>
<li>Name（项目名）：<code>PassworkChecker</code></li>
<li>Package name（包名）：默认即可（类似<code>com.example.passworkchecker</code>）</li>
<li>Save location（保存路径）：选一个自己能找到的文件夹</li>
<li>Language（语言）：选<strong>Java</strong>（更基础）</li>
<li>Minimum SDK（最低支持的安卓版本）：选默认的“ API 24 ”（覆盖大多数手机）</li>
</ul>
</li>
<li>点击“ Finish ”，等待项目加载完成（第一次可能会久一点，看网络）。</li>
</ol>
<h2 id="第二步-设计界面（输入密码的页面）"><a href="#第二步-设计界面（输入密码的页面）" class="headerlink" title="第二步 设计界面（输入密码的页面）"></a>第二步 设计界面（输入密码的页面）</h2><p>需要一个“ 输入框 ”让用户输密码，一个“ 按钮 ”点击验证，一个“ 文字 ”显示结果。</p>
<ol>
<li><p>找到页面设计文件：</p>
<p> 在左侧“ Project ”面板中，展开<code>app &gt; res &gt; layout</code>，双击<code>activity_main.xml</code>（这是默认的页面布局文件）。</p>
</li>
<li><p>切换道“ 代码试图 ”：</p>
<p> 点击右上角的<strong>Code</strong>标签（默认可能时“ Design ”可视化视图，直接写简单代码更清晰）。</p>
</li>
<li><p>替换布局代码：</p>
<p> 把原来的代码全都删掉，编写一下代码：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 垂直排列的容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_hight</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:padding</span>=<span class="string">&quot;30dp&quot;</span>	&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_password&quot;</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>+&quot;<span class="attr">wrap_content</span>&quot;</span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 验证按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;验证密码&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 结果显示文字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 左侧预览窗会显示：一个输入框、一个按钮、一个空白区域（用于显示结果）</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140114082.png"></p>
</li>
</ol>
<h2 id="第三步：写逻辑代码（点击按钮验证密码）"><a href="#第三步：写逻辑代码（点击按钮验证密码）" class="headerlink" title="第三步：写逻辑代码（点击按钮验证密码）"></a>第三步：写逻辑代码（点击按钮验证密码）</h2><p>点击 “验证密码” 按钮后，获取输入的密码，判断是否正确（比如设定正确密码是 “123456”），然后显示结果。</p>
<ol>
<li><p>找到逻辑代码文件：<br> 在左侧 “Project” 面板中，展开 <code>app &gt; java &gt; 包名（com.example.xxx）</code>，双击 <code>MainActivity.java</code>。</p>
</li>
<li><p>替换逻辑代码：<br> 把原来的代码全删掉，复制下面的代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.passwordchecker;  <span class="comment">// 这里的包名要和你项目的一致（默认不用改）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义控件变量（提前声明，方便后面使用）</span></span><br><span class="line">    <span class="keyword">private</span> EditText etPassword;  <span class="comment">// 密码输入框</span></span><br><span class="line">    <span class="keyword">private</span> Button btnCheck;      <span class="comment">// 验证按钮</span></span><br><span class="line">    <span class="keyword">private</span> TextView tvResult;    <span class="comment">// 结果显示文字</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载我们写的界面布局</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到界面中的控件（通过ID匹配）</span></span><br><span class="line">        etPassword = findViewById(R.id.et_password);</span><br><span class="line">        btnCheck = findViewById(R.id.btn_check);</span><br><span class="line">        tvResult = findViewById(R.id.tv_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给按钮设置“点击事件”：点击后执行验证逻辑</span></span><br><span class="line">        btnCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取输入的密码（从输入框中取文字）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> etPassword.getText().toString();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 判断密码是否正确（这里设定正确密码是“123456”）</span></span><br><span class="line">                <span class="keyword">if</span> (password.equals(<span class="string">&quot;123456&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 正确：显示“验证成功”</span></span><br><span class="line">                    tvResult.setText(<span class="string">&quot;密码正确！验证通过～&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 错误：显示“密码错误”</span></span><br><span class="line">                    tvResult.setText(<span class="string">&quot;密码错误，请重新输入！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第四步：运行-APP（在模拟器上测试）"><a href="#第四步：运行-APP（在模拟器上测试）" class="headerlink" title="第四步：运行 APP（在模拟器上测试）"></a>第四步：运行 APP（在模拟器上测试）</h2><ol>
<li>创建模拟器：<br> 点击顶部工具栏的 <strong>Device Manager</strong>（像手机一样的图标），点击 “Create device”，选择一个手机型号（比如 “Pixel 5”），点击 “Next”，选择一个安卓版本（比如 “Tiramisu”），下载后点击 “Finish”。</li>
<li>启动模拟器：<br> 在 Device Manager 中，点击刚创建的模拟器右侧的 “启动” 按钮（三角形），等待模拟器启动（第一次可能要几分钟，会显示一个安卓手机界面）。</li>
<li>运行 APP：<br> 点击 Android Studio 顶部的 <strong>Run</strong> 按钮（绿色三角形），选择刚才的模拟器，等待编译运行（底部会显示进度）。<br> 成功后，模拟器上会出现我们的 APP，打开后可以：<ul>
<li>在输入框中输入文字</li>
<li>点击 “验证密码” 按钮</li>
<li>看到结果（输入 “123456” 显示正确，其他显示错误）</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140113304.png"></p>
<h2 id="第五步：生成-APK-文件（可安装到手机的文件）"><a href="#第五步：生成-APK-文件（可安装到手机的文件）" class="headerlink" title="第五步：生成 APK 文件（可安装到手机的文件）"></a>第五步：生成 APK 文件（可安装到手机的文件）</h2><p>APK 是安卓应用的安装包，生成后可以传到自己的手机上安装。</p>
<ol>
<li><p>生成步骤：<br> 顶部菜单选择 **Build &gt; Build Bundle(s) &#x2F; APK(s) &gt; Build APK(s)**。<br> 等待编译完成，底部会提示 “APK generated successfully”，点击 “locate”，会打开文件夹，里面的 <code>app-debug.apk</code> 就是我们的安装包。</p>
</li>
<li><p>安装到手机：<br> 把 <code>app-debug.apk</code> 传到自己的安卓手机上（用微信 &#x2F; QQ 发送），在手机上点击该文件，按照提示安装（可能需要开启 “未知来源应用安装” 权限）。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140126526.jpg"></p>
</li>
</ol>
<h3 id="总结一下核心逻辑"><a href="#总结一下核心逻辑" class="headerlink" title="总结一下核心逻辑"></a>总结一下核心逻辑</h3><ol>
<li>界面（XML）：用 3 个控件（输入框、按钮、结果文字）垂直排列。</li>
<li>逻辑（Java）：<ul>
<li>找到界面上的控件</li>
<li>给按钮设置点击事件</li>
<li>点击时获取输入的密码，和 “123456” 对比，显示结果</li>
</ul>
</li>
</ol>
<p>这个过程涵盖了安卓开发的基础：界面设计、控件操作、事件处理。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓实操</tag>
      </tags>
  </entry>
  <entry>
    <title>实操·会员验证+猜数游戏</title>
    <url>/2025/08/11/%E5%AE%9E%E6%93%8D%C2%B7%E4%BC%9A%E5%91%98%E9%AA%8C%E8%AF%81-%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>内容：实现流程：打开 APP 先显示验证页 → 输入正确会员密码 → 跳转到猜数字游戏页。</p>
<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><ol>
<li>在“ New Project ”界面，选择<strong>Empty  Views Activity</strong>（空活动，最简单的模板），点击“ Next ”。</li>
<li>填写项目信息：<ul>
<li>Name（项目名）：<code>GuessTheNumbers</code></li>
<li>Package name（包名）：默认即可（类似<code>com.example.Guessthenumber</code>）</li>
<li>Save location（保存路径）：选一个自己能找到的文件夹</li>
<li>Language（语言）：选<strong>Java</strong>（更基础）</li>
<li>Minimum SDK（最低支持的安卓版本）：选默认的“ API 24 ”（覆盖大多数手机）</li>
</ul>
</li>
<li>点击“ Finish ”，等待项目加载完成（第一次可能会久一点，看网络）。</li>
</ol>
<h2 id="第二步-设计会员验证页面布局（activity-login-xml）"><a href="#第二步-设计会员验证页面布局（activity-login-xml）" class="headerlink" title="第二步 设计会员验证页面布局（activity_login.xml）"></a>第二步 设计会员验证页面布局（activity_login.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;会员验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_vip_password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入会员密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_vip_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;点击验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_vip_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三步-会员验证页面逻辑（LoginActivity-java）"><a href="#第三步-会员验证页面逻辑（LoginActivity-java）" class="headerlink" title="第三步 会员验证页面逻辑（LoginActivity.java）"></a>第三步 会员验证页面逻辑（LoginActivity.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.guessthenumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText etVipPassword;</span><br><span class="line">    <span class="keyword">private</span> Button btnVipCheck;</span><br><span class="line">    <span class="keyword">private</span> TextView tvVipResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CORRECT_PASSWORD=<span class="string">&quot;vip666&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载布局</span></span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        <span class="comment">// 绑定控件（通过ID关联布局中的元素）</span></span><br><span class="line">        etVipPassword = findViewById(R.id.et_vip_password);</span><br><span class="line">        btnVipCheck = findViewById(R.id.btn_vip_check);</span><br><span class="line">        tvVipResult = findViewById(R.id.tv_vip_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮点击事件：验证密码并跳转</span></span><br><span class="line">        btnVipCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取用户输入的密码</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> etVipPassword.getText().toString().trim();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 验证逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (inputPassword.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 输入为空</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;请输入会员密码&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputPassword.equals(CORRECT_PASSWORD)) &#123;</span><br><span class="line">                    <span class="comment">// 密码正确：跳转到猜数字页面</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;验证成功，正在进入游戏...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建跳转意图（从当前页到游戏页）</span></span><br><span class="line">                    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(LoginActivity.<span class="built_in">this</span>, MainActivity.class);</span><br><span class="line">                    startActivity(intent); <span class="comment">// 执行跳转</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 关闭当前验证页（可选：防止返回键回到验证页）</span></span><br><span class="line">                    finish();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 密码错误</span></span><br><span class="line">                    <span class="comment">// （正确密码：vip666）</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;密码错误，请重新输入&quot;</span>);</span><br><span class="line">                    <span class="comment">// 清空输入框</span></span><br><span class="line">                    etVipPassword.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第四步-设计猜数游戏页面布局（activity-main-xml）"><a href="#第四步-设计猜数游戏页面布局（activity-main-xml）" class="headerlink" title="第四步 设计猜数游戏页面布局（activity_main.xml）"></a>第四步 设计猜数游戏页面布局（activity_main.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;猜数游戏&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_game_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入0-100之间的数字&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_game_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;点击验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#CECECE&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_game_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="第五步-猜数游戏逻辑（MainActivity-java）"><a href="#第五步-猜数游戏逻辑（MainActivity-java）" class="headerlink" title="第五步 猜数游戏逻辑（MainActivity.java）"></a>第五步 猜数游戏逻辑（MainActivity.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.guessthenumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控件声明</span></span><br><span class="line">    <span class="keyword">private</span> EditText etGameNumber;    <span class="comment">// 数字输入框</span></span><br><span class="line">    <span class="keyword">private</span> Button btnGameCheck;      <span class="comment">// 猜测按钮</span></span><br><span class="line">    <span class="keyword">private</span> TextView tvGameResult;    <span class="comment">// 结果提示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetGameNumber;     <span class="comment">// 目标随机数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minRange</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">// 当前范围最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRange</span> <span class="operator">=</span> <span class="number">100</span>;   <span class="comment">// 当前范围最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载布局</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定控件</span></span><br><span class="line">        etGameNumber = findViewById(R.id.et_game_number);</span><br><span class="line">        btnGameCheck = findViewById(R.id.btn_game_check);</span><br><span class="line">        tvGameResult = findViewById(R.id.tv_game_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成0-100的随机数（游戏初始化）</span></span><br><span class="line">        targetGameNumber = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">101</span>);  <span class="comment">// 0-100闭区间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 猜测按钮点击事件</span></span><br><span class="line">        btnGameCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取用户输入的数字</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> etGameNumber.getText().toString().trim();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 输入验证</span></span><br><span class="line">                <span class="keyword">if</span> (input.isEmpty()) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入数字后再猜～&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 转换为整数（处理非数字输入）</span></span><br><span class="line">                <span class="type">int</span> userNumber;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    userNumber = Integer.parseInt(input);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入有效的数字！&quot;</span>);</span><br><span class="line">                    etGameNumber.setText(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空错误输入</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 检查数字范围</span></span><br><span class="line">                <span class="keyword">if</span> (userNumber &lt; <span class="number">0</span> || userNumber &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入0-100之间的数字！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 核心逻辑：对比用户输入与目标数字</span></span><br><span class="line">                <span class="keyword">if</span> (userNumber == targetGameNumber) &#123;</span><br><span class="line">                    <span class="comment">// 猜对了</span></span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;恭喜你！猜对了！🎉&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userNumber &lt; targetGameNumber) &#123;</span><br><span class="line">                    <span class="comment">// 猜小了：更新最小值</span></span><br><span class="line">                    minRange = userNumber;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;猜小了～ 范围：&quot;</span> + minRange + <span class="string">&quot; 到 &quot;</span> + maxRange);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 猜大了：更新最大值</span></span><br><span class="line">                    maxRange = userNumber;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;猜大了～ 范围：&quot;</span> + minRange + <span class="string">&quot; 到 &quot;</span> + maxRange);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 清空输入框，方便下次输入</span></span><br><span class="line">                etGameNumber.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="第六步-配置文件（AndroidManifest-xml）"><a href="#第六步-配置文件（AndroidManifest-xml）" class="headerlink" title="第六步 配置文件（AndroidManifest.xml）"></a>第六步 配置文件（AndroidManifest.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/taikongren&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/taikongren&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.GuessTheNumbers&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.LoginActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="完整流程测试步骤"><a href="#完整流程测试步骤" class="headerlink" title="完整流程测试步骤"></a>完整流程测试步骤</h2><ol>
<li><p>运行 APP，首先显示「会员验证页」。</p>
<p> 效果如下图所示：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508151645644.png" alt="会员验证界面"></p>
</li>
<li><p>输入正确密码 <code>vip666</code>（可在 <code>LoginActivity</code> 中修改）。</p>
</li>
<li><p>点击「验证并进入游戏」，自动跳转到「猜数字游戏页」。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508151646861.png" alt="猜数游戏界面"></p>
</li>
<li><p>在游戏页输入数字猜测，系统会提示范围（如 “猜小了～ 范围：20 到 100”）。</p>
</li>
<li><p>猜对后显示 “恭喜你！猜对了！🎉”。</p>
</li>
</ol>
<h2 id="核心技术点说明"><a href="#核心技术点说明" class="headerlink" title="核心技术点说明"></a>核心技术点说明</h2><ul>
<li><strong>页面跳转</strong>：通过 <code>Intent</code> 实现两个页面的切换，<code>startActivity(intent)</code> 触发跳转。</li>
<li><strong>启动页设置</strong>：<code>AndroidManifest.xml</code> 中，<code>LoginActivity</code> 包含 <code>&lt;intent-filter&gt;</code> 标记，因此成为 APP 打开的第一个页面。</li>
<li><strong>数据验证</strong>：两个页面都添加了输入检查（空输入、格式错误等），提升用户体验。</li>
<li><strong>生命周期管理</strong>：<code>finish()</code> 方法关闭验证页，防止用户按返回键回到验证页（可选逻辑）。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓实操</tag>
      </tags>
  </entry>
  <entry>
    <title>破解·常用工具</title>
    <url>/2025/08/19/%E7%A0%B4%E8%A7%A3%C2%B7%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h2><p>[学习链接]([渗透之OllyDbg逆向分析动态调试工具使用 - 大柿子 - 博客园](<a href="https://www.cnblogs.com/xsj210/p/15770601.html#:~:text=%E8%8B%A5%E6%98%AF%E4%BD%A0%E6%83%B3%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AAEXE%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8F%B3%E9%94%AE%E7%9B%B4%E6%8E%A5%E5%8F%AF%E4%BB%A5%E7%94%A8OllyDbg%E6%89%93%E5%BC%80%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%91%A2%EF%BC%9F">https://www.cnblogs.com/xsj210/p/15770601.html#:~:text=若是你想选中一个EXE文件，右键直接可以用OllyDbg打开，怎么设置呢？</a> 点击 “选项” -&gt;,“添加到浏览器”，添加OllyDbg到系统资源管理器菜单。 若是咱们每次运行OD都提示管理员权限运行，则能够进行快捷键简单的设置。 设置方式以下：兼容性中选择“以管理员身份运行此程序”。 下面简单讲解经常使用的快捷键调试方式。 设置断点，只要在光标定位的位置按下F2键便可，再按一次F2键会删除断点。))</p>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>动态调试工具</p>
<p>Windows 平台专属工具，主要用于分析 <strong>x86 架构的 PE 格式程序</strong>（如 .exe、.dll）。</p>
<p>包括反汇编窗口、寄存器窗口、信息窗口、数据窗口、堆栈窗口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200012.png"></p>
<p>当界面乱象时，可以点击顶部快捷键C，主窗口最大化便可优化布局。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200837.png"></p>
<p>各个窗口的含义：</p>
<ul>
<li><p>反汇编窗口： 显示被调试程序的反汇编代码，包括地址、HEX数据、反汇编、注释</p>
</li>
<li><p>寄存器窗口： 显示当前所选线程的CPU寄存器内容，点击标签可切换显示寄存器的方式</p>
</li>
<li><p>信息窗口： 显示反汇编窗口中选中的第一个命令的参数及跳转目标地址、字符等</p>
</li>
<li><p>数据窗口： 显示内存或文件的内容，右键菜单可切换显示方式</p>
</li>
<li><p>堆栈窗口： 显示当前线程的堆栈，记录传递的参数或局部变量</p>
</li>
<li><p>子窗口的快捷方式</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200626.png"></p>
</li>
</ul>
<p>点击 “选项” -&gt; “界面”，设置UDD路径和插件路径</p>
<ul>
<li>UDD路径用于保存咱们调试的信息。</li>
<li>插件路径包含了各类插件，而且能够直接使用。</li>
</ul>
<p>管理员权限运行</p>
<ul>
<li>点击OllyDbg.exe右键点击属性</li>
<li>兼容性中选择“以管理员身份运行此程序”</li>
</ul>
<h3 id="经常快捷键"><a href="#经常快捷键" class="headerlink" title="经常快捷键"></a>经常快捷键</h3><p>F2：设置断点<br>设置断点，只要在光标定位的位置按下F2键便可，再按一次F2键会删除断点。</p>
<p>CTRL+F2：从新开始<br>当程序想从新调试时，按下CTRL+F2便可。</p>
<p>F4：运行到选定位置<br>运行到选定位置，做用就是直接运行到光标所在位置处暂停。当咱们调试过程当中遇到循环，能够调至光标跳过循环。</p>
<p>F7：单步步入<br>单步步入，功能通单步步过（F8）相似，区别是遇到CALL等子程序时会进入其中，进入后首先停留在子程序的第一条指令上。以下图进入CALL子程序。CALL表示进入函数，RETN表示返回。</p>
<p>F8：单步步过<br>单步步过，每按一次这个按键，将执行反汇编窗口中的一条指令，遇到CALL等子程序不进入其代码。</p>
<p>F9：运行<br>按下F9键运行程序，若是没有设置相应的断点，被调试的程序直接开始运行。</p>
<p>CTRL+F9：执行到返回<br>执行到返回，按下此键会执行到一个返回指令时暂停，经常使用于从系统领空返回到咱们调试的程序领空。在调试程序时，按下CTRL+F9会一直运行程序，直到一个RETURN返回。再在RETN 10位置按下F8，则会返回以下图所示的位置，执行完CALL函数进入下一句。</p>
<p>ALT+F9：执行到用户代码<br>执行到用户代码，从系统领空快速返回咱们调试的程序领空。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>环境小记</title>
    <url>/2025/05/21/%E7%8E%AF%E5%A2%83%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1-Windows环境配置"><a href="#1-Windows环境配置" class="headerlink" title="1. Windows环境配置"></a>1. Windows环境配置</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>1.WINDOWS环境配置的难易程度因人而异，很多学员在此步骤上遇到困难。 </p>
<p>2.LINUX系统问题较少，原因是使用者较少且版本统一，而WINDOWS系统版本繁多，导致问题多样。 </p>
<p>3.WINDOWS系统使用ANSI编码，与常用的UTF-8编码不同，可能导致兼容性问题。</p>
<h3 id="1-2-系统版本选择"><a href="#1-2-系统版本选择" class="headerlink" title="1.2 系统版本选择"></a>1.2 系统版本选择</h3><p>1.推荐使用原版WINDOWS 10系统，避免使用精简版，以防出现未知问题。</p>
<p> 2.查看系统版本的方法包括使用win ver命令或系统设置中的关于选项。 </p>
<p>3.启用超级用户（类似于安卓系统的root用户）可以解决权限问题，避免某些操作失败。</p>
<h2 id="2-cmd和环境变量"><a href="#2-cmd和环境变量" class="headerlink" title="2. cmd和环境变量"></a>2. cmd和环境变量</h2><h3 id="2-1-cmd的打开方式"><a href="#2-1-cmd的打开方式" class="headerlink" title="2.1 cmd的打开方式"></a>2.1 cmd的打开方式</h3><p>1.cmd是一个常用的终端工具，在逆向工程中经常使用。 </p>
<p>2.打开cmd的方式有多种，推荐使用快捷键win键+r键打开。 </p>
<p>3.另一种打开方式是在指定路径下直接点击cmd，无需切换路径。</p>
<h3 id="2-2-cmd的基本操作"><a href="#2-2-cmd的基本操作" class="headerlink" title="2.2 cmd的基本操作"></a>2.2 cmd的基本操作</h3><p>1.显示当前路径下的所有文件，使用dir命令。 </p>
<p>2.清屏操作，使用cls命令。 </p>
<p>3.切换目录，使用cd命令。 </p>
<p>4.Tab键自动补全路径。 </p>
<p>5.复制和粘贴操作，通过右键菜单完成。 </p>
<p>6.回到上一级目录，使用cd..命令。 </p>
<p>7.上下键选择之前输入过的命令。 </p>
<p>8.在cmd中运行文件，包括没有扩展名的文件。</p>
<h3 id="2-4-相对路径和绝对路径"><a href="#2-4-相对路径和绝对路径" class="headerlink" title="2.4 相对路径和绝对路径"></a>2.4 相对路径和绝对路径</h3><p>1.绝对路径从盘符开始，如E:\soft\test。 </p>
<p>2.相对路径基于当前目录，如..\c或b。 </p>
<p>3.CD -d命令用于在不同盘符之间切换。</p>
<h3 id="2-5-环境变量的作用"><a href="#2-5-环境变量的作用" class="headerlink" title="2.5 环境变量的作用"></a>2.5 环境变量的作用</h3><p>1.环境变量Path用于指定程序搜索路径。 </p>
<p>2.通过将路径添加到Path变量，程序可以在任意目录下运行。 </p>
<p>3.环境变量的加载在启动时完成，新开的cmd窗口才能识别新的环境变量。</p>
<h2 id="3-jdk的安装"><a href="#3-jdk的安装" class="headerlink" title="3.jdk的安装"></a>3.jdk的安装</h2><h3 id="3-1-jdk的介绍"><a href="#3-1-jdk的介绍" class="headerlink" title="3.1 jdk的介绍"></a>3.1 jdk的介绍</h3><p>1.jdk是JAVA开发工具集，包含JAVA虚拟机和一些基本的类库。 </p>
<p>2.jdk是jre的基础上增加了开发工具，用于JAVA开发。 </p>
<p>3.jdk的版本主要有8和17，其中8和11是长期支持版本。</p>
<h3 id="3-2-jdk的下载和安装"><a href="#3-2-jdk的下载和安装" class="headerlink" title="3.2 jdk的下载和安装"></a>3.2 jdk的下载和安装</h3><p>1.jdk可以从Oracle官网或OpenJDK网站下载。 </p>
<p>2.下载时需要注册账号并登录。 </p>
<p>3.安装时选择合适的操作系统和版本，可以是ese或exe。</p>
<h3 id="3-3-jdk的安装检测"><a href="#3-3-jdk的安装检测" class="headerlink" title="3.3 jdk的安装检测"></a>3.3 jdk的安装检测</h3><p>1.安装完成后，通过cmd输入JAVA或JAVA_HOME来检测安装是否成功。 </p>
<p>2.如果输入JAVA或JAVA_HOME能显示版本信息，则表示环境配置正确。</p>
<h2 id="5-Windows注意事项"><a href="#5-Windows注意事项" class="headerlink" title="5.Windows注意事项"></a>5.Windows注意事项</h2><h3 id="5-1-Windows路径命名规范"><a href="#5-1-Windows路径命名规范" class="headerlink" title="5.1 Windows路径命名规范"></a>5.1 Windows路径命名规范</h3><p>1.Windows系统中路径命名应避免使用中文、空格和特殊符号，以防止出现错误。 </p>
<p>2.计算机名也应避免使用中文，以确保软件的正常运行。 </p>
<p>3.国外软件在Windows系统中对中文路径的兼容性较差。</p>
<h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>1.安装Python时，建议将Python的安装路径和脚本路径添加到系统环境变量中。 </p>
<p>2.通过配置环境变量，可以方便地运行Python解释器和脚本。 </p>
<p>3.在Windows系统中，可以使用path变量来添加Python的安装路径和脚本路径。</p>
<h3 id="5-3-计算机名对软件运行的影响"><a href="#5-3-计算机名对软件运行的影响" class="headerlink" title="5.3 计算机名对软件运行的影响"></a>5.3 计算机名对软件运行的影响</h3><p>1.计算机名使用中文可能导致某些软件无法正常运行，尤其是国外软件。 </p>
<p>2.修改计算机名为英文或数字可以解决某些软件运行问题。 </p>
<p>3.在虚拟机中可以方便地修改计算机名以进行测试。</p>
<h2 id="6-Android-Studio"><a href="#6-Android-Studio" class="headerlink" title="6.Android Studio"></a>6.Android Studio</h2><h3 id="6-1-安装与配置"><a href="#6-1-安装与配置" class="headerlink" title="6.1 安装与配置"></a>6.1 安装与配置</h3><p>1.Android Studio是一个强大的IDE工具，用于安卓开发和逆向工程。 </p>
<p>2.安装过程包括下载安装包和选择安装路径，建议不要将Android Studio安装在系统盘。</p>
<h3 id="6-2-启动与配置"><a href="#6-2-启动与配置" class="headerlink" title="6.2 启动与配置"></a>6.2 启动与配置</h3><p>1.启动Android Studio时选择不导入任何配置文件。 </p>
<p>2.选择自定义设置，并配置SDK的安装路径。 </p>
<p>3.配置模拟器的内存和主题选择。</p>
<h3 id="6-3-SDK的配置与管理"><a href="#6-3-SDK的配置与管理" class="headerlink" title="6.3 SDK的配置与管理"></a>6.3 SDK的配置与管理</h3><p>1.通过SDK Manager配置SDK，包括安装不同版本的SDK和工具。 </p>
<p>2.选择安装安卓10（API 29）和必要的build tools、NDK和CMake。</p>
<p>3.安装Google USB Driver以连接谷歌手机。</p>
<h3 id="6-4-创建安卓项目"><a href="#6-4-创建安卓项目" class="headerlink" title="6.4 创建安卓项目"></a>6.4 创建安卓项目</h3><p>1.选择创建Native C++项目以测试NDK支持。 </p>
<p>2.输入项目名称和包名，选择保存路径和语言（Java或Kotlin）。 </p>
<p>3.选择最小支持的SDK版本和C++标准。</p>
<h3 id="6-5-工程目录结构"><a href="#6-5-工程目录结构" class="headerlink" title="6.5 工程目录结构"></a>6.5 工程目录结构</h3><p>1.项目目录包括工程级别的配置文件和模块级别的代码文件。 </p>
<p>2.模块目录结构包括src、main、java和gradle文件。 </p>
<p>3.gradle文件中配置SDK版本、build tools版本和编译目标API版本。</p>
<h3 id="6-6-SDK目录结构"><a href="#6-6-SDK目录结构" class="headerlink" title="6.6 SDK目录结构"></a>6.6 SDK目录结构</h3><p>1.SDK目录包括build tools、platform tools、USB driver和其他编译和打包工具。 </p>
<p>2.build tools用于编译APP，platform tools用于刷机和操控手机。</p>
<h3 id="6-7-配置文件位置"><a href="#6-7-配置文件位置" class="headerlink" title="6.7 配置文件位置"></a>6.7 配置文件位置</h3><p>1.Android Studio的配置文件包括gradle和android配置文件。 </p>
<p>2.配置文件位于C盘用户目录下，需要手动删除以重置配置。</p>
<h2 id="7-ADB（Android-Debug-Bridge）"><a href="#7-ADB（Android-Debug-Bridge）" class="headerlink" title="7.ADB（Android Debug Bridge）"></a>7.ADB（Android Debug Bridge）</h2><h3 id="7-1-作用与原理"><a href="#7-1-作用与原理" class="headerlink" title="7.1 作用与原理"></a>7.1 作用与原理</h3><p>1.adb可以在电脑端操控手机，主要用于安卓应用安装和调试。 </p>
<p>2.adb的原理是通过电脑端的客户端和服务器与手机端的adbd进程进行交互，发送指令并操控手机。</p>
<p>3.adb客户端和服务器在电脑端，而adbd进程在手机端。</p>
<h3 id="7-2-概念与命令"><a href="#7-2-概念与命令" class="headerlink" title="7.2 概念与命令"></a>7.2 概念与命令</h3><p>1.超级adb具有root权限，不需要通过SEO申请，可以通过修改adbd源码实现。 </p>
<p>2.超级adb可以使用两个命令：adb root和adb remount。 </p>
<p>3.adb root使adb在root权限下运行，adb remount将system分区挂载为可读写。</p>
<h3 id="7-3-超级adb配置与环境变量"><a href="#7-3-超级adb配置与环境变量" class="headerlink" title="7.3 超级adb配置与环境变量"></a>7.3 超级adb配置与环境变量</h3><p>1.adb在SDK的platform tools目录下，使用前需将该目录添加到环境变量中。 </p>
<p>2.通过修改环境变量，可以在任意目录下访问adb命令。 </p>
<p>3.添加环境变量后，需重启计算机使其生效。</p>
<h3 id="7-4-adb常用命令"><a href="#7-4-adb常用命令" class="headerlink" title="7.4 adb常用命令"></a>7.4 adb常用命令</h3><p>略</p>
<h2 id="8-安卓模拟环境"><a href="#8-安卓模拟环境" class="headerlink" title="8. 安卓模拟环境"></a>8. 安卓模拟环境</h2><h3 id="8-1-安装软件"><a href="#8-1-安装软件" class="headerlink" title="8.1 安装软件"></a>8.1 安装软件</h3><p>1.到官网下载9.0模拟器，并安装<br><a href="https://www.ldmnq.com/">https://www.ldmnq.com/</a></p>
<p>[更新!]适用于几乎所有安卓模拟器(7+)安装magisk的教程-简单无脑向<br><a href="https://www.52pojie.cn/thread-1583586-1-1.html">https://www.52pojie.cn/thread-1583586-1-1.html</a><br>(出处: 吾爱破解论坛)</p>
<p>2.下载配置文件</p>
<p>3.安装面具</p>
<h3 id="8-2-Magisk介绍"><a href="#8-2-Magisk介绍" class="headerlink" title="8.2 Magisk介绍"></a>8.2 Magisk介绍</h3><p>Magisk 是一套用于定制 Android 的开源软件，支持高于 Android 5.0 的设备。</p>
<p>以下是一些功能亮点：</p>
<ul>
<li><strong>MagiskSU</strong>：为应用程序提供 root 访问权限</li>
<li><strong>Magisk 模块</strong>：通过安装模块修改只读分区</li>
<li><strong>MagiskHide</strong>：从根检测 &#x2F; 系统完整性检查中隐藏 Magisk(Shamiko)</li>
<li><strong>MagiskBoot</strong> : 最完整的安卓启动镜像解包和重新打包工具</li>
</ul>
<p>#二、工具介绍</p>
<h2 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1.IDE"></a>1.IDE</h2><p>IDE（集成开发环境）- IDEA</p>
<ul>
<li>IDEA介绍</li>
</ul>
<ol>
<li><p>DEA全程InteliJ IDEA</p>
</li>
<li><p>在业界被公认为最好的Java开发工具</p>
</li>
<li><p>IDEA是JetBrains公司的产品，总部位于捷克的首部布拉格</p>
</li>
<li><p>除了支持Java开发，还支持HTML、CSS、PHP、MySQL、Python等</p>
</li>
</ol>
<p>IDE（集成开发环境）- Eclipse</p>
<ul>
<li>Eclipse介绍</li>
</ul>
<ol>
<li>Eclipse是开放源代码的、基于JAva的可拓展开发平台</li>
<li>最初是由IBM公司耗资3000万美金开发的下一代IDE开发环境</li>
<li>2001年11月贡献给开源社区</li>
<li>Eclipse是目前最优秀的Java开发IDE之一</li>
</ol>
<h2 id="2-jadx"><a href="#2-jadx" class="headerlink" title="2. jadx"></a>2. jadx</h2><p>下载地址：<a href="https://github.com/skylot/jadx/releases/tag/v1.3.2">Release 1.3.2 · skylot&#x2F;jadx</a></p>
<p>1.jadx是一个常用的反编译工具，更新到1.3版本，功能强大。 </p>
<p>2.jadx安装在GitHub上，提供源代码和编译好的版本。 3.安装简单，不需要安装jadx本身，只需安装7-Zip用于解压。</p>
<p> 4.安装完成后，通过修改注册表并勾选选项，自动识别jadx。 </p>
<p>5.jadx界面默认中文版，可用于反编译APP，生成字面文件和代码。</p>
<p> 6.新版本jadx可以直接导出源代码，支持中文显示内存使用栏。</p>
<p>7.通过bat文件可以修改内存使用量，默认4GB，可改为8GB。 </p>
<p>8.jadx支持搜索类名和源代码，具有调试功能，需配置ADB。 </p>
<p>9.反混淆功能建议关闭，以免更改类名导致问题。</p>
<h2 id="3-gda"><a href="#3-gda" class="headerlink" title="3.gda"></a>3.gda</h2><p>下载地址：<a href="http://www.gda.wiki:9090/">http://www.gda.wiki:9090/</a></p>
<p>使用free版本</p>
<h2 id="4-jeb"><a href="#4-jeb" class="headerlink" title="4. jeb"></a>4. jeb</h2><p><strong>JAD与JEB的比较</strong></p>
<p>1.JAD可能反编译出的代码绿色注释部分不完整，反编译能力较弱。 </p>
<p>2.JEB反编译能力更强，适用于JAD反编译失败的APP。 </p>
<p>3.在JAD或JEB无法反编译的情况下，可以尝试使用定制ART虚拟机直接输出运行过程中的SMILE代码和寄存器参数进行分析。</p>
<p><strong>JEB的安装与使用</strong></p>
<p>1.下载JEB 4.2版本，解压后将jab.exe替换到bin目录下。 </p>
<p>2.双击jab.exe打开软件，接受协议并生成key。 </p>
<p>3.确保替换掉原jb.exe文件后，生成的东西才有用。 </p>
<p>4.软件界面延迟到2033年，可以通过拖入文件进行反编译。 </p>
<p>5.在Edit菜单下选择Language，可以切换到中文界面。 </p>
<p>6.反编译出的JAVA代码可以在Smart Code区域查看，搜索和跳转功能也十分便捷。 </p>
<p>7.JEB需要使用到JDK，并且JDK的大小目前最大为4GB，可以通过配置文件进行修改。</p>
<h2 id="5-apktool"><a href="#5-apktool" class="headerlink" title="5. apktool"></a>5. apktool</h2><p>官方地址<a href="https://maximoff.su/**apktool**/?history=1&lang=zh">https://maximoff.su/**apktool**/?history=1&amp;lang=zh</a></p>
<h2 id="6-frida"><a href="#6-frida" class="headerlink" title="6.frida"></a>6.frida</h2><ul>
<li>frida-server 安装（Android）: <a href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>frida-tools 安装：<a href="https://frida.re/docs/installation/">https://frida.re/docs/installation/</a></li>
<li>frida 官方网站: <a href="https://frida.re/">https://frida.re/</a></li>
<li>frida 官方文档：<a href="https://frida.re/docs/">https://frida.re/docs/</a></li>
</ul>
<p>本次安装涉及Frida 的两个组件，一个是安装到手机或模拟器中的: <code>frida-server</code>，另外就是装在电脑上用于逆向分析的：<code>frida-tools</code>。</p>
<h4 id="frida-server-安装"><a href="#frida-server-安装" class="headerlink" title="frida-server 安装"></a><code>frida-server</code> 安装</h4><p>安装方法参考：<a href="https://blog.csdn.net/weixin_45320254/article/details/126215490">最新2023：Frida完美安装方案_frida-server下载-CSDN博客</a></p>
<p>关键步骤：</p>
<p>将解压之后的文件push到设备中，指定到 &#x2F;data&#x2F;local&#x2F;tmp 路径下重命名为 frida-server。</p>
<p>终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\&gt; adb push C:\Users\xxx\Desktop\frida-server-15.2.2-android-x86_64 /data/local/tmp/frida-server</span><br><span class="line">C:\Users\xxx\Desktop\frida-server-15.2.2-android-x86...le pushed, 0 skipped. 19.4 MB/s (99542760 bytes in 4.882s)    </span><br></pre></td></tr></table></figure>

<p>命令行运行android设备中的frida-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\&gt; adb shell   // 进入手机</span><br><span class="line">VOG-AL00:/ # su    // 确定手机是root权限</span><br><span class="line">VOG-AL00:/ # cd /data/local/tmp      // 进入到tmp目录下</span><br><span class="line">VOG-AL00:/data/local/tmp # chmod 777 frida-server      // 给执行权限，可读可写可执行</span><br><span class="line">VOG-AL00:/data/local/tmp # ./frida-server      //正式启动frida-server</span><br></pre></td></tr></table></figure>

<p><code>提示：执行完毕后为运行状态。这个shell不能关闭，关闭了frida就停止了。</code></p>
<p>应用参考：<a href="https://blog.csdn.net/qq_38474570/article/details/120876120">Android之Frida框架完全使用指南_android frida-CSDN博客</a></p>
<h4 id="安装-FRIDA-DEXDump"><a href="#安装-FRIDA-DEXDump" class="headerlink" title="安装 FRIDA-DEXDump"></a><strong>安装 FRIDA-DEXDump</strong></h4><p>从 GitHub 仓库克隆项目并安装：</p>
<p>手动下载<a href="https://github.com/hluwa/frida-dexdump">frida-dexdump</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hluwa/FRIDA-DEXDump.git</span><br><span class="line"><span class="built_in">cd</span> FRIDA-DEXDump</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1945680&highlight=Frida">Frida 安装 - 吾爱破解 </a></p>
<p>逆向过程中，借助<strong>Frida</strong> 可以更快的实现软件的逆向破解，Frida不仅可以实现Android应用的逆向，对于IOS应用，Windows应用同样可以实现不错的效果本文可能由于frida 代码的不断更新，可能出现某些错误或者过时，大家尽量以官方文档为主：</p>
<ul>
<li>frida-server 安装（Android）: <a href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>frida-tools 安装：<a href="https://frida.re/docs/installation/">https://frida.re/docs/installation/</a></li>
<li>frida 官方网站: <a href="https://frida.re/">https://frida.re/</a></li>
<li>frida 官方文档：<a href="https://frida.re/docs/">https://frida.re/docs/</a></li>
</ul>
<p>本次安装涉及Frida 的两个组件，一个是安装到手机或模拟器中的: <code>frida-server</code>，另外就是装在电脑上用于逆向分析的：<code>frida-tools</code>。</p>
<h4 id="frida-server-安装-1"><a href="#frida-server-安装-1" class="headerlink" title="frida-server 安装"></a><code>frida-server</code> 安装</h4><p>frida-server 本质上是一个二进制文件，将其拷贝到需要进行hook的系统中运行即可，下面以Android系统为例：</p>
<p>首先需要从 <strong>github</strong> 的仓库中下载编译好的 frida-server 文件。仓库地址：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>从Release中下载对应版本的文件即可。frida-server的命名规则为：<code>frida-server-&#123;版本号&#125;-&#123;支持的系统&#125;-&#123;CPU架构&#125;.&#123;压缩文件扩展名&#125;</code></p>
<p>认准自己手机或模拟器的架构下载即可。例如我是 arm64 的 Android 手机，那么我就下载 <code>frida-server-16.4.5-android-arm64.xz</code> 即可</p>
<p>下载到合适的frida-server后，使用<code>adb push</code>命令将二进制文件推送到目标设备中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>如果推送不成功，也可以先推送到 <code>/sdcard/</code> 目录后，再使用 <code>adb shell</code>将 frida-server 复制到 <code>/data/local/tmp/</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">mv /sdcard/frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>推送完成后，使用：<code>adb shell</code>命令进入shell，并赋予 <code>frida-server</code> 可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure>

<p>上述工作都做完后，可以启动 <code>frida-server</code>了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">./frida-server</span><br></pre></td></tr></table></figure>

<p><code>frida-server</code>启动后不会有任何屏幕的提示信息。请注意这个命令行窗口不要关闭，如果命令窗口关闭后，<code>frida-server</code> 也会关闭</p>
<h4 id="frida-tools-安装"><a href="#frida-tools-安装" class="headerlink" title="frida-tools 安装"></a><code>frida-tools</code> 安装</h4><p>需要注意的是，上文提到的 frida-server 需与 frida 版本保持一致，安装 <code>frida-tools</code> 时又会自动安装 <code>frida</code> 。那么如何得知 <code>frida-tools</code> 版本呢？</p>
<p>首先打开 frida 仓库：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a>, 在 Release 中寻找 frida 版本并查找到 frida 的发布日期</p>
<p>获取到 frida 发布日期后，打开 frida-tools 仓库：<a href="https://github.com/frida/frida-tools">https://github.com/frida/frida-tools</a> 寻找上述 frida 发布日期的相同或之后的一个 frida-tools 版本，请记住这个版本号！</p>
<p>以 Windows 系统为例，电脑中需要存在Python环境：</p>
<p>使用以下命令安装 <code>frida-tools</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">pip3 install frida-tools==&#123;frida-tools版本号&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>安装 <code>frida-tools</code> 时会自动安装 <code>frida</code> 所以不要像网上某些教程教的一样分别安装, 不然有可能会出现安装失败或安装后运行时报错等问题！</p>
</blockquote>
<p>如果安装时出现网络连接问题，或者一些与网络相关的错误，请多试几遍，也可使用以下方法：</p>
<ul>
<li>使用 <code>-i</code> 参数指定软件源：<code>pip3 install frida-tools==&#123;frida-tools版本号&#125; -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>使用 <code>--proxy</code> 参数: <code>pip3 install frida-tools==&#123;frida-tools版本号&#125; --proxy=&#39;socks5://127.0.0.1:7890&#39;</code></li>
</ul>
<p>安装完成后，使用命令<code>frida-ps</code> 命令验证是否安装成功：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  ----------------------------</span></span><br><span class="line"><span class="function">  832  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">27076  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">30132  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">22788  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">21040  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">30480  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function"> 1872  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">13060  <span class="title">conhost.exe</span></span></span><br><span class="line"><span class="function"> 1880  <span class="title">dllhost.exe</span></span></span><br><span class="line"><span class="function"> 8544  <span class="title">explorer.exe</span></span></span><br><span class="line"><span class="function">13700  <span class="title">frida</span>-<span class="title">ps.exe</span></span></span><br><span class="line"><span class="function">15032  <span class="title">nvcontainer.exe</span></span></span><br><span class="line"><span class="function">26740  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">27464  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">26948  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 2076  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 9824  <span class="title">sihost.exe</span></span></span><br><span class="line"><span class="function"> 9860  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9868  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9928  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">11208  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">20020  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">10020  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">10084  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<p>执行命令后出现的就是当前机器的进程列表，证明 <code>frida-tools</code> 单独运行是没问题的。那么如何测试是否能正确的与运行在手机或模拟器中的<code>frida-server</code>通信呢？</p>
<p>将手机与电脑连接后，按照上文说的启动 <code>frida-server</code> ，在命令行中使用 <code>frida-ps -U</code>命令查看手机进程：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span> -<span class="title">U</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  --------------------------------------------</span></span><br><span class="line"><span class="function">  683  <span class="title">ATFWD</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">24558  <span class="title">adbd</span></span></span><br><span class="line"><span class="function">  672  <span class="title">adsprpcd</span></span></span><br><span class="line"><span class="function">  686  <span class="title">alipayservice</span></span></span><br><span class="line"><span class="function">11860  <span class="title">android.process.acore</span></span></span><br><span class="line"><span class="function">22740  <span class="title">android.process.contacts</span></span></span><br><span class="line"><span class="function">11653  <span class="title">android.process.media</span></span></span><br><span class="line"><span class="function">  690  <span class="title">audiod</span></span></span><br><span class="line"><span class="function">  664  <span class="title">bspCriticalLog</span></span></span><br><span class="line"><span class="function">  662  <span class="title">cnd</span></span></span><br><span class="line"><span class="function">  680  <span class="title">cnss</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">12137  <span class="title">com.amap.android.location</span></span></span><br><span class="line"><span class="function">12262  <span class="title">com.android.incallui</span></span></span><br><span class="line"><span class="function">24490  <span class="title">com.android.keyguard</span></span></span><br><span class="line"><span class="function">22711  <span class="title">com.android.mms</span></span></span><br><span class="line"><span class="function">12125  <span class="title">com.android.phone</span></span></span><br><span class="line"><span class="function">14538  <span class="title">com.android.providers.downloads</span></span></span><br></pre></td></tr></table></figure>

<p>如果执行结果如上所示，那么基本上 frida 安装已经成功了，如果出现错误，请仔细检查以上的所有步骤是否正确。</p>
<h2 id="7-BinaryNinja"><a href="#7-BinaryNinja" class="headerlink" title="7.BinaryNinja"></a>7.BinaryNinja</h2><h2 id="8-010-Editor"><a href="#8-010-Editor" class="headerlink" title="8.010 Editor"></a>8.010 Editor</h2><p>16进制文件编辑工具，以16进制方式打开文件。</p>
<p><strong>总的（包含linux和windows以及破解软件）：</strong><br>链接：<a href="https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu">https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu</a><br>提取码：1ynu</p>
<p>参考：<a href="https://blog.csdn.net/NS_ice/article/details/132398846">010editor的安装与基本操作-CSDN博客</a></p>
<h2 id="9-Ghidra"><a href="#9-Ghidra" class="headerlink" title="9.Ghidra"></a>9.Ghidra</h2><p>参考：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2020073&highlight=Ghidra">逆向分析工具GhidraMCP 吾爱破解</a></p>
<pre><code>   [《Ghidra简介及使用方法》学习 - 吾爱破解](https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1793425&amp;highlight=Ghidra)
</code></pre>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a><strong>下载地址</strong>：</h3><p>从 GitHub Releases 下载对应系统的压缩包（如 <code>ghidra_11.0_PUBLIC_YYYYMMDD.zip</code>）。</p>
<p><strong>解压文件</strong>：</p>
<ul>
<li><p><strong>Windows</strong>：使用 WinRAR、7-Zip 或系统自带解压工具。</p>
</li>
<li><p><strong>Linux&#x2F;macOS</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip ghidra_11.0_PUBLIC_*.zip -d ~/ghidra</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h3><h4 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a><strong>Java 环境</strong></h4><p>Ghidra 需要 **Java 11+**（推荐 OpenJDK 11）：</p>
<ul>
<li><p><strong>Windows&#x2F;macOS</strong>：</p>
<ul>
<li>下载并安装 <a href="https://adoptium.net/">Adoptium Temurin JDK 11</a>。</li>
</ul>
</li>
<li><p><strong>Linux</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk  # Ubuntu/Debian</span><br><span class="line">sudo dnf install java-11-openjdk # Fedora</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证-Java-版本"><a href="#验证-Java-版本" class="headerlink" title="验证 Java 版本"></a><strong>验证 Java 版本</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version  # 输出应包含 &quot;openjdk 11.0.x&quot;</span><br></pre></td></tr></table></figure>

<h3 id="启动-Ghidra"><a href="#启动-Ghidra" class="headerlink" title="启动 Ghidra"></a><strong>启动 Ghidra</strong></h3><p><strong>Windows</strong></p>
<ol>
<li>进入解压后的目录 <code>ghidra_11.0/</code>。</li>
<li>双击运行 **<code>ghidraRun.bat</code>**（可能需要管理员权限）</li>
</ol>
<h4 id="Linux-macOS"><a href="#Linux-macOS" class="headerlink" title="Linux&#x2F;macOS"></a><strong>Linux&#x2F;macOS</strong></h4><ol>
<li><p>打开终端，进入解压目录：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/ghidra/ghidra_11.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋予执行权限并启动：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ghidraRun</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="首次配置"><a href="#首次配置" class="headerlink" title="首次配置"></a><strong>首次配置</strong></h3><ol>
<li><strong>选择工作目录</strong>：<ul>
<li>首次启动时，Ghidra 会提示设置项目目录（默认 <code>~/ghidra_projects</code>）。</li>
</ul>
</li>
<li><strong>接受许可协议</strong>：<ul>
<li>阅读并同意 Ghidra 的许可条款。</li>
</ul>
</li>
</ol>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><p><strong>（1）创建项目</strong></p>
<ol>
<li>点击 **<code>File &gt; New Project</code>**。</li>
<li>选择 **”Non-Shared Project”**（个人项目），输入项目名称（如 <code>MyFirstProject</code>）。</li>
</ol>
<p><strong>（2）导入文件</strong></p>
<ol>
<li>在项目窗口中，右键点击项目名 → **<code>Import File</code>**。</li>
<li>选择要分析的二进制文件（如 <code>.exe</code>、<code>.elf</code>、<code>.dll</code>）。</li>
<li>保持默认选项，点击 **”Import”**。</li>
</ol>
<p><strong>（3）分析代码</strong></p>
<ol>
<li>双击导入的文件，Ghidra 会提示是否分析 → 点击 **”Yes”**。</li>
<li>选择分析选项（默认勾选所有），点击 **”Analyze”**：<ul>
<li><strong>反编译</strong>：查看伪代码（按 <code>F</code> 聚焦到函数）。</li>
<li><strong>字符串搜索</strong>：在 <code>Defined Strings</code> 列表查找线索（如 <code>flag&#123;</code>）。</li>
<li><strong>交叉引用（XRefs）</strong>：右键点击函数或变量 → **”References”**。</li>
</ul>
</li>
</ol>
<p><strong>（4）常用快捷键</strong></p>
<ul>
<li><code>F</code>：聚焦到当前函数。</li>
<li><code>G</code>：跳转到地址。</li>
<li><code>Ctrl + F</code>：在当前视图搜索文本。</li>
<li><code>;</code>：添加注释。</li>
</ul>
<hr>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a><strong>高级功能</strong></h3><p><strong>（1）脚本与插件</strong></p>
<ul>
<li><strong>脚本</strong>：在 <code>Window &gt; Script Manager</code> 中运行 Python 脚本（如自动解密算法）。</li>
<li><strong>插件</strong>：将插件放入 <code>ghidra_11.0/Ghidra/Extensions</code> 目录并重启。</li>
</ul>
<p><strong>（2）版本控制</strong></p>
<ul>
<li>支持通过 Git 管理项目（需手动配置）。</li>
</ul>
<p><strong>（3）反编译优化</strong></p>
<ul>
<li>在反编译窗口右键 → <strong>“Rename Variable”</strong> 或 <strong>“Retype Variable”</strong> 提高可读性。</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><p><strong>（1）启动报错 “No suitable Java version found”</strong></p>
<ul>
<li><strong>原因</strong>：未安装 Java 11 或环境变量配置错误。</li>
<li><strong>解决</strong>：<ul>
<li>检查 <code>java -version</code> 是否为 JDK 11。</li>
<li>手动指定 Java 路径（编辑 <code>ghidraRun</code> 脚本）。</li>
</ul>
</li>
</ul>
<p><strong>（2）分析卡死</strong></p>
<ul>
<li><strong>原因</strong>：大文件分析内存不足。</li>
<li><strong>解决</strong>：<ul>
<li>修改 <code>ghidraRun</code> 中的内存参数（如 <code>MAXMEM=4096M</code>）。</li>
</ul>
</li>
</ul>
<p><strong>（3）中文乱码</strong></p>
<ul>
<li><strong>解决</strong>：<ul>
<li>在反汇编视图右键 → <strong>“Options &gt; Listing Fields”</strong> → 修改字体为支持中文的字体（如宋体）。</li>
</ul>
</li>
</ul>
<h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a><strong>学习资源</strong></h3><ul>
<li><strong>官方文档</strong>：<br>  <a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a></li>
<li><strong>入门教程</strong>：<br>  <a href="https://ghidra.re/ghidra_docs/Introductory_Tutorial.html">Ghidra 官方入门指南</a></li>
<li><strong>社区支持</strong>：<br>  <a href="https://github.com/NationalSecurityAgency/ghidra/discussions">Ghidra 官方论坛</a></li>
</ul>
<h2 id="10-HxD-Hex"><a href="#10-HxD-Hex" class="headerlink" title="10.HxD_Hex"></a>10.HxD_Hex</h2><p>HxD Hex Editor 是一款功能强大的十六进制编辑器和磁盘编辑器，它可以让你直接查看和编辑二进制文件的内容。你可以使用HxD Hex Editor来分析、修改和处理各种数据格式，包括程序文件、磁盘映像、内存转储以及其他二进制文件。</p>
<p>下载地址：<a href="https://mh-nexus.de/en/hxd">HxD | https://mh-nexus.de/en/hxd</a></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><ol>
<li><p>以十六进制表示方式显示文件内容，并允许直接编辑其中的字节</p>
</li>
<li><p>支持将数据按特定数据类型进行解析和显示，方便对结构化数据进行编辑和分析。</p>
<p> 视图  &gt;&gt;  位置显示数制、数据显示、字节分组大小</p>
</li>
<li><p>可用于比较两个文件的差异，以找出变更或修改的部分。</p>
<p> 将两个图像的数据进行对比</p>
</li>
<li><p>可以执行文本或二进制数据的搜索和替换操作，帮助定位和修改特定的数据。</p>
<p> 搜索  &gt;&gt;  搜索（Ctrl+F）……</p>
</li>
<li><p>支持将数据导入到文件中或将文件导出为不同的数据格式</p>
<p> 文件 &gt;&gt;  导出  &gt;&gt;  ……</p>
</li>
<li><p>能够处理非常大的文件，并且在编辑和浏览时保持快速响应。</p>
</li>
</ol>
<p>了解更多详情：<a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a></p>
<p>用途<br>HxD Hex Editor通常用于以下几个方面：</p>
<p>1）帮助软件开发人员进行反汇编、调试和逆向工程。查看和修改程序的二进制代码，以理解其内部结构、修复漏洞或进行功能定制。</p>
<p>2）对于受损的文件或存储介质，HxD Hex Editor可以帮助您直接浏览并修复数据错误。查看和编辑二进制数据来识别并修复文件中的损坏部分，如磁盘映像、内存转储等。</p>
<p>3）HxD Hex Editor提供了强大的数据分析和处理功能，一些游戏会使用二进制文件格式来存储游戏数据。</p>
<h2 id="11-upx"><a href="#11-upx" class="headerlink" title="11.upx"></a>11.upx</h2><h2 id="12-XVolkolak"><a href="#12-XVolkolak" class="headerlink" title="12.XVolkolak"></a>12.XVolkolak</h2><h2 id="13-radare2"><a href="#13-radare2" class="headerlink" title="13.radare2"></a>13.radare2</h2><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><p>安装radare2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y gcc make cmake curl git  gcc-multilib</span><br><span class="line">git clone https://github.com/radare/radare2.git</span><br><span class="line">cd radare2</span><br><span class="line">./sys/install.sh</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line"></span><br><span class="line">make uninstall</span><br><span class="line">make purge</span><br></pre></td></tr></table></figure>

<h3 id="window环境"><a href="#window环境" class="headerlink" title="window环境"></a>window环境</h3><p>参考：</p>
<p><a href="https://bbs.kanxue.com/thread-225529.htm">在Windows平台下的使用radare2进行调试-外文翻译-看雪</a></p>
<p>在Windows上安装Radare2并配置r2pipe库的步骤如下：</p>
<h3 id="下载正确的文件"><a href="#下载正确的文件" class="headerlink" title="下载正确的文件"></a><strong>下载正确的文件</strong></h3><p>访问 <a href="https://github.com/radareorg/radare2/releases/tag/5.9.8">Radare2 5.9.8 发布页面</a>，在 <strong>Assets</strong> 部分找到以下文件：</p>
<ul>
<li><strong><code>radare2-5.9.8-w64.zip</code></strong><ul>
<li>这是 <strong>64 位 Windows 系统</strong>的预编译版本，适用于天选2笔记本（现代笔记本通常为 64 位系统）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><strong>安装步骤</strong></h3><ol>
<li><p><strong>下载文件</strong>：点击 <code>radare2-5.9.8-w64.zip</code> 下载压缩包。</p>
</li>
<li><p><strong>解压文件</strong>：将压缩包解压到任意目录（例如 <code>C:\radare2</code>）。</p>
</li>
<li><p><strong>配置环境变量</strong>：</p>
<ul>
<li>将 Radare2 的 <code>bin</code> 目录（如 <code>C:\radare2\bin</code>）添加到系统 <code>PATH</code> 环境变量。</li>
<li><strong>步骤</strong>：<ol>
<li>右键点击“此电脑” → 属性 → 高级系统设置 → 环境变量 → 编辑系统变量 <code>Path</code> → 添加 <code>C:\radare2\bin</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>验证安装</strong>：</p>
<ul>
<li><p>打开命令提示符（CMD 或 PowerShell），输入：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r2 -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出应显示版本信息：<code>radare2 5.9.8 ...</code>。</p>
</li>
</ul>
</li>
<li><p>打开命令提示符（CMD）或PowerShell，并导航至Radare2所在目录。使用以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\radare2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该目录下执行以下命令来运行Radare2：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r2.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p>这将启动Radare2交互式环境。</p>
<p> 验证Radare2是否正确安装。在Radare2交互式环境中，输入<code>?</code>或<code>help</code>命令查看帮助文档。</p>
<p> 接下来，您可以通过pip来安装r2pipe库。请确保您已经安装了Python和pip。</p>
<p> 打开命令提示符或PowerShell，并运行以下命令来安装r2pipe库：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install r2pipe</span><br></pre></td></tr></table></figure>

<p> 安装完成后，您可以在Python脚本中导入并使用r2pipe库与已安装的Radare2进行交互了。</p>
</li>
</ol>
<p>以上是在Windows上安装和配置Radare 2及r2pipe库的基本步骤。根据系统和安装方式，可能会有细微差异，请参考官方文档或社区支持寻求更详细的帮助。</p>
<p>安装程序都将radare2.exe以及其他工具放在C：&#x2F;users &#x2F;username &#96;&#96;&#x2F; AppData目录中。 我必须从命令行将目录切换到该文件夹才能使用可执行文件。 为了从命令行的任何位置访问该文件，必须将该目录添加到$ PATH环境变量中。 这计算机用来查找可以从系统的任何位置运行的命令和应用程序的变量。<br>要设置你的$ PATH变量，你可以通过以下两种方法之一来完成。 您可以通过转到系统属性 -&gt;高级 -&gt;环境变量来使用Windows GUI进行更改，单击路径变量并单击编辑。 然后你可以添加你的radare2文件的目录。</p>
<h3 id="命令行使用方法"><a href="#命令行使用方法" class="headerlink" title="命令行使用方法"></a>命令行使用方法</h3><p>Radare2 在命令行下有一些小工具可供使用：</p>
<ul>
<li>radare2：十六进制编辑器和调试器的核心，通常通过它进入交互式界面。</li>
<li>rabin2：从可执行二进制文件中提取信息。</li>
<li>rasm2：汇编和反汇编。</li>
<li>rahash2：基于块的哈希工具。</li>
<li>radiff2：二进制文件或代码差异比对。</li>
<li>rafind2：查找字节模式。</li>
<li>ragg2：r_egg 的前端，将高级语言编写的简单程序编译成x86、x86-64和ARM的二进制文件。</li>
<li>rarun2：用于在不同环境中运行程序。</li>
<li>rax2：数据格式转换。</li>
</ul>
<h4 id="radare2-r2"><a href="#radare2-r2" class="headerlink" title="radare2&#x2F;r2"></a>radare2&#x2F;r2</h4><p>参数很多，这里最重要是 <code>file</code>。如果想 attach 到一个进程上，则使用 <code>pid</code>。常用参数如下：</p>
<ul>
<li><code>-A</code>：相当于在交互界面输入了 <code>aaa</code>。</li>
<li><code>-c</code>：运行 radare 命令。（<code>r2 -A -q -c &#39;iI~pic&#39; file</code>）</li>
<li><code>-d</code>：调试二进制文件或进程。</li>
<li><code>-a</code>,<code>-b</code>,<code>-o</code>：分别指定体系结构、位数和操作系统，通常是自动的，但也可以手动指定。</li>
<li><code>-w</code>：使用可写模式打开。</li>
</ul>
<h4 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h4><p>拿到一个二进制文件时，第一步就是获取关于它的基本信息，这时候就可以使用 rabin2。rabin2 可以获取包括 ELF、PE、Mach-O、Java CLASS 文件的区段、头信息、导入导出表、数据段字符串、入口点等信息，并且支持多种格式的输出。</p>
<p>下面介绍一些常见的用法：</p>
<ul>
<li><code>-I</code>：最常用的参数，它可以打印出二进制文件信息，其中我们需要重点关注其使用的安全防护技术，如 canary、pic、nx 等。（<code>file</code>、<code>chekcsec -f</code>）</li>
<li><code>-e</code>：得到二进制文件的入口点。（｀readelf -h&#96;）</li>
<li><code>-i</code>：获得导入符号表，RLT中的偏移等。（<code>readelf -r</code>）</li>
<li><code>-E</code>：获得全局导出符号表。</li>
<li><code>-s</code>：获得符号表。（<code>readelf -s</code>）</li>
<li><code>-l</code>：获得二进制文件使用到的动态链接库。（<code>ldd</code>）</li>
<li><code>-z</code>：从 ELF 文件的 .rodare 段或 PE 文件的 .text 中获得字符串。（<code>strings -d</code>）</li>
<li><code>-S</code>：获得完整的段信息。（<code>readelf -S</code>）</li>
<li><code>-c</code>：列出所有类，在分析 Java 程序是很有用。</li>
</ul>
<p>最后还要提到的一个参数 <code>-r</code>，它可以将得到的信息以 radare2 可读的形式输出，在后续的分析中可以将这样格式的信息输入 radare2，这是非常有用的。</p>
<h4 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h4><p>rasm2 是一个内联汇编、反汇编程序。它的主要功能是获取给定机器指令操作码对应的字节。</p>
<p>下面是一些重要的参数：</p>
<ul>
<li><code>-L</code>：列出目标体系结构所支持的插件，输出中的第一列说明了插件提供的功能（a&#x3D;asm, d&#x3D;disasm, A&#x3D;analyze, e&#x3D;ESIL）。</li>
<li><code>-a</code>：知道插件的名字后，就可以使用 -a&#96; 来进行设置。</li>
<li><code>-b</code>：设置CPU寄存器的位数。</li>
<li><code>-d</code>：反汇编十六进制对字符串。</li>
<li><code>-D</code>：反汇编并显示十六进制对和操作码。</li>
<li><code>-C</code>：汇编后以 C 语言风格输出。</li>
<li><code>-f</code>：从文件中读入汇编代码。</li>
</ul>
<h4 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h4><p>rahash2 用于计算检验和，支持字节流、文件、字符串等形式和多种算法。</p>
<p>重要参数：</p>
<ul>
<li><code>-a</code>：指定算法。默认为 sha256，如果指定为 all，则使用所有算法。</li>
<li><code>-b</code>：指定块的大小（而不是整个文件）</li>
<li><code>-B</code>：打印处每个块的哈希</li>
<li><code>-s</code>：指定字符串（而不是文件）</li>
<li><code>-a entropy</code>：显示每个块的熵（<code>-B -b 512 -a entropy</code>）</li>
</ul>
<h4 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h4><p>radiff2 是一个基于偏移的比较工具。</p>
<p>重要参数：</p>
<ul>
<li><p><code>-s</code>：计算文本距离并得到相似度。</p>
</li>
<li><p><code>－AC</code>：这两个参数通常一起使用，从函数的角度进行比较。</p>
</li>
<li><pre><code>  -g
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	：得到给定的符号或两个偏移的图像对比。</span><br><span class="line"></span><br><span class="line">	- 如：`radiff2 -g main a.out b.out | xdot -`（需要安装xdot）</span><br><span class="line"></span><br><span class="line">- `-c`：计算不同点的数量。</span><br><span class="line"></span><br><span class="line">#### rafind2</span><br><span class="line"></span><br><span class="line">rafind2 用于在二进制文件中查找字符模式。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-s`：查找特定字符串。</span><br><span class="line">- `-e`：使用正则匹配。</span><br><span class="line">- `-z`：搜索以`\0`结束的字符串。</span><br><span class="line">- `-x`：查找十六进制字符串。</span><br><span class="line"></span><br><span class="line">#### ragg2</span><br><span class="line"></span><br><span class="line">ragg2 可以将高级语言编写的简单程序编译成 x86、x86-64 或 ARM 的二进制文件。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-a`：设置体系结构。</span><br><span class="line">- `-b`：设置体系结构位数(32/64)。</span><br><span class="line">- `-P`：生成某种模式的字符串，常用于输入到某程序中并寻找溢出点。</span><br><span class="line">- -r：使用原始字符而不是十六进制对。</span><br><span class="line">	- ragg2 -P 50 -r`</span><br><span class="line">- -i：生成指定的 shellcode。查看-L。</span><br><span class="line">	- `ragg2 -a x86 -b 32 -i exec`</span><br><span class="line">- `-e`：使用指定的编码器。查看 `-L`。</span><br><span class="line"></span><br><span class="line">#### rarun2</span><br><span class="line"></span><br><span class="line">rarun2 是一个可以使用不同环境、参数、标准输入、权限和文件描述符的启动器。</span><br><span class="line"></span><br><span class="line">常用的参数设置：</span><br><span class="line"></span><br><span class="line">- `program`</span><br><span class="line">- `arg1`, `arg2`,…</span><br><span class="line">- `setenv`</span><br><span class="line">- `stdin`, `stdout`</span><br><span class="line"></span><br><span class="line">#### rax2</span><br><span class="line"></span><br><span class="line">rax2 是一个格式转换工具，在二进制、八进制、十六进制数字和字符串之间进行转换。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-e`：交换字节顺序</span><br><span class="line">- `-s`：十六进制-&gt;字符</span><br><span class="line">- `-S`：字符-&gt;十六进制</span><br><span class="line">- `-D`, `-E`：base64 解码和编码</span><br><span class="line"></span><br><span class="line">## 14.Strings</span><br><span class="line"></span><br><span class="line">## ZipRepair</span><br><span class="line"></span><br><span class="line">## x64dbg</span><br><span class="line"></span><br><span class="line">x64dbg 是一款开源的、目前仍在积极开发中的 x32/x64 位动态调试器。其界面及操作方法与 [OllyDbg](https://www.52pojie.cn/thread-350397-1-1.html) 类似，和 OllyDbg 不同的是它可以对 64 位程序进行调试。此外，其开放式的设计给了此软件很强的生命力。通过爱好者们不断的修改和扩充，使其功能越来越强大。</span><br><span class="line">该调试器(目前)有三部分：DBG、GUI、Bridge：</span><br><span class="line">DBG 是调试器的调试部分。它处理调试技术(使用 TitanEngine 引擎，近来还新增了 Gleebug 引擎)，并为 GUI 提供数据。</span><br><span class="line">GUI 是调试器的图形部分。它建立在 Qt 上，并提供用户交互界面。</span><br><span class="line">Bridge 是 DBG 和 GUI 部分的通信库(将来也许是在更多的部件之间)。Bridge 可用于在新建功能上工作，而无需更新代码的其他部分。</span><br><span class="line"></span><br><span class="line">**汉化修订说明：**</span><br><span class="line"></span><br><span class="line">1. 对 x64dbg 帮助文档的主要内容进行了汉化，并按照最新版进行了修订、补译。对界面字体以及布局重新进行了设置。将默认调用在线英文帮助更改为调用本地中文帮助文件。</span><br><span class="line">2. 为帮助用户更好地了解 x64dbg 反汇编后的 CPU 汇编指令信息，对汇编指令的“助记符摘要”全部进行了汉化。对“助记符帮助”进行了部分汉化。汇编指令的汉化参考了“清华大学出版社”出版的《汇编语言程序设计教程》(第4版) 中术语，因此可能与其他软件的汉化术语略有不同。</span><br><span class="line">3. 对 Scylla 插件等进行了全面汉化。</span><br><span class="line">4. 对 x64dbg 官方中文版的汉化错误及不一致处进行了修订，并与帮助文档的关键词进行了统一。</span><br><span class="line">5. 对中文版界面的字体进行了重新设置，使其更为美观。</span><br><span class="line">6. 对“暗黑”主题界面颜色的默认值进行了调整，使代码显示更为清晰。并对主题的“选项&gt;外观”对话框中的“颜色”和“字体”标签的排列错位进行了调整。</span><br><span class="line">7. 本次更新集成了可在“CPU”界面搜索中文字符串引用的 x64dbg_tol 插件。</span><br><span class="line">8. 本次更新版本修改了启动条件，改为直接以管理员权限启动。</span><br><span class="line">9. 本次去除了新版本主程序的数字签名，解决了某些 DLL 文件的非标字串不能汉化的问题。</span><br><span class="line"></span><br><span class="line">在x64dbg中设置条件断点 – by elecs@看雪学院</span><br><span class="line">https://bbs.pediy.com/thread-251385.htm</span><br><span class="line"></span><br><span class="line">x64dbg Plugin Manager 第三方人员开发的插件管理器</span><br><span class="line">https://github.com/horsicq/x64dbg-Plugin-Manager</span><br><span class="line"></span><br><span class="line">官网：https://x64dbg.com/</span><br><span class="line"></span><br><span class="line">x64dbg官方下载地址（软件原版已经自带简体中文语言）</span><br><span class="line">https://github.com/x64dbg/x64dbg/releases</span><br><span class="line">https://sourceforge.net/projects/x64dbg/files/snapshots</span><br><span class="line"></span><br><span class="line">x64dbg 简体中文版(Jan 6 2024)： https://www.lanzouu.com/iuFXx1l65ush</span><br><span class="line"></span><br><span class="line">## IDA pro</span><br><span class="line"></span><br><span class="line">参考：[IDA Pro 9 安装和插件配置-安全工具-看雪](https://bbs.kanxue.com/thread-285604.htm#msg_header_h1_1)</span><br><span class="line"></span><br><span class="line">### IDA Pro 9.0.241217 SP1</span><br><span class="line"></span><br><span class="line">打包了配置好的IDA9 SP1,设置IDAPython路径即可使用</span><br><span class="line"></span><br><span class="line">附件:</span><br><span class="line"></span><br><span class="line">- IDAPlugins.zip</span><br><span class="line"></span><br><span class="line">- IdaPro9Beta-Keygen-iRabbit.py</span><br><span class="line"></span><br><span class="line">- IDA Professional 9.0.7z</span><br><span class="line"></span><br><span class="line">	链接: https://pan.baidu.com/s/1eCmxbP6nNHm5qz41rFbetg?pwd=5hdq</span><br><span class="line"></span><br><span class="line">参考如下步骤</span><br><span class="line"></span><br><span class="line">1. 运行ida-pro_90sp1_x64win.exe安装ida</span><br><span class="line">2. 修改IdaPro9Beta-Keygen-iRabbit.py文件的部分内容,复制到ida根目录</span><br><span class="line">3. python运行keygen,自动修补</span><br><span class="line">4. 修改patched文件后缀,替换ida.dll和ida32.dll(注意保存原始文件)</span><br><span class="line"></span><br><span class="line">### IDA Pro 9.1.250226</span><br><span class="line"></span><br><span class="line">相比之下9.1修了不少bug,分析程序更快更丝滑,还有signatures-bundle和IDA Feeds可以使用</span><br><span class="line"></span><br><span class="line">实测9.0的patch脚本可用于9.1,并且大部分9.0的插件可用于9.1,由于二者配置方法类似便不多赘述</span><br><span class="line"></span><br><span class="line">更新部分如下(2025/04/14):</span><br><span class="line"></span><br><span class="line">1. 初始化IDA</span><br><span class="line"></span><br><span class="line">	参考Binwalker师傅编写的7.7绿色版的IDA_InitTool</span><br><span class="line"></span><br><span class="line">	使用python实现禁用IDA自动更新和设置IDAPython路径的功能(默认使用嵌入的python3.11.9</span><br><span class="line"></span><br><span class="line">2. 配置和使用IDA Feeds插件</span><br><span class="line"></span><br><span class="line">	泄露文件中包括了符号库signatures-bundles-9.1.zip,物尽其用配置了一波该插件</span><br><span class="line"></span><br><span class="line">3. 配置和使用IDA MCP插件</span><br><span class="line"></span><br><span class="line">	实测自动化分析效果和WPeChatGPT差不多,但能看到分析过程,需要注意消耗的token更多</span><br><span class="line"></span><br><span class="line">提供配置好的IDA9.1压缩包,初次使用前运行InitIDA.exe后即可使用(WPeChatgpt需要手动配置api和模型)</span><br><span class="line">IDA Professional 9.1.7z 链接: https://pan.baidu.com/s/16Hk9FjEygb1yohUzblxdFw?pwd=8put 提取码: 8put</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **GDB（Linux）**</span><br><span class="line"></span><br><span class="line">1. 安装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  sudo apt install gdb
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 基础命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  gdb ./target         # 加载程序
  break main           # 在main函数下断点
  run                 # 运行
  ni                  # 单步执行
  info registers      # 查看寄存器
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># IDA Pro快速上手</span><br><span class="line"></span><br><span class="line">参考：[IDA Pro的使用CSDN](https://blog.csdn.net/Python_0011/article/details/146866529)</span><br><span class="line"></span><br><span class="line">来源：BUUCTF 	题目：easyre</span><br><span class="line"></span><br><span class="line">## 打开软件</span><br><span class="line"></span><br><span class="line">打开IDA，会看到 &quot;New&quot; 和 &quot;Go&quot; 两个选项。&quot;New&quot; 是直接打开程序，&quot;Go&quot; 是先启动 IDA 界面。</span><br><span class="line"></span><br><span class="line">选 &quot;Go&quot;，启动后，在菜单栏里点 &quot;File&quot; -&gt; &quot;Open&quot;，找到要分析的程序。然后会跳出个窗口，默认设置就好。</span><br><span class="line"></span><br><span class="line">### 加载文件配置窗口</span><br><span class="line"></span><br><span class="line">这个界面是一个IDA Pro或类似的逆向工程软件在加载可执行文件时显示的配置对话框。以下是各部分的解释：</span><br><span class="line"></span><br><span class="line">**1. 文件加载信息**</span><br><span class="line"></span><br><span class="line">- **`Load file F:\AA-Reversing\BUUCTF\easyre\easyre.exe as`**</span><br><span class="line">	表示正在加载的可执行文件路径和名称（`easyre.exe`），并询问以何种格式解析该文件。</span><br><span class="line">	提供的选项包括：</span><br><span class="line">	- **Portable executable for AMD64 (PE) [pe.dll]**：将文件解析为64位PE格式（Windows可执行文件）。</span><br><span class="line">	- **MS-DOS executable (EXE) [dos.dll]**：将文件解析为MS-DOS格式（旧版兼容模式）。</span><br><span class="line">	- **Binary file**：直接以二进制文件形式加载（无自动解析）。</span><br><span class="line"></span><br><span class="line">**2. 处理器类型（Processor type）**</span><br><span class="line"></span><br><span class="line">选择目标文件的CPU架构，通常工具会根据文件头自动识别，但也可手动调整。例如：</span><br><span class="line"></span><br><span class="line">- **Intel Pentium protected with MMX**：保护模式下的x86指令集（常见于Windows/Linux可执行文件）。</span><br><span class="line">- **Intel Pentium real with MMX**：实模式（常见于DOS程序）。</span><br><span class="line">- **MetaPC**：通用反汇编模式。</span><br><span class="line">- **Intel 860**：较少见的架构（通常不用于常规逆向）。</span><br><span class="line"></span><br><span class="line">**3. 加载段配置（Loading segment/offset）**</span><br><span class="line"></span><br><span class="line">- **Loading segment 0x0000000000000000**</span><br><span class="line">	指定代码段的起始地址（通常PE文件会从`0x00400000`开始，此处可能是默认值或手动输入）。</span><br><span class="line">- **Loading offset 0x0000000000000000**</span><br><span class="line">	指定文件在内存中的偏移量（与段地址配合使用）。</span><br><span class="line"></span><br><span class="line">**4. 分析选项（Analysis/Options）**</span><br><span class="line"></span><br><span class="line">- **Enabled**：是否启用自动分析（如识别函数、字符串等）。</span><br><span class="line">- **Create segments**：自动创建代码/数据段。</span><br><span class="line">- **Load resources**：加载PE文件的资源部分（如图标、字符串表）。</span><br><span class="line">- **Fill segment gaps**：填充段之间的空隙（对齐内存）。</span><br><span class="line">- **Create FLAT group**：将段合并为平坦内存模型（简化地址计算）。</span><br><span class="line">- **Manual load**：手动加载（高级用户自定义配置）。</span><br><span class="line"></span><br><span class="line">**5. 底部按钮**</span><br><span class="line"></span><br><span class="line">- **OK**：确认配置并加载文件。</span><br><span class="line">- **Cancel**：取消加载。</span><br><span class="line">- **Help**：查看帮助文档。</span><br><span class="line"></span><br><span class="line">**用户操作建议**</span><br><span class="line"></span><br><span class="line">1. **保持默认选项**：如果是标准的Windows PE文件（如`easyre.exe`），直接选择`Portable executable for AMD64`并点击`OK`。</span><br><span class="line">2. **手动调整**：若文件特殊（如加壳、混淆），可能需要修改处理器类型或关闭自动分析。</span><br><span class="line">3. **错误处理**：如果加载后代码混乱，可能是架构选错，需重新尝试其他选项。</span><br><span class="line"></span><br><span class="line">这个界面主要用于确保工具正确解析文件结构和指令集，是逆向工程的第一步。</span><br><span class="line"></span><br><span class="line">### **DWARF调试信息** 配置窗口</span><br><span class="line"></span><br><span class="line">检测到目标文件中包含 **DWARF调试信息** 时弹出的配置对话框。</span><br><span class="line"></span><br><span class="line">DWARF是一种常见的调试数据格式（主要用于ELF文件，如Linux/gcc编译的程序），包含函数名、变量类型、源代码行号等高级信息。以下是各选项的详细解释：</span><br><span class="line"></span><br><span class="line">**1. 核心选项**</span><br><span class="line"></span><br><span class="line">- **`Global names`**</span><br><span class="line">	加载全局变量和符号的名称（如`g_counter`）。勾选后，逆向时能看到更有意义的变量名。</span><br><span class="line">- **`Functions`**</span><br><span class="line">	**（默认勾选）** 加载函数名和边界信息（如`main()`、`sub_401000`会被替换为原始函数名）。</span><br><span class="line">- **`Use function bounds`**</span><br><span class="line">	严格按DWARF信息定义函数范围（避免工具错误分割函数）。</span><br><span class="line"></span><br><span class="line">**2. 类型与调用约定**</span><br><span class="line"></span><br><span class="line">- **`Types (uncheck for speed)`**</span><br><span class="line">	**（默认勾选）** 加载变量/结构体的类型信息（如`int`、`char*`）。取消勾选可加快加载速度，但会丢失类型提示。</span><br><span class="line">- **`Apply calling conventions`**</span><br><span class="line">	**（默认勾选）** 应用DWARF中记录的调用约定（如`cdecl`、`fastcall`），确保反汇编的调用逻辑准确。</span><br><span class="line">- **`Allow __usercall`**</span><br><span class="line">	**（默认勾选）** 支持非标准调用约定（如用户自定义的寄存器传参方式）。</span><br><span class="line">- **`Function prototypes are definitive`**</span><br><span class="line">	**（默认勾选）** 强制使用DWARF中的函数原型（覆盖工具的自动推断）。</span><br><span class="line"></span><br><span class="line">**3. 源代码关联**</span><br><span class="line"></span><br><span class="line">- **`Import file names/line numbers`**</span><br><span class="line">	关联源代码文件名和行号（需DWARF中包含编译路径信息）。勾选后，反汇编窗口可能显示类似`/home/user/src/main.c:10`的注释。</span><br><span class="line"></span><br><span class="line">**4. 底部按钮**</span><br><span class="line"></span><br><span class="line">- **`Yes`** 确认加载DWARF信息（推荐勾选所需选项后点击）。</span><br><span class="line">- **`No`** 忽略DWARF信息，仅按二进制文件分析。</span><br><span class="line"></span><br><span class="line">**用户操作建议**</span><br><span class="line"></span><br><span class="line">1. **常规逆向**：保持默认勾选（尤其是`Functions`和`Types`），以获取最大信息量。</span><br><span class="line">2. **性能优先**：若文件较大，可取消`Types`或`Import file names/line numbers`加速加载。</span><br><span class="line">3. **混淆/优化代码**：若DWARF信息可能被篡改（如某些CTF题目），可关闭`Function prototypes are definitive`，避免误导。</span><br><span class="line">4. **无源码调试**：即使勾选`Import file names/line numbers`，若DWARF中路径无效，则不会显示行号。</span><br><span class="line"></span><br><span class="line">### **为什么重要？**</span><br><span class="line"></span><br><span class="line">DWARF信息能极大提升逆向效率，例如：</span><br><span class="line"></span><br><span class="line">- 直接显示`main()`而非`sub_401000`。</span><br><span class="line">- 恢复结构体字段名（如`struct.user.name`）。</span><br><span class="line">- 识别库函数调用（如`strcpy`的参数类型）。</span><br><span class="line">	但需注意：**发布版本通常剥离DWARF**，此界面多见于开发/调试版本。</span><br><span class="line"></span><br><span class="line">## 窗口介绍</span><br><span class="line"></span><br><span class="line">主窗口界面：</span><br><span class="line"></span><br><span class="line">- **函数窗口 (Functions window)：**</span><br><span class="line"></span><br><span class="line">	在左侧的就是函数窗口，所有的后汉书都在此窗口列出。</span><br><span class="line"></span><br><span class="line">	拿到一个题目，一般从main函数开始，但main函数通常不会直接显示出来，所以需要点击窗口后用Ctrl+F搜一下。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/IDA_Functions%20window.png)</span><br><span class="line"></span><br><span class="line">- **汇编窗口 (IDA views):**</span><br><span class="line"></span><br><span class="line">	这块是汇编代码的地盘，有两种显示方式：</span><br><span class="line"></span><br><span class="line">	1.图形模式</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543842.png)</span><br><span class="line"></span><br><span class="line">	2.文本模式</span><br><span class="line"></span><br><span class="line">	在图形模式下，右键选 &quot;Text view&quot; 或者按空格键就能切换到文本模式。</span><br><span class="line"></span><br><span class="line">	展示汇编代码和地址。![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543843.png)</span><br><span class="line"></span><br><span class="line">	- **伪代码窗口：**</span><br><span class="line"></span><br><span class="line">		在汇编窗口文本模式中，对着函数按 `F5`，就能看到伪代码，把汇编语言变成了更易读的伪代码。</span><br><span class="line"></span><br><span class="line">	![image-20250505180517503](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/IDA_views%E4%BC%AA%E4%BB%A3%E7%A0%81.png)</span><br><span class="line"></span><br><span class="line">- **十六进制窗口：**</span><br><span class="line"></span><br><span class="line">	虽然叫“十六进制窗口”，但它其实能显示各种格式，还能当十六进制编辑器用。默认情况下，它会显示程序的十六进制代码和对应的 ASCII 字符，每行 16 个字节。可以同时打开好几个十六进制窗口。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051809928.png)</span><br><span class="line"></span><br><span class="line">- **消息窗口：**</span><br><span class="line"></span><br><span class="line">	会显示 IDA 输出的信息，比如文件分析状态、操作错误等等，就像 Pycharm 的 Console 控制台。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051810911.png)</span><br><span class="line"></span><br><span class="line">- **导航栏：**</span><br><span class="line"></span><br><span class="line">	导航栏就是那条彩色的水平带，它能线性地展示被加载文件的地址空间。默认情况下，它会显示整个二进制文件的地址范围。右击导航栏，会显示一个提示，告诉你光标所在位置对应二进制文件中的哪个位置。</span><br><span class="line"></span><br><span class="line">	简单来说，点哪儿跳哪儿，不同的颜色代表不同的数据段，比如 data 段、text 段等等。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051811379.png)</span><br><span class="line"></span><br><span class="line">## 修正</span><br><span class="line"></span><br><span class="line">IDA在加载文件的时候会有些错误，需要手动纠正。</span><br><span class="line"></span><br><span class="line">1. 函数修正：</span><br><span class="line"></span><br><span class="line">通常以 push ebp/rbp 指令开头的地址是函数的起始地址，但 IDA 有时会认错。这时候，在起始地址的汇编代码处，按快捷键 P (或者右键选 &quot;Create Function&quot;)，就能把它变成函数。</span><br><span class="line"></span><br><span class="line">2. 指令修正：</span><br><span class="line"></span><br><span class="line">如果 IDA 把某些指令识别错了，选中后按快捷键 D 就能手动修正。</span><br><span class="line"></span><br><span class="line">3. 数据修正：</span><br><span class="line"></span><br><span class="line">在数据段，一个数据的长度可能是 1/2/4/8 字节，用快捷键 D 可以修改类型。如果某部分数据是字符串但没被正确识别，按快捷键 A 就能把它变成 ASCII 字符串。</span><br><span class="line"></span><br><span class="line">## 注释和重命名</span><br><span class="line"></span><br><span class="line">- **重命名：**</span><br><span class="line"></span><br><span class="line">	在 IDA 里，你可以修改变量名、函数名等等，方便理解代码。在需要重命名的地方右键，选 &quot;Rename&quot; 就行。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051817181.png)</span><br><span class="line"></span><br><span class="line">- **注释：**</span><br><span class="line"></span><br><span class="line">	快捷键 `;` 可以在反汇编窗口加注释，快捷键 `/` 可以在反编译窗口加注释。IDA 还能自动给不常用架构的代码加注释，在 &quot;Auto comments&quot; 那里勾选就行。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051825870.png)</span><br><span class="line"></span><br><span class="line">## 交叉引用</span><br><span class="line"></span><br><span class="line">- **代码交叉引用：**</span><br><span class="line"></span><br><span class="line">	表示一个指令把控制权交给另一个指令，能帮忙了解指令和指令、指令和函数之间的调用关系。</span><br><span class="line"></span><br><span class="line">- **数据交叉引用：**</span><br><span class="line"></span><br><span class="line">	用于追踪二进制文件访问数据的情况，能让知道指令和数据之间有啥关系。这部分需要比较扎实的汇编知识。</span><br><span class="line"></span><br><span class="line">## 常用快捷键</span><br><span class="line"></span><br><span class="line">- F5：</span><br><span class="line"></span><br><span class="line">	在汇编窗口里按 F5，能生成对应函数的伪代码。</span><br><span class="line"></span><br><span class="line">* Ctrl+F5：</span><br><span class="line"></span><br><span class="line">	可以把伪代码导出保存下来。</span><br><span class="line"></span><br><span class="line">* Shift+F12：</span><br><span class="line"></span><br><span class="line">	在汇编窗口里按 Shift+F12，能打开字符串窗口。所有字符串都在这儿展示，你可以搜一些关键字符串。双击某个字符串，就能跳到汇编窗口中该字符串对应的位置。用 Ctrl+F 可以查找字符串。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051953784.png)</span><br><span class="line"></span><br><span class="line">- **Ctrl+X (交叉引用)：**</span><br><span class="line"></span><br><span class="line">	在汇编窗口中，用 `Ctrl+X` 可以查看哪些函数引用了这个字符串或数据。点 &quot;OK&quot; 会跳到相应位置。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051955880.png)</span><br><span class="line"></span><br><span class="line">- **Alt+T (文本搜索)：**</span><br><span class="line"></span><br><span class="line">	IDA 文本搜索相当于在反汇编列表窗口文本模式下搜索子字符串。搜到字符串后，会自动跳到汇编窗口中对应的位置。</span><br><span class="line"></span><br><span class="line">	它只会查找完整的词，包括操作码助记符或常量。</span><br><span class="line"></span><br><span class="line">	选 &quot;Find all occurences&quot;，IDA 会在一个新窗口里显示所有搜索结果，方便你快速定位。</span><br><span class="line"></span><br><span class="line">- **跳转地址：**</span><br><span class="line"></span><br><span class="line">	汇编窗口左边是地址，右边是汇编代码。</span><br><span class="line"></span><br><span class="line">	在浏览代码的时候，可能会迷路。或者你知道想去的目标地址，但反汇编窗口里没有可供双击导航的名称。这时候，用 `G` 就能跳到指定位置。</span><br><span class="line"></span><br><span class="line">- **N (重命名)：**</span><br><span class="line"></span><br><span class="line">	可以把一些函数名或者变量名改成方便理解的名字。</span><br><span class="line"></span><br><span class="line">- **Ctrl+Z (撤回操作)：**</span><br><span class="line"></span><br><span class="line">	不小心改错了，Ctrl+Z回到上一步。</span><br><span class="line"></span><br><span class="line">## 数据类型转换快捷键</span><br><span class="line"></span><br><span class="line">当flag 是 16 进制 ASCII 值时，可以靠快捷键搞定。</span><br><span class="line"></span><br><span class="line">- D (转换成数据形式)：</span><br><span class="line"></span><br><span class="line">	分析数据时，有时候需要把字符串转换成数据。</span><br><span class="line"></span><br><span class="line">* A (转换成字符形式)：</span><br><span class="line"></span><br><span class="line">	转换成字符串。</span><br><span class="line"></span><br><span class="line">* C (转换成汇编代码)：</span><br><span class="line"></span><br><span class="line">	转换成汇编代码。</span><br><span class="line"></span><br><span class="line">* U (转成原始字符)：</span><br><span class="line"></span><br><span class="line">	转换成最原始的状态。</span><br><span class="line"></span><br><span class="line">* Shift+E (导出数据)：</span><br><span class="line"></span><br><span class="line">	导出数据，选中后按 Shift+E，选你想导出的方式。</span><br><span class="line"></span><br><span class="line">- **数据转化形式：**</span><br><span class="line"></span><br><span class="line">	分析伪代码时，有时候要对数据进行类型转化。右键数据，会出现这些选项：</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505052002733.png)</span><br><span class="line"></span><br><span class="line">	- Hexadecimal: 十六进制</span><br><span class="line">	- Octal: 八进制</span><br><span class="line">	- Char: 字符</span><br><span class="line">	- Enum: 枚举</span><br><span class="line"></span><br><span class="line">main函数翻成伪代码后：</span><br><span class="line"></span><br><span class="line">````java</span><br><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int b; // [rsp+28h] [rbp-8h] BYREF</span><br><span class="line">  int b_1; // [rsp+2Ch] [rbp-4h] BYREF</span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  scanf(&quot;%d%d&quot;, &amp;b_1, &amp;b);</span><br><span class="line">  if ( b_1 == b )</span><br><span class="line">    printf(&quot;flag&#123;this_Is_a_EaSyRe&#125;&quot;);</span><br><span class="line">  else</span><br><span class="line">    printf(&quot;sorry,you can&#x27;t get flag&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">分析出 `main` 函数的逻辑是：**输入两个相同的数字 → 输出 flag**</span><br><span class="line"></span><br><span class="line">## **解题方法**</span><br><span class="line"></span><br><span class="line">### **方法 1：直接运行程序并输入相同数字**</span><br><span class="line"></span><br><span class="line">1. **运行程序**（如果是 Windows 的 `.exe`，直接双击；如果是 Linux 的 ELF，用 `./program` 运行）。</span><br><span class="line"></span><br><span class="line">2. **输入两个相同的数字**，比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  123
  123
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. **程序输出 flag**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  flag&#123;this_Is_a_EaSyRe&#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### **方法 2：直接修改二进制文件（硬编码绕过检查）**</span><br><span class="line"></span><br><span class="line">如果不想手动输入，可以修改汇编代码，让程序直接输出 flag（适用于逆向题目）：</span><br><span class="line"></span><br><span class="line">1. 用 **IDA/Ghidra** 找到 `if (b_1 == b)` 的判断部分。</span><br><span class="line">2. 把 `JNE`（跳转如果不相等）改成 `JMP` 或 `NOP`，让程序直接执行 `printf(&quot;flag&#123;...&#125;&quot;)`。</span><br><span class="line">3. 保存修改后的程序，运行即可直接得 flag。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># IDA Pro MCP 逆向分析利器</span><br><span class="line"></span><br><span class="line">参考：[AI逆向50页长文掌握 IDA Pro MCP 逆向分析利器](https://bbs.kanxue.com/thread-286813.htm)</span><br><span class="line"></span><br><span class="line">## 步骤一：准备大模型 API Key</span><br><span class="line"></span><br><span class="line">要使用 IDA Pro MCP，首先需要一个大模型服务的 API Key。</span><br><span class="line"></span><br><span class="line">### DeepSeek</span><br><span class="line"></span><br><span class="line">- **官方网站:** [https://www.deepseek.com/](https://bbs.kanxue.com/elink@cc8K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6%4N6%4N6Q4x3X3g2V1k6h3g2H3M7$3g2W2K9#2)</span><br><span class="line">- **API 管理平台:** [https://platform.deepseek.com/usage](https://bbs.kanxue.com/elink@fa1K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3L8r3q4@1k6X3!0J5L8g2)</span><br><span class="line"></span><br><span class="line">根据平台的指引完成实名认证和充值，在API管理页创建一个新的API Key。</span><br><span class="line"></span><br><span class="line">`务必妥善保管API Key，防止泄露！！！`</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543844.png)</span><br><span class="line"></span><br><span class="line">在充值后，在liunx系统使用curl命令测试api是否可用。</span><br><span class="line"></span><br><span class="line">将 `&lt;DeepSeek API Key&gt;` 替换为自己的 Key</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">curl https://api.deepseek.com/chat/completions \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -H &quot;Authorization: Bearer &lt;DeepSeek API Key&gt;&quot; \</span><br><span class="line">  -d &#x27;&#123;</span><br><span class="line">        &quot;model&quot;: &quot;deepseek-chat&quot;,</span><br><span class="line">        &quot;messages&quot;: [</span><br><span class="line">          &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;,</span><br><span class="line">          &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello!&quot;&#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;stream&quot;: false</span><br><span class="line">      &#125;&#x27;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220917980.png)</span><br><span class="line"></span><br><span class="line">如果终端成功输出了 AI 的回复消息，则表示 DeepSeek API Key 配置成功.</span><br><span class="line"></span><br><span class="line">## 步骤二：选择并配置 MCP 客户端</span><br><span class="line"></span><br><span class="line">### 客户端一：VS Code 插件 (Cline / RooCode)</span><br><span class="line"></span><br><span class="line">Cline 和 RooCode 是两款支持 MCP 的 VS Code 插件，可以将 VS Code 作为 IDA Pro MCP 的客户端。</span><br><span class="line"></span><br><span class="line">#### 安装</span><br><span class="line"></span><br><span class="line">“扩展”，插件cline或RooCode</span><br><span class="line"></span><br><span class="line">#### 初始化配置</span><br><span class="line"></span><br><span class="line">进行初始化配置，主要是设置大模型API Key</span><br><span class="line"></span><br><span class="line">1. 打开其中一个插件的设置界面，点击插件图标（或是用命令面板Ctrl+Shift+P/Cmd+Shift+P走索插件名称找到。）</span><br><span class="line"></span><br><span class="line">2. 选择“使用自己的PAPI Key”（Use your own API key）</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220931666.png)</span><br><span class="line"></span><br><span class="line">3. 配置 API Key</span><br><span class="line"></span><br><span class="line">	根据选择的 API 服务商进行配置：</span><br><span class="line"></span><br><span class="line">	- **DeepSeek:**</span><br><span class="line">		- 选择 `API Provider` 为 `DeepSeek`。</span><br><span class="line">		- 在 `API Key` 字段中填入 DeepSeek API Key。</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220933934.png)</span><br><span class="line"></span><br><span class="line">**语言设置（Preferred Language）**</span><br><span class="line"></span><br><span class="line">- **简体中文**：强制工具（如Cline插件）始终以中文与你交互，即使你的提问包含其他语言。</span><br><span class="line">- **作用场景**：例如当你输入英文问题时，工具仍会用中文回答。</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220957109.png)</span><br><span class="line"></span><br><span class="line">## 步骤四：部署 IDA Pro MCP (Windows)</span><br><span class="line"></span><br><span class="line">1. **配置python环境**</span><br><span class="line"></span><br><span class="line">	Windows 环境需要安装 Python 3.11 或更高版本</span><br><span class="line"></span><br><span class="line">	已安装python使用的版本为3.12.6</span><br><span class="line"></span><br><span class="line">2. **切换 IDA Pro 的 Python 环境**</span><br><span class="line"></span><br><span class="line">	告知 IDA Pro 使用安装的 Python 3.12.6，cmd中执行</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	&quot;F:\IDA Professional 9.1\idapyswitch.exe&quot; --force-path &quot;E:\python\python3,dll&quot;</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505221043566.png)</span><br><span class="line"></span><br><span class="line">	成功执行后通常没有输出。</span><br><span class="line"></span><br><span class="line">3. **安装 ida-pro-mcp Python 包**</span><br><span class="line"></span><br><span class="line">	下载 `uv` 包</span><br><span class="line"></span><br><span class="line">	#### 分步安装依赖</span><br><span class="line"></span><br><span class="line">	如果直接安装失败，先安装小体积依赖包，再尝试安装 `uv`：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  # 先安装其他小包（如有必要）
  pip install numpy pandas -i https://pypi.tuna.tsinghua.edu.cn/simple
  
  # 再安装 uv
  pip install uv -i https://pypi.tuna.tsinghua.edu.cn/simple
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 Python  的 pip 来安装 `ida-pro-mcp`。</span><br><span class="line"></span><br><span class="line">之后所有 pip 安装都会默认使用清华源，**永久配置镜像源**（推荐）</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">**临时指定镜像源**：在命令中添加 `-i` 参数：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  pip install --upgrade git+https://github.com/mrexodia/ida-pro-mcp -i https://pypi.tuna.tsinghua.edu.cn/simple
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. **安装 MCP 插件到 IDA Pro**</span><br><span class="line"></span><br><span class="line">	执行安装命令将插件复制到 IDA Pro</span><br><span class="line"></span><br><span class="line">	使用命令查找`ida-pro-mcp.exe` 可执行文件的路径。</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	pip show -f ida-pro-mcp</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	输出信息：</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	Name: ida-pro-mcp</span><br><span class="line">	Version: 1.3.0</span><br><span class="line">	...</span><br><span class="line">	Location: E:\python\Lib\site-packages# &lt;--- 包安装位置</span><br><span class="line">	Requires: mcp</span><br><span class="line">	Required-by:</span><br><span class="line">	Files:</span><br><span class="line">	  ..\..\Scripts\ida-pro-mcp.exe# &lt;--- 可执行文件相对路</span><br><span class="line">	  ..\..\Scripts\idalib-mcp.exe</span><br><span class="line">	  ida_pro_mcp-1.3.0.dist-info\INSTALLER</span><br><span class="line">		...</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	可得绝对路径：E:\python\Scripts\ida-pro-mcp.exe</span><br><span class="line"></span><br><span class="line">	执行安装命令：</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	&quot;E:\python\Scripts\ida-pro-mcp.exe&quot; --install</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543845.png)</span><br><span class="line"></span><br><span class="line">​	**MCP 服务器配置生成**，这是 **MCP 服务器的标准配置模板**，需手动添加到对应工具的配置文件中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>Installed IDA Pro plugin (IDA restart required)<br>Plugin: C:\Users\tangxtang\AppData\Roaming\Hex-Rays\IDA Pro\plugins\mcp-plugin.py</p>
<pre><code>
- **核心功能已部署**，插件文件已复制到 IDA 的插件目录。
- 需要 **重启 IDA** 才能生效。
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓逆向工程</tag>
        <tag>信息安全</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>破解·壳与程序的特征</title>
    <url>/2025/08/11/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<p>学习链接：[破解基础知识之认识壳与程序的特征](<a href="https://www.52pojie.cn/thread-234739-1-1.html">【初学者教程】破解基础知识之认识壳与程序的特征 - 吾爱破解 - 52pojie.cn</a>)</p>
<p><strong>基础状态</strong>：程序在刚编译完成时，通常为无壳状态。</p>
<p><strong>无可程序差异</strong>：不同编译器编译的无壳程序存在区别（因编译器特性、生成机制不同）。</p>
<p><strong>学习逻辑</strong>：先认识不同编译器的无壳程序特征，是理解加壳后程序特征的基础（由基础到复杂，降低学习难度）。</p>
<p><strong>核心方法</strong>：通过对比无壳程序与加壳后程序，可明确两者的特征差异。</p>
<p><strong>特征确定维度</strong>：程序的核心特征主要从以下信息判断：</p>
<ul>
<li>入口点代码</li>
<li>程序区段</li>
<li>加载模块</li>
</ul>
<h2 id="VC6-编译无壳程序的核心特点"><a href="#VC6-编译无壳程序的核心特点" class="headerlink" title="VC6 编译无壳程序的核心特点"></a>VC6 编译无壳程序的核心特点</h2><h4 id="1-入口点代码特征（固定模板）"><a href="#1-入口点代码特征（固定模板）" class="headerlink" title="1.入口点代码特征（固定模板）"></a>1.入口点代码特征（固定模板）</h4><ul>
<li><p><strong>OD（OllyDbg）视角：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55          push ebp        ; 保存基址指针</span><br><span class="line">8B EC       mov ebp, esp    ; 建立新栈帧</span><br><span class="line">[若干压栈指令]  ; 不同程序的push地址可能不同（如参数、环境变量）</span><br><span class="line">call xxx     ; 调用VC6运行库初始化函数（如 __set_app_type、__p__fmode 等固定API）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键固定行为</strong>：无论程序逻辑如何，<strong>入口必包含压栈保环境 → 调用VC6运行库初始化</strong>的固定流程。</li>
<li><strong>与VS区别</strong>：VS编译的程序入口仅两行（<code>call + jmp</code>），无连接压栈和直接API调用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190151191.png"></p>
</li>
<li><p><strong>工具识别</strong>：</p>
<p>  PEID&#x2F;ExeinfoPE 直接标注为 <code>Microsoft Visual C++ ver 5.0/6.0</code>，入口点特征可辅助确认。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190152565.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190153467.png"></p>
</li>
</ul>
<h4 id="2-区段（Section）特征（固定四区段）"><a href="#2-区段（Section）特征（固定四区段）" class="headerlink" title="2. 区段（Section）特征（固定四区段）"></a><strong>2. 区段（Section）特征（固定四区段）</strong></h4><ul>
<li><p><strong>PEID&#x2F;ExeinfoPE 视角</strong>：</p>
<p>  区段固定为 4 个，无<code>.reloc</code>（重定位段）：</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>用途</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>包含程序指令，可读可执行</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读数据段</td>
<td>存储常量、字符串、导入表等</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>存储全局变量、静态变量</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>包含图标、对话框等二进制资源</td>
</tr>
</tbody></table>
<ul>
<li><strong>与 VS 区别</strong>：VS 编译的程序多一个<code>.reloc</code>段（用于基址重定位），区段总数为 5 个。</li>
</ul>
</li>
</ul>
<h4 id="3-运行库初始化行为（固定-API-调用）"><a href="#3-运行库初始化行为（固定-API-调用）" class="headerlink" title="3. 运行库初始化行为（固定 API 调用）"></a><strong>3. 运行库初始化行为（固定 API 调用）</strong></h4><ul>
<li>入口点调用的 API 固定指向 VC6 运行库（如 <code>MSVCRT.dll</code> 中的 <code>__set_app_type</code>、<code>__p__fmode</code> 等），用于初始化 C 运行时环境（如 I&#x2F;O 模式、浮点状态）。</li>
<li>不同程序的差异仅体现在<strong>压栈的参数地址</strong>（如命令行、环境变量指针），但 API 调用顺序和目标固定。</li>
</ul>
<h4 id="4-实际应用场景（逆向工程中的识别）"><a href="#4-实际应用场景（逆向工程中的识别）" class="headerlink" title="4.实际应用场景（逆向工程中的识别）"></a><strong>4.实际应用场景（逆向工程中的识别）</strong></h4><ul>
<li><strong>快速判断开发环境</strong>：通过 PEID 区段数（4 个）+ OD 入口指令（<code>push ebp + mov ebp, esp</code>）可秒级确认 VC6 编译。</li>
<li><strong>区分壳与无壳</strong>：若程序区段被混淆（如合并区段）或入口代码被加密，则可能加壳（需进一步脱壳）。</li>
<li><strong>对比易语言独立编译</strong>：易语言独立编译调用 VC 链接器，区段和入口特征与 VC6 完全一致，需结合其他特征（如易语言运行库函数）区分。</li>
</ul>
<h2 id="VS2008和VS2013编译无壳程序"><a href="#VS2008和VS2013编译无壳程序" class="headerlink" title="VS2008和VS2013编译无壳程序"></a>VS2008和VS2013编译无壳程序</h2><p>可从 <strong>入口点代码、程序区段、运行库 &#x2F; API 调用</strong> 三个维度分析特征，两者存在共性也有版本差异.</p>
<h3 id="一、共性核心特征"><a href="#一、共性核心特征" class="headerlink" title="一、共性核心特征"></a><strong>一、共性核心特征</strong></h3><h4 id="1-入口点代码：简洁的-“CALL-JMP”-结构"><a href="#1-入口点代码：简洁的-“CALL-JMP”-结构" class="headerlink" title="1.入口点代码：简洁的 “CALL + JMP” 结构"></a>1.<strong>入口点代码：简洁的 “CALL + JMP” 结构</strong></h4><ul>
<li><p><strong>指令形态</strong>：<br>  无壳程序入口仅 <strong>2 行核心指令</strong>，典型形式：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    00401005  ; 调用内部函数（实际跳转到运行库初始化）</span><br><span class="line">jmp     00401010  ; 跳转至真正的程序逻辑（如main函数前的初始化）</span><br></pre></td></tr></table></figure>

<p>  进入<code>call</code>后的子逻辑，会调用 <strong>固定的系统 &#x2F; 运行库 API</strong>（如初始化 C++ 运行时、获取系统时间等）。</p>
</li>
<li><p><strong>与 VC6 对比</strong>：<br>  VC6 入口有连续压栈（<code>push ebp</code>等）和多个 API 调用，而 VS 入口更 “紧凑”，通过间接跳转隐藏细节。</p>
</li>
</ul>
<h4 id="2-程序区段：新增-reloc段（支持-ASLR）"><a href="#2-程序区段：新增-reloc段（支持-ASLR）" class="headerlink" title="2. 程序区段：新增.reloc段（支持 ASLR）"></a>2. <strong>程序区段：新增<code>.reloc</code>段（支持 ASLR）</strong></h4><ul>
<li><p><strong>区段列表</strong>：<br>  相比 VC6 的 4 个区段（.text、.rdata、.data、.rsrc），VS 编译程序多一个 <strong><code>.reloc</code>段</strong>，用于 <strong>基址重定位</strong>（适配 Windows 的 ASLR 随机化加载机制）。</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>用途</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>包含程序指令，可读可执行</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读数据段</td>
<td>存储常量、字符串、导入表等</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>存储全局变量、静态变量</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>包含图标、对话框等二进制资源</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td>重定位表</td>
<td>存储基址重定位信息</td>
</tr>
</tbody></table>
</li>
<li><p><strong>意义</strong>：<br>  <code>.reloc</code>记录了程序加载到非默认基址时，需要修正的地址偏移，是现代编译器对 “内存安全” 的适配。</p>
</li>
</ul>
<h3 id="二、版本差异（VS2008-vs-VS2013）"><a href="#二、版本差异（VS2008-vs-VS2013）" class="headerlink" title="二、版本差异（VS2008 vs VS2013）"></a><strong>二、版本差异（VS2008 vs VS2013）</strong></h3><h4 id="1-链接器版本与标识"><a href="#1-链接器版本与标识" class="headerlink" title="1. 链接器版本与标识"></a>1. <strong>链接器版本与标识</strong></h4><ul>
<li><strong>VS2008</strong>：链接器版本 <code>9.0</code>，工具（如 PEID）可检测到 “Microsoft Visual C++ 9.0” 标识。</li>
<li><strong>VS2013</strong>：链接器版本 <code>12.0</code>，标识为 “Microsoft Visual C++ 12.0”。</li>
</ul>
<h4 id="2-入口-API-调用细节"><a href="#2-入口-API-调用细节" class="headerlink" title="2. 入口 API 调用细节"></a>2. <strong>入口 API 调用细节</strong></h4><ul>
<li><p>VS2013：</p>
<p>  进入<code>call</code>后的初始化逻辑，更倾向调用现代系统 API（如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call KERNEL32.GetSystemTimeAsFileTime  ; 获取系统时间（高精度）</span><br><span class="line">call KERNEL32.GetCurrentProcessId      ; 获取进程ID</span><br><span class="line">call KERNEL32.GetCurrentThreadId       ; 获取线程ID</span><br></pre></td></tr></table></figure>

<p>  这些 API 在 VS2008 中可能被更早期的函数替代（如<code>GetSystemTime</code>而非<code>GetSystemTimeAsFileTime</code>）。</p>
</li>
</ul>
<h3 id="三、逆向分析中的识别方法"><a href="#三、逆向分析中的识别方法" class="headerlink" title="三、逆向分析中的识别方法"></a><strong>三、逆向分析中的识别方法</strong></h3><ol>
<li><p><strong>工具快速检测</strong>：</p>
<ul>
<li><strong>PEID&#x2F;ExeinfoPE</strong>：直接显示编译器版本（“VS2008” 或 “VS2013”），并验证<code>.reloc</code>区段存在。</li>
</ul>
</li>
<li><p><strong>OllyDbg 动态验证</strong>：加载程序后，入口指令若为 “<code>call + jmp</code>”，且跟随<code>call</code>后看到运行库初始化逻辑（如调用上述 KERNEL32 API），则符合 VS 特征。</p>
</li>
</ol>
<h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a><strong>总结对比表</strong></h3><table>
<thead>
<tr>
<th>维度</th>
<th>VS2008</th>
<th>VS2013</th>
</tr>
</thead>
<tbody><tr>
<td><strong>入口代码</strong></td>
<td>2 行（call + jmp），调用早期 API</td>
<td>2 行（call + jmp），调用现代 API</td>
</tr>
<tr>
<td><strong>区段</strong></td>
<td>含<code>.reloc</code>，共 5 个核心区段</td>
<td>含<code>.reloc</code>，共 5 个核心区段</td>
</tr>
<tr>
<td><strong>运行库</strong></td>
<td><code>msvcr90.dll</code>（动态）</td>
<td><code>msvcr120.dll</code>（动态）</td>
</tr>
<tr>
<td><strong>工具标识</strong></td>
<td>“Visual C++ 9.0”</td>
<td>“Visual C++ 12.0”</td>
</tr>
</tbody></table>
<h2 id="易语言编译无壳程序"><a href="#易语言编译无壳程序" class="headerlink" title="易语言编译无壳程序"></a>易语言编译无壳程序</h2><p><strong>核心背景</strong>：易语言编译依赖 <strong>VC 链接器</strong>（底层调用 VC 编译器），因此两种编译模式的特征与 <strong>VC 无壳程序</strong> 存在关联，但又因 “是否依赖外部运行库” 产生差异。</p>
<h3 id="一、核心区段结构特征（PEID-ExeinfoPE-视角）"><a href="#一、核心区段结构特征（PEID-ExeinfoPE-视角）" class="headerlink" title="一、核心区段结构特征（PEID&#x2F;ExeinfoPE 视角）"></a>一、核心区段结构特征（PEID&#x2F;ExeinfoPE 视角）</h3><p>易语言底层调用 <strong>VC 链接器</strong> 编译，因此区段框架与 VC6 无壳程序高度一致，但存在细微差异：</p>
<table>
<thead>
<tr>
<th>特征维度</th>
<th>具体表现</th>
</tr>
</thead>
<tbody><tr>
<td>区段数量</td>
<td>固定为 <strong>4 个核心区段</strong>（无 <code>.reloc</code> 区段），是区分现代 VS 编译程序（含 <code>.reloc</code>）的关键标志。</td>
</tr>
<tr>
<td>区段名称</td>
<td>标准命名：<code>.text</code>（代码段）、<code>.rdata</code>（只读数据）、<code>.data</code>（全局变量）、<code>.rsrc</code>（资源），无随机或异常区段名（加壳程序常见随机区段）。</td>
</tr>
<tr>
<td>区段属性</td>
<td><code>.text</code> 区段必含 <strong>可执行属性（Execute）</strong>，<code>.rdata</code> 为只读（Read），<code>.data</code> 可读写（Read&#x2F;Write），属性无异常（加壳程序可能篡改 <code>.text</code> 为不可执行）。</td>
</tr>
</tbody></table>
<h3 id="二、导入表特征（依赖库标识）"><a href="#二、导入表特征（依赖库标识）" class="headerlink" title="二、导入表特征（依赖库标识）"></a>二、导入表特征（依赖库标识）</h3><p>导入表是识别易语言程序的 <strong>核心依据</strong>，因编译模式（独立 &#x2F; 非独立）不同略有差异：</p>
<table>
<thead>
<tr>
<th>编译模式</th>
<th>导入表关键特征</th>
</tr>
</thead>
<tbody><tr>
<td>非独立编译</td>
<td><strong>必依赖易语言支持库</strong>：导入表中明确包含 <code>krnln.fnr</code>（易语言核心支持库）、<code>eapi.fnr</code>（扩展支持库）等易语言特有库，且函数名多为中文标识相关（如 <code>初始化环境</code> <code>创建窗口</code> 等）。 同时依赖 VC 基础运行库 <code>MSVCRT.dll</code>（因底层调用 VC 编译链）。</td>
</tr>
<tr>
<td>独立编译</td>
<td>无外部易语言支持库依赖（支持库被打包进 EXE），导入表仅依赖 <code>MSVCRT.dll</code> 等 VC 运行库，但 EXE 体积通常 <strong>明显更大</strong>（因内置支持库代码）。</td>
</tr>
</tbody></table>
<h3 id="三、入口代码特征（反汇编视角）"><a href="#三、入口代码特征（反汇编视角）" class="headerlink" title="三、入口代码特征（反汇编视角）"></a>三、入口代码特征（反汇编视角）</h3><p>易语言无壳程序的入口代码继承 VC6 特征，但存在细微区别：</p>
<ul>
<li><p>入口指令以 <code>PUSH EBP</code>、<code>MOV EBP, ESP</code> 等栈初始化指令开始（同 VC6 标准入口）。</p>
</li>
<li><p>早期易语言版本入口附近可能调用 <code>MSVCRT.dll!__getmainargs</code> 或 <code>_main</code> 函数（VC 运行库初始化逻辑）。</p>
</li>
<li><p>与纯 VC6 程序的区别：入口后续会跳转到易语言特有初始化逻辑（如支持库加载、窗口创建等），反汇编中可能出现中文函数名的字符串引用（如 <code>_启动窗口_创建完毕</code>）。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508191509164.png" alt="来源吾爱破解作者Hmily链接见文顶"></p>
</li>
</ul>
<h3 id="四、资源与字符串特征"><a href="#四、资源与字符串特征" class="headerlink" title="四、资源与字符串特征"></a>四、资源与字符串特征</h3><ul>
<li><p><strong>资源区段（.rsrc）</strong>：易语言程序通常包含大量窗体资源（对话框、按钮、文本框等），资源类型中可能存在 <code>DLG</code>（对话框）、<code>ICON</code>（图标）等，且资源名称可能含中文标识（如窗体标题）。</p>
</li>
<li><p>字符串特征：程序字符串中常出现易语言特有标识，例如：</p>
<ul>
<li><p>支持库相关：<code>krnln.fnr</code>、<code>eapi.fnr</code>、<code>支持库版本不兼容</code> 等（查看模块）。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508191510023.png" alt="来源吾爱破解作者Hmily链接见文顶"></p>
</li>
<li><p>运行逻辑相关：<code>_启动窗口_</code>、<code>_按钮1_被单击</code>、<code>信息框</code> 等中文函数或事件名。</p>
</li>
</ul>
</li>
</ul>
<h3 id="五、运行时行为特征"><a href="#五、运行时行为特征" class="headerlink" title="五、运行时行为特征"></a>五、运行时行为特征</h3><ul>
<li><strong>独立编译程序</strong>：运行时会在系统临时目录（如 <code>C:\Users\用户名\AppData\Local\Temp</code>）释放打包的支持库文件（<code>.fnr</code>&#x2F;<code>.fne</code>），程序退出后通常自动删除。</li>
<li><strong>非独立编译程序</strong>：若目标机未安装易语言或未放置对应支持库，运行时会弹窗报错（如 <code>找不到指定的支持库文件</code>），依赖外部库的特征明显。</li>
</ul>
<h3 id="关键区分点"><a href="#关键区分点" class="headerlink" title="关键区分点"></a>关键区分点</h3><ol>
<li>与 VC6 无壳程序的区别：VC6 程序无 <code>krnln.fnr</code> 等易语言库依赖，且字符串中无中文事件 &#x2F; 函数名；易语言程序即使独立编译，也可能在代码中残留支持库相关字符串。</li>
<li>与加壳程序的区别：加壳程序区段名称混乱（如 <code>.upx0</code>、<code>.pack</code>）、区段数量异常（通常 2-3 个），且导入表可能被隐藏（需脱壳后才能看到真实依赖）；而易语言无壳程序区段规范、导入表清晰。</li>
</ol>
<p>可以从程序里找一些call的调用最终都会走到上面核心代码图位置（文字不太好表达），这个方法可以区分和VC的区别，非独立编译比较容易识别，入口特征和模块特征都有krnln.fnr。</p>
<h2 id="Delhpi编译无壳程序"><a href="#Delhpi编译无壳程序" class="headerlink" title="Delhpi编译无壳程序"></a>Delhpi编译无壳程序</h2><h3 id="一、区段结构特征（PEID-ExeinfoPE-视角）"><a href="#一、区段结构特征（PEID-ExeinfoPE-视角）" class="headerlink" title="一、区段结构特征（PEID&#x2F;ExeinfoPE 视角）"></a>一、区段结构特征（PEID&#x2F;ExeinfoPE 视角）</h3><p>Delphi 编译器生成的 PE 区段结构相对固定，与 VC &#x2F; 易语言等有明显差异：</p>
<table>
<thead>
<tr>
<th>特征维度</th>
<th>具体表现</th>
</tr>
</thead>
<tbody><tr>
<td>区段数量</td>
<td>典型包含 <strong>4-5 个核心区段</strong>：<code>.text</code>（代码段）、<code>.data</code>（全局数据）、<code>.rsrc</code>（资源段）、<code>.idata</code>（导入表），部分版本可能含 <code>.reloc</code>（重定位表，通常较小或缺失）。</td>
</tr>
<tr>
<td>区段名称</td>
<td>区段命名规范且无随机名：<code>.text</code> 为可执行代码，<code>.data</code> 存放全局变量和常量，<code>.rsrc</code> 含窗体 &#x2F; 图标等资源，<code>.idata</code> 明确存储导入函数信息（无加壳程序的混乱区段名如 <code>.pack</code>）。</td>
</tr>
<tr>
<td>区段属性</td>
<td><code>.text</code> 必含 <strong>可执行属性（Execute）</strong>，<code>.data</code> 为读写属性（Read&#x2F;Write），<code>.rsrc</code> 和 <code>.idata</code> 为只读（Read），属性无异常篡改（加壳程序常将 <code>.text</code> 改为不可执行以隐藏代码）。</td>
</tr>
</tbody></table>
<h3 id="二、导入表特征（依赖库标识）-1"><a href="#二、导入表特征（依赖库标识）-1" class="headerlink" title="二、导入表特征（依赖库标识）"></a>二、导入表特征（依赖库标识）</h3><p>Delphi 程序依赖其专属运行时库（RTL）和组件库（VCL），导入表是识别的核心依据：</p>
<table>
<thead>
<tr>
<th>编译模式（静态 &#x2F; 动态）</th>
<th>导入表关键特征</th>
</tr>
</thead>
<tbody><tr>
<td>动态编译（默认）</td>
<td>依赖 <strong>Delphi 运行时 BPL 库</strong>：导入表中必含 <code>rtlXX.bpl</code>（RTL 核心库，XX 为版本号，如 <code>rtl100.bpl</code> 对应 Delphi 6）、<code>vclXX.bpl</code>（VCL 组件库，含窗体 &#x2F; 控件逻辑）。 同时依赖系统基础库：<code>kernel32.dll</code>、<code>user32.dll</code> 等，但核心逻辑依赖 BPL 库，函数名多为 Pascal 风格（如 <code>@System@Initialize</code>）。</td>
</tr>
<tr>
<td>静态编译（链接时嵌入）</td>
<td>无外部 BPL 库依赖（RTL&#x2F;VCL 代码被打包进 EXE），导入表仅含系统 API（如 <code>kernel32.dll!CreateFileA</code>、<code>user32.dll!MessageBoxA</code>），但程序体积 <strong>显著增大</strong>（因内置运行时库代码）。</td>
</tr>
<tr>
<td>函数名特征</td>
<td>导入函数名无 VC 风格的修饰符（如 <code>_函数名@参数大小</code>），多为原始 API 名或 Pascal 命名规范的函数（如 <code>@SysUtils@StrLen</code>），区分于 C&#x2F;C++ 程序的下划线前缀。</td>
</tr>
</tbody></table>
<h3 id="三、入口代码特征（反汇编视角）-1"><a href="#三、入口代码特征（反汇编视角）-1" class="headerlink" title="三、入口代码特征（反汇编视角）"></a>三、入口代码特征（反汇编视角）</h3><p>Delphi 程序入口点（OEP）代码逻辑固定，与其他编译器差异明显：</p>
<ul>
<li>入口指令以 <strong>栈初始化</strong> 开始：<code>PUSH EBP</code> → <code>MOV EBP, ESP</code> → <code>PUSH EBX</code> → <code>PUSH ESI</code> → <code>PUSH EDI</code>（标准 Pascal 函数栈帧）。</li>
<li>入口后直接调用 Delphi 运行时初始化函数：如 <code>@System@StartExe</code> 或 <code>@Vcl@Forms@TApplication@Initialize</code>（VCL 程序特有），无 VC 程序的 <code>__security_init_cookie</code> 等安全检查指令。</li>
<li>代码中大量使用 <strong>寄存器间接寻址</strong>（如 <code>MOV EAX, [ESI+0x14]</code>），因 Pascal 调用约定更依赖寄存器传递参数。</li>
</ul>
<h3 id="四、其他关键特征"><a href="#四、其他关键特征" class="headerlink" title="四、其他关键特征"></a>四、其他关键特征</h3><ol>
<li><strong>无壳与加壳区分</strong>：加壳 Delphi 程序区段名混乱（如 <code>.upx</code> 区段）、导入表被隐藏（需脱壳后才见 BPL 依赖），而无壳程序区段规范、导入表清晰可见。</li>
<li><strong>程序体积</strong>：动态编译的小型程序体积通常在 <strong>500KB-2MB</strong>（依赖 BPL 库），静态编译则可能达 <strong>5-10MB</strong>（内置 RTL&#x2F;VCL 代码），显著大于同功能的易语言程序。</li>
</ol>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用OllyDbg打开练习文件：</p>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250819152553656.png"></p>
<h4 id="分区域细节分析"><a href="#分区域细节分析" class="headerlink" title="分区域细节分析"></a>分区域细节分析</h4><ol>
<li><strong>反汇编窗口（左上）：入口代码与逻辑</strong></li>
</ol>
<ul>
<li><strong>入口指令</strong>：<code>0044EDF4</code> 处的 <code>PUSH EBP ; MOV EBP, ESP</code>，是 <strong>Pascal 函数的标准栈帧初始化</strong>（旧版 Delphi 典型特征，区别于 VC 的简洁入口）。</li>
<li><strong>调用逻辑</strong>：后续 <code>CALL 吾爱破解.004xxxx</code> 均指向 <strong>程序内部函数</strong>（而非系统库或壳的解密逻辑），符合 Delphi 程序 “依赖自身运行时” 的特点。</li>
</ul>
<h5 id="2-寄存器窗口（右上）：运行时状态"><a href="#2-寄存器窗口（右上）：运行时状态" class="headerlink" title="2. 寄存器窗口（右上）：运行时状态"></a>2. <strong>寄存器窗口（右上）：运行时状态</strong></h5><ul>
<li><strong>EIP &#x3D; 0044EDF4</strong>：指向程序入口点（与 Exeinfo PE 的 <code>Entry Point</code> 一致），说明调试器正确定位到 <strong>原生 OEP（原始入口点）</strong>。</li>
<li><strong>LastErr &#x3D; ERROR_ENVVAR_NOT_FOUND</strong>：调试时的环境变量读取失败（非致命，仅为调试环境问题，不影响程序原生性）。</li>
</ul>
<h5 id="3-内存转储窗口（左下）：数据与字符串"><a href="#3-内存转储窗口（左下）：数据与字符串" class="headerlink" title="3. 内存转储窗口（左下）：数据与字符串"></a>3. <strong>内存转储窗口（左下）：数据与字符串</strong></h5><ul>
<li><strong>ASCII 区可见中文</strong>：如 <code>吾爱破解</code> 等字符串，是 <strong>程序自身的明文字符</strong>（加壳程序通常会加密字符串，此处无加密）。</li>
<li><strong>数据无混淆</strong>：十六进制数据无乱码或加密特征（如固定偏移的加密块），符合无壳程序的内存布局。</li>
</ul>
<h5 id="4-栈窗口（右下）：调用链与返回地址"><a href="#4-栈窗口（右下）：调用链与返回地址" class="headerlink" title="4. 栈窗口（右下）：调用链与返回地址"></a>4. <strong>栈窗口（右下）：调用链与返回地址</strong></h5><ul>
<li><strong>返回地址</strong>：<code>RETURN to KERNEL32.7608FC9</code>，指向系统库 <code>KERNEL32</code>，是 <strong>程序正常调用系统 API 的结束流程</strong>（如 <code>ExitProcess</code>），无壳的异常跳转（如壳的解密后跳转）。</li>
</ul>
<p>刚开始在使用Exeinfo PE从区段特征判断，我是判断该程序并非 Delphi 无壳原生程序，更可能是经过加壳处理的程序，原因如下：</p>
<ul>
<li>区段命名不规范<ul>
<li>出现了<code>CODE</code>、<code>DATA</code>、<code>BSS</code> 等<strong>自定义名称</strong></li>
</ul>
</li>
<li>区段数量异常<ul>
<li>多达 <strong>8 个区段</strong>，明显超出正常范围，壳会拆分&#x2F;伪造区段以隐藏原始代码</li>
</ul>
</li>
<li>区段属性矛盾<ul>
<li><code>.rdata</code> 区段（只读数据段）的 <code>Flags</code> 为 <code>50000040</code>（含 <strong>可执行属性</strong>），但 <code>.rdata</code> 正常应为 <strong>只读不可执行</strong>，此矛盾是<strong>壳的混淆特征</strong>（故意篡改区段属性，干扰调试））。</li>
<li><code>.reloc</code> 区段（重定位段）同样被标记为 <code>50000040</code>（可执行），不符合原生程序的只读属性。</li>
</ul>
</li>
</ul>
<p>但是查了一下，发现这只是旧版Delphi程序的“特殊特征”：</p>
<p>此前区段查看器中 <strong>自定义区段名（CODE、DATA 等）</strong> 看似异常，实际是 <strong>旧版 Delphi 编译器的历史特性</strong>：</p>
<ul>
<li>旧版 Delphi（2.0~7.0）允许 <strong>自定义区段命名</strong>（如 <code>CODE</code> 存代码，<code>DATA</code> 存数据），而非现代编译器的 <code>.text</code>&#x2F;<code>.data</code> 标准命名。</li>
<li>区段数量多（8 个）是因旧版编译器为 <strong>调试信息、资源、重定位表</strong> 单独创建区段，属于原生设计，并非加壳篡改。</li>
</ul>
<h2 id="加壳程序识别"><a href="#加壳程序识别" class="headerlink" title="加壳程序识别"></a>加壳程序识别</h2><h3 id="一、查壳工具识别法（特征码匹配原理）"><a href="#一、查壳工具识别法（特征码匹配原理）" class="headerlink" title="一、查壳工具识别法（特征码匹配原理）"></a><strong>一、查壳工具识别法（特征码匹配原理）</strong></h3><ol>
<li><p><strong>核心原理</strong>：<br> 工具内置 <strong>加壳程序特征库</strong>（如特征码、区段 &#x2F; 入口模式），通过对比程序数据判定壳类型。</p>
</li>
<li><p><strong>工具对比与优劣</strong>：</p>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>代表工具</th>
<th>特征库机制</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统工具</strong></td>
<td>PEiD、FFI 等</td>
<td>依赖公开库（如<code>userdb.txt</code>）</td>
<td>支持用户自定义特征，灵活扩展</td>
<td>特征库陈旧（多基于 2009 年前数据），对新壳（如 VMProtect）<strong>误报率高</strong>（如 VMProtect 常被误判为 UPolyX）</td>
</tr>
<tr>
<td><strong>现代工具</strong></td>
<td>Exeinfo PE</td>
<td>作者独立维护 + 新版支持外部库</td>
<td>对新壳（VMProtect、Themida、WinLicense 等）识别更准，覆盖范围广</td>
<td>早期版本不支持自定义特征，对壳版本识别模糊</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="二、手动特征识别法（区段-入口分析）"><a href="#二、手动特征识别法（区段-入口分析）" class="headerlink" title="二、手动特征识别法（区段 + 入口分析）"></a><strong>二、手动特征识别法（区段 + 入口分析）</strong></h3><ol>
<li><strong>核心维度</strong>：<br> 突破工具局限，通过 <strong>程序自身结构特征</strong> 判断，适用于新壳 &#x2F; 定制壳。</li>
<li><strong>区段信息分析</strong>：<ul>
<li><strong>查看方式</strong>：PEiD&#x2F;Exeinfo PE 的 “区段查看” 功能（如 PEiD 的 EP 区段按钮）。</li>
<li><strong>判断逻辑</strong>：<ul>
<li>异常区段：壳常篡改区段名（如<code>.upx0</code>、<code>.pack</code>）、数量（2-3 个冗余区段）、属性（代码段标记为不可执行）。</li>
<li>典型壳特征：Themida&#x2F;WinLicense 会生成<code>._OVR</code>等特殊区段；压缩壳（如 UPX）区段数据高度压缩。</li>
</ul>
</li>
</ul>
</li>
<li><strong>入口代码分析</strong>：<ul>
<li><strong>查看方式</strong>：OllyDbg 载入后，**<code>Ctrl+A</code>**让 OD 分析入口代码，观察指令、字符串特征。</li>
<li><strong>判断逻辑</strong>：<ul>
<li>壳的入口多为 <strong>解密 &#x2F; 解压逻辑</strong>（如循环异或、调用系统 API 前的混淆指令）。</li>
<li>典型壳特征：Safengine 壳入口有<code>SE</code>相关字符串；VProtect 入口含特定跳转模式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="三、方法互补性"><a href="#三、方法互补性" class="headerlink" title="三、方法互补性"></a><strong>三、方法互补性</strong></h3><ul>
<li><strong>工具优先</strong>：快速筛除已知壳（如传统压缩壳、老版本加密壳），降低分析成本。</li>
<li><strong>手动兜底</strong>：面对新壳（如定制 VMProtect）、特征库未覆盖的壳，通过区段 + 入口特征定位脱壳方向。</li>
</ul>
<p><strong>总结</strong>：查壳工具是 “快速筛子”，手动分析是 “深度探针”，两者结合可覆盖绝大多数加壳识别场景。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="无壳的-NET-程序"><a href="#无壳的-NET-程序" class="headerlink" title="无壳的 .NET 程序"></a>无壳的 .NET 程序</h3><p>文件：吾爱破解论坛学习脱壳实例_.NET.rar</p>
<p>工具：Exeinfo PE</p>
<h4 id="一、核心信息解读"><a href="#一、核心信息解读" class="headerlink" title="一、核心信息解读"></a><strong>一、核心信息解读</strong></h4><ol>
<li><p><strong>编译器与平台</strong>：<br> Exeinfo PE 检测显示：<code>MS Visual C# / Basic.NET [Link 11]</code>，说明程序由 <strong>.NET 框架</strong> 编写（C# 或 <a href="https://vb.net/">VB.NET</a> 语言），链接器版本对应 .NET Framework 相关编译工具（如 Visual Studio 的 C# 编译器）。</p>
</li>
<li><p><strong>是否加壳</strong>：</p>
<ul>
<li>工具未报 “加壳” 相关标识（如 <code>Packed by XXX</code>），反而提示 <code>try Analyze with .NET Reflector</code>（建议用 .NET 反编译工具分析），说明 <strong>程序无传统加密壳</strong>（传统壳会篡改区段 &#x2F; 入口，此程序区段规范、检测逻辑指向原生 .NET 程序）。</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508200022298.png"></p>
</li>
</ol>
<h4 id="二、区段特征分析（3-个区段，符合无壳-NET-程序规律）"><a href="#二、区段特征分析（3-个区段，符合无壳-NET-程序规律）" class="headerlink" title="二、区段特征分析（3 个区段，符合无壳 .NET 程序规律）"></a><strong>二、区段特征分析（3 个区段，符合无壳 .NET 程序规律）</strong></h4><table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>属性（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><code>00002000</code></td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>IL 代码</strong>（.NET 中间语言）和预编译的本机代码，是程序逻辑核心区。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td><code>00006000</code></td>
<td>只读（Read）</td>
<td>存储程序资源（图标、字符串、版本信息等），无执行属性，符合资源段规范。</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td><code>00008000</code></td>
<td>只读（Read）</td>
<td>存储基址重定位信息，适配 Windows 加载器的 ASLR 机制，是 PE 格式的标准区段。</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508200022526.png"></p>
<h4 id="三、-NET-程序的-“非壳”-保护说明"><a href="#三、-NET-程序的-“非壳”-保护说明" class="headerlink" title="三、.NET 程序的 “非壳” 保护说明"></a><strong>三、.NET 程序的 “非壳” 保护说明</strong></h4><p>虽然程序无 <strong>传统加密壳</strong>（如 UPX、VMProtect），但 .NET 程序常通过 <strong>代码混淆器</strong>（如 ConfuserEx、SmartAssembly）进行保护：</p>
<ul>
<li>混淆 vs 加壳：<ul>
<li>加壳：加密 PE 代码段，运行时动态解密（篡改区段、入口逻辑）；</li>
<li>混淆：修改 IL 代码结构（如重命名类 &#x2F; 方法、插入冗余代码），但 <strong>不改变 PE 区段的原生性</strong>（区段名、属性仍符合 .NET 程序特征）。</li>
</ul>
</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>文件本质</strong>：无壳的 .NET 程序（C#&#x2F;<a href="https://vb.net/">VB.NET</a> 编写），依赖 .NET Framework 运行时。</p>
<h3 id="AutoIt-脚本编译的可执行程序"><a href="#AutoIt-脚本编译的可执行程序" class="headerlink" title="AutoIt 脚本编译的可执行程序"></a><strong>AutoIt 脚本编译的可执行程序</strong></h3><p>(AutoIt 编译的程序并非传统加密壳，而是 <strong>脚本打包器产物</strong>)</p>
<h4 id="一、核心识别结论"><a href="#一、核心识别结论" class="headerlink" title="一、核心识别结论"></a>一、核心识别结论</h4><ol>
<li><p><strong>Exeinfo PE 关键提示</strong>：</p>
<ul>
<li>底部信息：<code>AutoIt v3.3.12.0 - Jonathan Bennett &amp; AutoIt Team</code> → 明确为 <strong>AutoIt 编译产物</strong>（AutoIt 是 Windows 脚本语言，编译后生成 EXE，内置解释器 + 脚本）。</li>
<li>附加说明：<code>Exe2Aut.exe decompiler, &quot;AU3&quot; packed scr...</code> → 可通过 <code>Exe2Aut</code> 工具 <strong>反编译提取内部 AU3 脚本</strong>，暗示程序内含 “打包的脚本数据”。</li>
</ul>
<p> <img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820003429667.png" alt="上传失败，待操作"></p>
</li>
</ol>
<h4 id="二、Autolt编译程序的“打包特征”分析"><a href="#二、Autolt编译程序的“打包特征”分析" class="headerlink" title="二、Autolt编译程序的“打包特征”分析"></a>二、Autolt编译程序的“打包特征”分析</h4><ol>
<li><strong>区段与数据特征</strong></li>
</ol>
<ul>
<li><p><strong>区段命名</strong>：<code>.text</code>（代码段，存 AutoIt 解释器代码）、<code>.rdata</code>（只读数据，存字符串 &#x2F; 导入表）、<code>.data</code>（全局数据，存脚本压缩包）、<code>.rsrc</code>（资源，存图标等），命名规范但 <strong>数据段隐藏脚本</strong>。</p>
</li>
<li><p><strong>数据隐藏</strong>：</p>
<ul>
<li><code>.data</code> 或 <code>.rdata</code> 段可能包含 <strong>压缩的 AU3 脚本数据</strong>（AutoIt 编译时会将脚本压缩后嵌入 EXE），可通过 <code>Exe2Aut</code> 解包提取。</li>
<li>区段的 <code>First bytes</code> 无明显加密特征（因是 “打包” 而非 “加密壳”，脚本仅压缩，未加密）。</li>
</ul>
<p>  <img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820003545070.png" alt="上传失败，待操作"></p>
</li>
</ul>
<h4 id="2-入口代码与运行时特征（OllyDbg-视角）"><a href="#2-入口代码与运行时特征（OllyDbg-视角）" class="headerlink" title="2. 入口代码与运行时特征（OllyDbg 视角）"></a>2. <strong>入口代码与运行时特征（OllyDbg 视角）</strong></h4><ul>
<li><strong>入口指令</strong>：<code>CALL 吾爱破解.00B62DE3</code> → 调用 <strong>AutoIt 解释器的初始化函数</strong>（负责解压脚本、加载运行时环境），而非传统壳的 “解密代码”。</li>
<li><strong>运行时依赖</strong>：导入表会包含 <code>AutoIt3.dll</code> 相关函数（若动态链接），或直接内置解释器代码（静态编译，体积较大）</li>
</ul>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820003736416.png" alt="上传失败，待操作"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>该程序 <strong>不是传统加密壳</strong>，而是 <strong>AutoIt 脚本的编译产物</strong>，其 “打包特征” 体现在：</p>
<ul>
<li>内置 AutoIt 解释器，区段隐藏压缩脚本；</li>
<li>可被 <code>Exe2Aut</code> 等工具直接解包；</li>
<li>入口指向解释器初始化函数，而非解密逻辑。</li>
</ul>
<h3 id="TASM-FASM-编译"><a href="#TASM-FASM-编译" class="headerlink" title="TASM&#x2F;FASM 编译"></a><strong>TASM&#x2F;FASM 编译</strong></h3><p>(纯汇编编写的无壳程序)</p>
<h4 id="一、核心结论"><a href="#一、核心结论" class="headerlink" title="一、核心结论"></a>一、核心结论</h4><ol>
<li><strong>编译器与类型</strong>：<br> Exeinfo PE 检测显示：<code>TASM / FASM (MASM - compatible assembler) - Linker: 5.12</code>，说明程序由 <strong>TASM（Turbo Assembler）或 FASM（Flat Assembler，兼容 MASM 语法）</strong> 编译，属于 <strong>手写汇编程序</strong>（无高级语言依赖）。</li>
<li><strong>是否加壳</strong>：<ul>
<li>工具明确标记 <code>Not packed</code>（未加壳）；</li>
<li>区段、入口、导入表均符合 <strong>原生 PE 程序特征</strong>（无壳的篡改痕迹）。</li>
</ul>
</li>
</ol>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820004419185.png" alt="上传失败，待操作"></p>
<h4 id="二、无壳特征的多维度验证"><a href="#二、无壳特征的多维度验证" class="headerlink" title="二、无壳特征的多维度验证"></a>二、无壳特征的多维度验证</h4><h4 id="1-区段特征（4-个规范区段）"><a href="#1-区段特征（4-个规范区段）" class="headerlink" title="1. 区段特征（4 个规范区段）"></a>1. <strong>区段特征（4 个规范区段）</strong></h4><table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>标志（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><code>00001000</code></td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>手写汇编指令</strong>（程序核心逻辑），指令直接对应机器码，无加密 &#x2F; 混淆。</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td><code>00002000</code></td>
<td>只读（Read）</td>
<td>存储 <strong>只读常量</strong>（如字符串、API 导入表），数据未加密，可直接解析。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td><code>00003000</code></td>
<td>可读写（Read&#x2F;Write）</td>
<td>存储 <strong>全局变量</strong>（如未初始化数据），无异常属性（如壳会将数据段标记为可执行）。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td><code>00004000</code></td>
<td>只读（Read）</td>
<td>存储 <strong>资源数据</strong>（如图标、版本信息），命名和属性均符合 PE 标准，无篡改。</td>
</tr>
</tbody></table>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820004519962.png" alt="上传失败，待操作"></p>
<h4 id="2-入口代码特征（OllyDbg-反汇编）"><a href="#2-入口代码特征（OllyDbg-反汇编）" class="headerlink" title="2. 入口代码特征（OllyDbg 反汇编）"></a>2. <strong>入口代码特征（OllyDbg 反汇编）</strong></h4><ul>
<li><strong>指令逻辑</strong>：入口 <code>00401088</code> 处直接调用 <strong>系统 API</strong>（如 <code>kernel32.GetModuleHandleA</code>、<code>user32.DialogBoxParamA</code>），无壳的 <strong>解密 &#x2F; 解压前置逻辑</strong>（如循环异或、跳转混淆）。</li>
<li><strong>调用链</strong>：所有调用均指向 <code>kernel32.dll</code>、<code>user32.dll</code> 等系统库，无异常第三方库（如壳的运行时库），符合 <strong>纯汇编程序直接调用系统 API 的特征</strong>。</li>
</ul>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820004623283.png" alt="上传失败，待操作"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>该程序是 <strong>TASM&#x2F;FASM 编译的纯汇编无壳程序</strong>，特征为：</p>
<ul>
<li>汇编器编译标识明确，无加壳标记；</li>
<li>区段规范、属性正常，无篡改；</li>
<li>入口直接调用系统 API，逻辑清晰，无混淆。</li>
</ul>
<h3 id="Borland-C-6-0-编译无壳程序"><a href="#Borland-C-6-0-编译无壳程序" class="headerlink" title="Borland C++ 6.0 编译无壳程序"></a>Borland C++ 6.0 编译无壳程序</h3><h4 id="一、编译器与无壳的核心判定"><a href="#一、编译器与无壳的核心判定" class="headerlink" title="一、编译器与无壳的核心判定"></a><strong>一、编译器与无壳的核心判定</strong></h4><ol>
<li><p><strong>ExeinfoPE 关键标识</strong>：</p>
<ul>
<li>检测结果：<code>Borland C++ - Copyright 2002 Borland Info Corporation</code> → 明确为 <strong>Borland C++ 6.0</strong> 编译（经典老版 C++ 编译器，区别于微软 VC）。</li>
<li>链接器版本：<code>Linker Info: 5.00</code> → 匹配 BC++6 的默认链接器版本。</li>
<li>加壳判定：<code>Not packed</code>（未加壳），结合区段、入口特征验证。</li>
</ul>
<p> <img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820012853947.png" alt="上传失败，待操作"></p>
</li>
</ol>
<h4 id="二、区段特征（8-个区段的结构解析）"><a href="#二、区段特征（8-个区段的结构解析）" class="headerlink" title="二、区段特征（8 个区段的结构解析）"></a><strong>二、区段特征（8 个区段的结构解析）</strong></h4><p>BC++6 编译的程序区段 <strong>划分更细</strong>（对比 VC6 的 4 个区段），典型区段及意义：</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>标志（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>程序指令</strong>，包含 Borland C++ 运行时初始化逻辑（区别于 VC 的 MSVCRT 依赖）。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>可读写（Read&#x2F;Write）</td>
<td>存储 <strong>全局 &#x2F; 静态变量</strong>，BC++6 的数据段可能包含 Borland 运行库的初始化数据。</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读段</td>
<td>只读（Read）</td>
<td>存储 <strong>常量、字符串、只读数据</strong>，但 **导入表独立存于 <code>.idata</code>**（VC6 常将导入表放 <code>.rdata</code>）。</td>
</tr>
<tr>
<td><code>.idata</code></td>
<td>导入段</td>
<td>只读（Read）</td>
<td>单独存储 <strong>导入表</strong>（系统 API 及 Borland 运行库函数），结构清晰，便于逆向分析。</td>
</tr>
<tr>
<td><code>.edata</code></td>
<td>导出段</td>
<td>可执行（Execute）+ 读（Read）</td>
<td>若程序有导出函数，会单独存于 <code>.edata</code>（VC6 通常无此区段，或合并到其他段）。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>只读（Read）</td>
<td>存储 <strong>图标、对话框、版本信息</strong>，命名和结构符合 PE 标准，无混淆。</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td>重定位段</td>
<td>只读（Read）</td>
<td>存储基址重定位信息，适配 Windows 加载器（类似 VS 系列的 <code>.reloc</code>，但 BC++6 更少见）。</td>
</tr>
</tbody></table>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820012917209.png" alt="上传失败，待操作"></p>
<h4 id="三、入口代码与运行时特征（OllyDbg-视角）"><a href="#三、入口代码与运行时特征（OllyDbg-视角）" class="headerlink" title="三、入口代码与运行时特征（OllyDbg 视角）"></a><strong>三、入口代码与运行时特征（OllyDbg 视角）</strong></h4><ol>
<li><strong>入口指令逻辑</strong>：<ul>
<li>入口 <code>004012FC</code> 处可见 <code>JMP SHORT</code> 跳转 + 连续 <code>DB</code> 指令（如 <code>DB 66</code>、<code>DB 32</code>）→ 这些 <code>DB</code> 是 <strong>嵌入代码段的字符串或常量</strong>（BC++6 编译时会将短字符串直接放在代码段附近，而非单独的 <code>.rdata</code> 偏移，是老编译器的特征）。</li>
<li>后续调用 <code>kernel32.GetModuleHandleA</code> 等系统 API，同时隐含 <strong>Borland 运行库的初始化逻辑</strong>（如内存管理、异常处理，因 BC++6 依赖自身运行库 <code>borlndmm.dll</code> 等，若静态链接则无导入，需从代码中识别）。</li>
</ul>
</li>
<li><strong>运行时依赖</strong>：<ul>
<li>若动态链接 Borland 库，导入表会含 <code>borlndmm.dll</code>（内存管理）、<code>vcl60.bpl</code>（VCL 组件，若用可视化库）；</li>
<li>若静态链接，导入表仅含系统 API（如 <code>kernel32.dll</code>、<code>user32.dll</code>），但程序体积更大（内置 Borland 运行时代码）。</li>
</ul>
</li>
</ol>
<p><img src="/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81.assets/image-20250820012956352.png" alt="待操作"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>该程序是 <strong>Borland C++ 6.0 编译的无壳原生程序</strong>，特征为：</p>
<ul>
<li>编译器标识明确，工具判定无壳；</li>
<li>区段划分精细（8 个区段，含独立导入段 <code>.idata</code>）；</li>
<li>代码段嵌入短字符串（<code>DB</code> 指令），运行时隐含 Borland 库逻辑；</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>smali</title>
    <url>/2025/08/21/smali/</url>
    <content><![CDATA[<h2 id="一、什么是-Smali？"><a href="#一、什么是-Smali？" class="headerlink" title="一、什么是 Smali？"></a>一、什么是 Smali？</h2><p>你可以把 Smali 理解为**Android 应用的 “汇编语言”**。就像电脑程序的 C 语言会被编译成汇编语言一样，Android 的 Java 代码会被编译成<code>.dex</code>文件，而 Smali 就是<code>.dex</code>文件反编译后的 “可读形式”。</p>
<ul>
<li>作用：修改 Smali 代码 &#x3D; 直接修改 Android 应用的逻辑（比如破解付费功能、去除广告）</li>
<li>特点：基于 “寄存器” 工作（所有数据都存在寄存器里，类似我们用的变量）</li>
<li>工具：通过 APKTool 等工具可以把 APK 里的<code>.dex</code>文件转成 Smali 代码，修改后再转回去</li>
</ul>
<h2 id="二、最基础的结构：寄存器"><a href="#二、最基础的结构：寄存器" class="headerlink" title="二、最基础的结构：寄存器"></a>二、最基础的结构：寄存器</h2><p>Smali 里没有 “变量名”，所有数据都存在<strong>寄存器</strong>里，就像一个个小盒子，每个盒子有编号。</p>
<h3 id="2-1-寄存器的两种类型"><a href="#2-1-寄存器的两种类型" class="headerlink" title="2.1 寄存器的两种类型"></a>2.1 寄存器的两种类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>命名</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>局部寄存器</td>
<td>v0, v1, v2…</td>
<td>存方法里的临时数据（类似 Java 的局部变量）</td>
<td>v0 存一个数字，v1 存一个字符串</td>
</tr>
<tr>
<td>参数寄存器</td>
<td>p0, p1, p2…</td>
<td>存方法的参数（包括特殊的<code>this</code>）</td>
<td>调用<code>setName(&quot;张三&quot;)</code>时，p1 存 “张三”</td>
</tr>
</tbody></table>
<h3 id="2-2-关键区别：静态方法-vs-非静态方法的参数寄存器"><a href="#2-2-关键区别：静态方法-vs-非静态方法的参数寄存器" class="headerlink" title="2.2 关键区别：静态方法 vs 非静态方法的参数寄存器"></a>2.2 关键区别：静态方法 vs 非静态方法的参数寄存器</h3><ul>
<li><strong>非静态方法</strong>（普通方法）：p0 固定是<code>this</code>（当前对象），p1 才是第一个参数<br>  例：Java 的<code>void eat(String food)</code>，Smali 中 p0 是 “这个对象”，p1 是 food 参数</li>
<li><strong>静态方法</strong>（带 static 的方法）：没有<code>this</code>，p0 直接是第一个参数<br>  例：Java 的<code>static int add(int a, int b)</code>，Smali 中 p0 是 a，p1 是 b</li>
</ul>
<h2 id="三、类的声明（对应-Java-的-class）"><a href="#三、类的声明（对应-Java-的-class）" class="headerlink" title="三、类的声明（对应 Java 的 class）"></a>三、类的声明（对应 Java 的 class）</h2><h3 id="3-1-基本格式（必须掌握）"><a href="#3-1-基本格式（必须掌握）" class="headerlink" title="3.1 基本格式（必须掌握）"></a>3.1 基本格式（必须掌握）</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span> 权限修饰符 类的全路径;  // 声明类（类似Java的<span class="string">&quot;public class 包名.类名&quot;</span>）</span><br><span class="line"><span class="keyword">.super</span> 父类全路径;  // 声明父类（类似Java的<span class="string">&quot;extends 父类&quot;</span>）</span><br><span class="line"><span class="keyword">.implements</span> 接口全路径;  // 声明实现的接口（类似Java的<span class="string">&quot;implements 接口&quot;</span>）</span><br><span class="line"><span class="keyword">.source</span> <span class="string">&quot;Java文件名.java&quot;</span>  // 对应Java源码文件（可选，混淆后可能没有）</span><br></pre></td></tr></table></figure>

<h3 id="3-2-实例（对照-Java-看更清楚）"><a href="#3-2-实例（对照-Java-看更清楚）" class="headerlink" title="3.2 实例（对照 Java 看更清楚）"></a>3.2 实例（对照 Java 看更清楚）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="comment">// 类内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/example/Student;</span>  // <span class="class">L开头+包名/类名+;</span>结尾（固定格式）</span><br><span class="line"><span class="keyword">.super</span> <span class="class">Lcom/example/Person;</span>  // 父类是Person</span><br><span class="line"><span class="keyword">.implements</span> <span class="class">Lcom/example/Study;</span>  // 实现Study接口</span><br><span class="line"><span class="keyword">.source</span> <span class="string">&quot;Student.java&quot;</span>  // 对应Java文件</span><br></pre></td></tr></table></figure>

<h3 id="3-3-特别注意"><a href="#3-3-特别注意" class="headerlink" title="3.3 特别注意"></a>3.3 特别注意</h3><ul>
<li>所有类 &#x2F; 接口的全路径必须以<code>L</code>开头，以<code>;</code>结尾（比如<code>Ljava/lang/String;</code>对应<code>java.lang.String</code>）</li>
<li>如果类在某个类内部（内部类），用<code>$</code>连接，比如<code>Student$Score</code>对应 Smali 的<code>Lcom/example/Student$Score;</code></li>
</ul>
<h2 id="四、字段（对应-Java-的成员变量）"><a href="#四、字段（对应-Java-的成员变量）" class="headerlink" title="四、字段（对应 Java 的成员变量）"></a>四、字段（对应 Java 的成员变量）</h2><p>字段就是类里的变量（包括静态变量和非静态变量），声明格式很固定。</p>
<h3 id="4-1-基本格式"><a href="#4-1-基本格式" class="headerlink" title="4.1 基本格式"></a>4.1 基本格式</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.field</span> 权限修饰符 静态修饰符 变量名:变量类型;</span><br></pre></td></tr></table></figure>

<ul>
<li>权限修饰符：<code>public</code>&#x2F;<code>private</code>&#x2F;<code>protected</code>（和 Java 一样）</li>
<li>静态修饰符：<code>static</code>（静态变量加，非静态不加）</li>
<li>变量类型：Smali 的特殊写法（后面会详细讲）</li>
</ul>
<h3 id="4-2-实例（对照-Java）"><a href="#4-2-实例（对照-Java）" class="headerlink" title="4.2 实例（对照 Java）"></a>4.2 实例（对照 Java）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 非静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;  <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> isMale;  <span class="comment">// 非静态字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/example/Student;</span></span><br><span class="line"><span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非静态字段：private String name;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span> name:<span class="class">Ljava/lang/String;</span>  // 类型是String（<span class="class">Ljava/lang/String;</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态字段：public static int age;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> public</span><span class="keyword"> static</span> age:I  // 类型是int（I）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非静态字段：protected boolean isMale;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> protected</span> isMale:Z  // 类型是boolean（Z）</span><br></pre></td></tr></table></figure>

<h2 id="五、数据类型（Smali-的-“密码本”）"><a href="#五、数据类型（Smali-的-“密码本”）" class="headerlink" title="五、数据类型（Smali 的 “密码本”）"></a>五、数据类型（Smali 的 “密码本”）</h2><p>Smali 的类型写法和 Java 完全不同，必须死记！这是看懂 Smali 的基础。</p>
<h3 id="5-1-基本类型（简单类型）"><a href="#5-1-基本类型（简单类型）" class="headerlink" title="5.1 基本类型（简单类型）"></a>5.1 基本类型（简单类型）</h3><table>
<thead>
<tr>
<th>Smali 类型</th>
<th>对应 Java 类型</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>int（整数）</td>
<td>123、-45</td>
</tr>
<tr>
<td>Z</td>
<td>boolean（布尔）</td>
<td>true（1）、false（0）</td>
</tr>
<tr>
<td>B</td>
<td>byte（字节）</td>
<td>0~255 的数</td>
</tr>
<tr>
<td>C</td>
<td>char（字符）</td>
<td>‘A’、’ 中’</td>
</tr>
<tr>
<td>S</td>
<td>short（短整数）</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>J</td>
<td>long（长整数）</td>
<td>超过 int 范围的数（占 2 个寄存器）</td>
</tr>
<tr>
<td>F</td>
<td>float（单精度浮点数）</td>
<td>3.14f</td>
</tr>
<tr>
<td>D</td>
<td>double（双精度浮点数）</td>
<td>3.1415926（占 2 个寄存器）</td>
</tr>
</tbody></table>
<h3 id="5-2-引用类型（对象-数组）"><a href="#5-2-引用类型（对象-数组）" class="headerlink" title="5.2 引用类型（对象 &#x2F; 数组）"></a>5.2 引用类型（对象 &#x2F; 数组）</h3><table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>对应 Java</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>类类型</td>
<td>L 包名 &#x2F; 类名；</td>
<td>类对象</td>
<td><code>Ljava/lang/String;</code> → <code>String</code></td>
</tr>
<tr>
<td>数组类型</td>
<td>[元素类型</td>
<td>数组</td>
<td><code>[I</code> → <code>int[]</code>；<code>[Ljava/lang/String;</code> → <code>String[]</code></td>
</tr>
<tr>
<td>多维数组</td>
<td>[[元素类型（几维就加几个 [）</td>
<td>多维数组</td>
<td><code>[[I</code> → <code>int[][]</code>；<code>[[[B</code> → <code>byte[][][]</code></td>
</tr>
</tbody></table>
<h3 id="5-3-方法签名（方法的-“身份证”）"><a href="#5-3-方法签名（方法的-“身份证”）" class="headerlink" title="5.3 方法签名（方法的 “身份证”）"></a>5.3 方法签名（方法的 “身份证”）</h3><p>Smali 用 “方法签名” 表示方法，格式：<code>方法名(参数类型列表)返回值类型</code><br>参数之间没有分隔符，直接连写！</p>
<p><strong>例子</strong>：</p>
<table>
<thead>
<tr>
<th>Smali 签名</th>
<th>对应 Java 方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>getName()Ljava/lang/String;</code></td>
<td><code>String getName()</code></td>
</tr>
<tr>
<td><code>setAge(I)V</code></td>
<td><code>void setAge(int age)</code></td>
</tr>
<tr>
<td><code>add(IF)F</code></td>
<td><code>float add(int a, float b)</code></td>
</tr>
<tr>
<td><code>show(String[] arr, int num)Z</code> → 签名是<code>show([Ljava/lang/String;I)Z</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="六、方法的声明与实现"><a href="#六、方法的声明与实现" class="headerlink" title="六、方法的声明与实现"></a>六、方法的声明与实现</h2><p>方法是 Smali 的核心，所有逻辑都在这里写。</p>
<h3 id="6-1-方法的基本结构"><a href="#6-1-方法的基本结构" class="headerlink" title="6.1 方法的基本结构"></a>6.1 方法的基本结构</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span> 权限修饰符 静态修饰符 方法签名  // 方法声明（类似Java的<span class="string">&quot;public static int add(int a)&quot;</span>）</span><br><span class="line"><span class="keyword">    .locals</span> N  // 局部寄存器的数量（v0到vN-1）</span><br><span class="line"><span class="keyword">    .prologue</span>  // 代码开始的标记（固定加）</span><br><span class="line"><span class="keyword">    .line</span> 10  // 对应Java源码的行号（可选，删除不影响运行）</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法体（具体逻辑）</span></span><br><span class="line">    </span><br><span class="line">    返回指令  // 比如return-void（返回空）<span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span>  // 方法结束标记</span><br></pre></td></tr></table></figure>

<h3 id="6-2-实例：简单方法（对照-Java）"><a href="#6-2-实例：简单方法（对照-Java）" class="headerlink" title="6.2 实例：简单方法（对照 Java）"></a>6.2 实例：简单方法（对照 Java）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非静态方法：设置名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> setName(<span class="class">Ljava/lang/String;</span>)V  // 方法签名：参数是String，返回void</span><br><span class="line"><span class="keyword">    .locals</span> 0  // 不需要局部寄存器（v0都不用）</span><br><span class="line"><span class="keyword">    .prologue</span>  // 代码开始</span><br><span class="line"><span class="keyword">    .line</span> 8  // 对应Java第8行</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 核心逻辑：this.name = newName</span></span><br><span class="line">    <span class="comment"># p0是this（当前Student对象），p1是newName参数</span></span><br><span class="line">   <span class="built_in"> iput-object </span>p1, p0, <span class="class">Lcom/example/Student;</span>-&gt;name:<span class="class">Ljava/lang/String;</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void </span> // 返回空<span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-特殊方法：构造方法（）"><a href="#6-3-特殊方法：构造方法（）" class="headerlink" title="6.3 特殊方法：构造方法（）"></a>6.3 特殊方法：构造方法（<init>）</h3><p>构造方法是创建对象时调用的方法，Smali 中固定叫<code>&lt;init&gt;</code>，必须调用父类的构造方法！</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;  <span class="comment">// 给name赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> &lt;init&gt;(<span class="class">Ljava/lang/String;</span>)V  // 构造方法固定叫&lt;init&gt;</span><br><span class="line"><span class="keyword">    .locals</span> 0</span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 5</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一步：必须调用父类的构造方法（Object的构造方法）</span></span><br><span class="line">   <span class="built_in"> invoke-direct </span>&#123;p0&#125;, <span class="class">Ljava/lang/Object;</span>-&gt;&lt;init&gt;()V  // p0是this</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二步：给当前对象的name赋值（this.name = 参数name）</span></span><br><span class="line">   <span class="built_in"> iput-object </span>p1, p0, <span class="class">Lcom/example/Student;</span>-&gt;name:<span class="class">Ljava/lang/String;</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-特殊方法：静态代码块（）"><a href="#6-4-特殊方法：静态代码块（）" class="headerlink" title="6.4 特殊方法：静态代码块（）"></a>6.4 特殊方法：静态代码块（<clinit>）</h3><p>Java 的静态代码块（<code>static &#123; ... &#125;</code>）在 Smali 中对应<code>&lt;clinit&gt;</code>方法，用于初始化静态字段。</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        school = <span class="string">&quot;阳光小学&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.field</span><span class="keyword"> public</span><span class="keyword"> static</span> school:<span class="class">Ljava/lang/String;</span>  // 静态字段school</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态代码块对应&lt;clinit&gt;方法（静态构造方法）</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> static</span><span class="keyword"> constructor</span> &lt;clinit&gt;()V  // 固定写法</span><br><span class="line"><span class="keyword">    .locals</span> 1  // 需要1个局部寄存器v0</span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 4</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 给静态字段school赋值</span></span><br><span class="line">   <span class="built_in"> const-string </span>v0, <span class="string">&quot;阳光小学&quot;</span>  // v0存字符串<span class="string">&quot;阳光小学&quot;</span></span><br><span class="line">   <span class="built_in"> sput-object </span>v0, <span class="class">Lcom/example/Student;</span>-&gt;school:<span class="class">Ljava/lang/String;</span>  // 存入静态字段</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="七、常用指令（Smali-的-“动词”）"><a href="#七、常用指令（Smali-的-“动词”）" class="headerlink" title="七、常用指令（Smali 的 “动词”）"></a>七、常用指令（Smali 的 “动词”）</h2><p>指令是 Smali 的动作，比如 “赋值”、”调用方法”、”跳转” 等，必须掌握常用的。</p>
<h3 id="7-1-赋值指令（给寄存器存数据）"><a href="#7-1-赋值指令（给寄存器存数据）" class="headerlink" title="7.1 赋值指令（给寄存器存数据）"></a>7.1 赋值指令（给寄存器存数据）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>const&#x2F;4 vA, 0xN</td>
<td>存一个小整数（-8 到 7）到 vA</td>
<td><code>const/4 v0, 0x1</code> → v0&#x3D;1</td>
</tr>
<tr>
<td>const&#x2F;16 vA, 0xN</td>
<td>存中等整数（-32768 到 32767）到 vA</td>
<td><code>const/16 v0, 0x100</code> → v0&#x3D;256</td>
</tr>
<tr>
<td>const-string vA, “内容”</td>
<td>存字符串到 vA</td>
<td><code>const-string v0, &quot;你好&quot;</code> → v0&#x3D;”你好”</td>
</tr>
<tr>
<td>const-class vA, L 类名；</td>
<td>存类的 Class 对象到 vA</td>
<td><code>const-class v0, Ljava/lang/String;</code> → v0&#x3D;String.class</td>
</tr>
</tbody></table>
<h3 id="7-2-字段操作指令（存-取字段的值）"><a href="#7-2-字段操作指令（存-取字段的值）" class="headerlink" title="7.2 字段操作指令（存 &#x2F; 取字段的值）"></a>7.2 字段操作指令（存 &#x2F; 取字段的值）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>iget-object vA, vB, 字段</td>
<td>从 vB 对象中取 “对象类型字段” 到 vA</td>
<td><code>iget-object v0, p0, LStudent;-&gt;name:LString;</code> → v0 &#x3D; this.name</td>
</tr>
<tr>
<td>iput-object vA, vB, 字段</td>
<td>把 vA 的对象存入 vB 对象的 “对象类型字段”</td>
<td><code>iput-object v0, p0, LStudent;-&gt;name:LString;</code> → this.name &#x3D; v0</td>
</tr>
<tr>
<td>sget-object vA, 静态字段</td>
<td>取 “静态对象字段” 到 vA</td>
<td><code>sget-object v0, LStudent;-&gt;school:LString;</code> → v0 &#x3D; Student.school</td>
</tr>
<tr>
<td>sput-object vA, 静态字段</td>
<td>把 vA 的对象存入 “静态对象字段”</td>
<td><code>sput-object v0, LStudent;-&gt;school:LString;</code> → Student.school &#x3D; v0</td>
</tr>
<tr>
<td>iget vA, vB, 字段</td>
<td>取 “基本类型字段”（int 等）到 vA</td>
<td><code>iget v0, p0, LStudent;-&gt;age:I</code> → v0 &#x3D; this.age</td>
</tr>
<tr>
<td>iput vA, vB, 字段</td>
<td>存 “基本类型字段”（int 等）</td>
<td><code>iput v0, p0, LStudent;-&gt;age:I</code> → this.age &#x3D; v0</td>
</tr>
</tbody></table>
<h3 id="7-3-方法调用指令（执行另一个方法）"><a href="#7-3-方法调用指令（执行另一个方法）" class="headerlink" title="7.3 方法调用指令（执行另一个方法）"></a>7.3 方法调用指令（执行另一个方法）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>invoke-virtual {参数}, 方法签名</td>
<td>调用普通方法（非私有、非静态）</td>
<td><code>invoke-virtual &#123;p0&#125;, LStudent;-&gt;getName()LString;</code> → 调用 this.getName ()</td>
</tr>
<tr>
<td>invoke-static {参数}, 方法签名</td>
<td>调用静态方法</td>
<td><code>invoke-static &#123;v0&#125;, LInteger;-&gt;parseInt(LString;)I</code> → 调用 Integer.parseInt (v0)</td>
</tr>
<tr>
<td>invoke-direct {参数}, 方法签名</td>
<td>调用私有方法或构造方法</td>
<td><code>invoke-direct &#123;p0&#125;, LObject;-&gt;&lt;init&gt;()V</code> → 调用父类构造方法</td>
</tr>
</tbody></table>
<p><strong>调用后取返回值</strong>：</p>
<ul>
<li>若方法返回对象（如 String）：<code>move-result-object vA</code> → 把结果存到 vA</li>
<li>若方法返回基本类型（如 int）：<code>move-result vA</code> → 把结果存到 vA</li>
</ul>
<p><strong>例子</strong>：调用<code>Integer.parseInt(&quot;123&quot;)</code>并获取结果</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">const-string v0, <span class="string">&quot;123&quot;</span>  // v0 = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="comment"># 调用静态方法：Integer.parseInt(&quot;123&quot;)</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">invoke-static </span>&#123;v0&#125;, <span class="class">Ljava/lang/Integer;</span>-&gt;parseInt(<span class="class">Ljava/lang/String;</span>)I<span class="built_in"></span></span><br><span class="line"><span class="built_in">move-result </span>v1  // 把返回的int值存到v1（v1=123）</span><br></pre></td></tr></table></figure>

<h3 id="7-4-条件跳转指令（做判断）"><a href="#7-4-条件跳转指令（做判断）" class="headerlink" title="7.4 条件跳转指令（做判断）"></a>7.4 条件跳转指令（做判断）</h3><p>条件跳转就像 Java 的<code>if</code>语句，满足条件就跳到指定标签（如<code>:cond_0</code>）。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用（满足条件则跳转）</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>if-eq vA, vB, :label</td>
<td>vA &#x3D;&#x3D; vB</td>
<td><code>if-eq v0, v1, :cond_0</code> → 若 v0 等于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-ne vA, vB, :label</td>
<td>vA !&#x3D; vB</td>
<td><code>if-ne v0, v1, :cond_0</code> → 若 v0 不等于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-lt vA, vB, :label</td>
<td>vA &lt; vB</td>
<td><code>if-lt v0, v1, :cond_0</code> → 若 v0 小于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-gt vA, vB, :label</td>
<td>vA &gt; vB</td>
<td><code>if-gt v0, v1, :cond_0</code> → 若 v0 大于 v1，跳去:cond_0</td>
</tr>
</tbody></table>
<p><strong>例子</strong>：判断年龄是否大于 18</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设v0存年龄（比如20）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const/4 </span>v1, 0x12  <span class="comment"># v1 = 18（0x12是18的十六进制）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">if-gt </span>v0, v1,<span class="keyword"> :is_adult</span>  <span class="comment"># 若v0&gt;v1（20&gt;18），跳去:is_adult</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未成年人逻辑</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;未成年&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">goto </span>:end  <span class="comment"># 跳过成年人逻辑</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">:is_adult</span>  <span class="comment"># 成年人标签</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;成年人&quot;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">:end</span>  <span class="comment"># 结束标签</span></span><br><span class="line"><span class="comment"># 最终v2的值是&quot;成年人&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-数组操作指令（数组的增删改查）"><a href="#7-5-数组操作指令（数组的增删改查）" class="headerlink" title="7.5 数组操作指令（数组的增删改查）"></a>7.5 数组操作指令（数组的增删改查）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>new-array vA, vB, [类型</td>
<td>创建长度为 vB 的数组，存到 vA</td>
<td><code>new-array v0, v1, [I</code> → 创建 int 数组，长度 v1，存到 v0</td>
</tr>
<tr>
<td>aget-object vA, vB, vC</td>
<td>取数组 vB 中索引 vC 的对象到 vA</td>
<td><code>aget-object v0, v1, v2</code> → v0 &#x3D; v1 [v2]（v1 是 String []）</td>
</tr>
<tr>
<td>aput-object vA, vB, vC</td>
<td>把 vA 的对象存入数组 vB 的索引 vC</td>
<td><code>aput-object v0, v1, v2</code> → v1[v2] &#x3D; v0</td>
</tr>
<tr>
<td>array-length vA, vB</td>
<td>取数组 vB 的长度到 vA</td>
<td><code>array-length v0, v1</code> → v0 &#x3D; v1.length</td>
</tr>
</tbody></table>
<p><strong>例子</strong>：创建 String 数组并赋值</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">const/4 v0, 0x2  <span class="comment"># v0=2（数组长度）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">new-array </span>v1, v0, [<span class="class">Ljava/lang/String;</span>  <span class="comment"># 创建长度2的String数组，存到v1</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;苹果&quot;</span>  <span class="comment"># v2=&quot;苹果&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">aput-object </span>v2, v1, 0x0  <span class="comment"># 数组[0] = &quot;苹果&quot;</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;香蕉&quot;</span>  <span class="comment"># v2=&quot;香蕉&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">aput-object </span>v2, v1, 0x1  <span class="comment"># 数组[1] = &quot;香蕉&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时v1是[&quot;苹果&quot;, &quot;香蕉&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="八、异常处理（try-catch）"><a href="#八、异常处理（try-catch）" class="headerlink" title="八、异常处理（try-catch）"></a>八、异常处理（try-catch）</h2><p>和 Java 的<code>try-catch</code>一样，Smali 用<code>.try</code>和<code>.catch</code>处理异常。</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 可能出错的代码</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> readFile()V</span><br><span class="line"><span class="keyword">    .locals</span> 2  <span class="comment"># 局部寄存器v0、v1</span></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 6</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># try块开始</span></span><br><span class="line"><span class="keyword">    .try</span>_start_0</span><br><span class="line">        <span class="comment"># 创建FileReader对象（可能抛异常）</span></span><br><span class="line">       <span class="built_in"> const-string </span>v0, <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">       <span class="built_in"> new-instance </span>v1, <span class="class">Ljava/io/FileReader;</span></span><br><span class="line">       <span class="built_in"> invoke-direct </span>&#123;v1, v0&#125;, <span class="class">Ljava/io/FileReader;</span>-&gt;&lt;init&gt;(<span class="class">Ljava/lang/String;</span>)V</span><br><span class="line"><span class="keyword">    .try</span>_end_0</span><br><span class="line">    <span class="comment"># 捕获FileNotFoundException，跳去:catch_0</span></span><br><span class="line"><span class="keyword">    .catch</span> <span class="class">Ljava/io/FileNotFoundException;</span> &#123;:try_start_0 ..<span class="keyword"> :try_end_0</span>&#125;<span class="keyword"> :catch_0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 没有异常就直接返回</span></span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span>    </span><br><span class="line">    <span class="comment"># catch块：处理异常</span></span><br><span class="line">   <span class="keyword"> :catch_0</span></span><br><span class="line">   <span class="built_in"> move-exception </span>v0  <span class="comment"># v0 = 捕获到的异常对象</span></span><br><span class="line">    <span class="comment"># 调用printStackTrace()</span></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Ljava/lang/Throwable;</span>-&gt;printStackTrace()V</span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="九、工具使用（动手实操必备）"><a href="#九、工具使用（动手实操必备）" class="headerlink" title="九、工具使用（动手实操必备）"></a>九、工具使用（动手实操必备）</h2><p>学完语法，必须会用工具才能真正修改 Smali：</p>
<ol>
<li><p><strong>APKTool</strong>（核心工具）：</p>
<ul>
<li>功能：把 APK 反编译成 Smali 代码和资源文件</li>
<li>命令：<ul>
<li>反编译：<code>apktool d 你的应用.apk</code>（会生成一个文件夹，里面的<code>smali</code>目录就是 Smali 代码）</li>
<li>重新打包：修改完 Smali 后，<code>apktool b 反编译的文件夹</code>（生成的 APK 在<code>dist</code>目录）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>辅助工具</strong>：</p>
<ul>
<li><p>AndroidKiller：可视化界面，集成反编译、编辑、打包（新手推荐）</p>
</li>
<li><p>JEB：把 Smali 转成类似 Java 的代码（方便分析逻辑，但修改仍需改 Smali）</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://source.android.google.cn/docs/core/runtime/dalvik-bytecode?hl=zh-cn">Dalvik 字节码格式  | Android Open Source Project</a>]</p>
<p>[smali介绍](<a href="https://github.com/JesusFreke/smali/wiki">Home · JesusFreke&#x2F;smali Wiki</a>)</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的APK结构和Dalvik字节码</title>
    <url>/2025/08/10/%E7%AE%80%E5%8D%95%E7%9A%84APK%E7%BB%93%E6%9E%84%E5%92%8CDalvik%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h2 id="简单的APK结构"><a href="#简单的APK结构" class="headerlink" title="简单的APK结构"></a>简单的APK结构</h2><p>应用打包的核心文件——<strong>APK（Android Package）</strong></p>
<p>APK 文件是Android操作系统中的应用程序包，它包含了应用的所有资源、代码和必要的配置文件。可以把APK看作一个容器，其中集成了Android应用的所有组成部分。</p>
<p>实际上，APK 文件是以 <strong>ZIP</strong> 格式进行压缩打包的，只要在电脑上将apk后缀改为zip即可解压。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目根目录/                     # 整个项目的根目录</span><br><span class="line">├── .gradle/                    # Gradle构建工具的缓存文件，自动生成，无需手动修改</span><br><span class="line">├── .idea/                      # Android Studio的配置文件目录，包含项目设置等，自动生成</span><br><span class="line">├── app/                        # 应用的核心模块，主要开发工作在此目录进行</span><br><span class="line">│   ├── src/                    # 源代码和资源的主目录</span><br><span class="line">│   │   ├── main/               # 主代码和资源目录（正式环境）</span><br><span class="line">│   │   │   ├── java/（或kotlin/）  # 源代码目录，按包名组织</span><br><span class="line">│   │   │   │   └── com/example/myapp/  # 应用的包名目录（示例）</span><br><span class="line">│   │   │   │       ├── MainActivity.java（或.kt）  # 应用入口Activity，定义界面逻辑</span><br><span class="line">│   │   │   │       └── utils/  # 工具类目录（如网络、数据处理工具）</span><br><span class="line">│   │   │   ├── res/            # 资源目录，按类型分类</span><br><span class="line">│   │   │   │   ├── drawable/   # 可绘制资源（图片、形状、选择器等）</span><br><span class="line">│   │   │   │   │   ├── ic_logo.png  # 应用图标图片资源</span><br><span class="line">│   │   │   │   │   └── shape_round.xml  # 圆角形状资源</span><br><span class="line">│   │   │   │   ├── layout/     # 布局文件目录，定义UI结构</span><br><span class="line">│   │   │   │   │   └── activity_main.xml  # MainActivity对应的布局文件</span><br><span class="line">│   │   │   │   ├── mipmap/     # 应用图标目录（适配不同屏幕密度）</span><br><span class="line">│   │   │   │   │   └── ic_launcher.png  # 应用桌面图标</span><br><span class="line">│   │   │   │   ├── values/     # 配置资源目录</span><br><span class="line">│   │   │   │   │   ├── strings.xml  # 字符串资源（集中管理文本，避免硬编码）</span><br><span class="line">│   │   │   │   │   ├── colors.xml   # 颜色资源（定义应用配色）</span><br><span class="line">│   │   │   │   │   └── dimens.xml   # 尺寸资源（统一管理控件大小）</span><br><span class="line">│   │   │   │   ├── raw/        # 原始文件目录（音频、视频等）</span><br><span class="line">│   │   │   │   └── xml/        # 自定义XML资源（如菜单、网络配置）</span><br><span class="line">│   │   │   └── AndroidManifest.xml  # 应用清单文件，声明组件、权限、配置等</span><br><span class="line">│   │   ├── androidTest/        # 仪器化测试目录（需在设备/模拟器上运行）</span><br><span class="line">│   │   │   └── java/（或kotlin/）  # 测试代码，如UI交互测试</span><br><span class="line">│   │   └── test/               # 单元测试目录（在本地JVM运行）</span><br><span class="line">│   │       └── java/（或kotlin/）  # 测试代码，如逻辑单元测试</span><br><span class="line">│   ├── build.gradle            # 模块级构建脚本，配置依赖、编译选项等</span><br><span class="line">│   └── proguard-rules.pro      # 代码混淆规则（发布时减小APK体积并保护代码）</span><br><span class="line">├── build/                      # 编译生成的中间文件和APK，自动管理</span><br><span class="line">├── gradle/                     # Gradle包装器配置，自动下载指定版本Gradle</span><br><span class="line">├── gradlew                     # Linux/Mac系统的Gradle命令行脚本</span><br><span class="line">├── gradlew.bat                 # Windows系统的Gradle命令行脚本</span><br><span class="line">├── build.gradle（Project）     # 项目级构建脚本，配置全局插件和仓库</span><br><span class="line">├── settings.gradle             # 声明项目包含的模块（默认包含:app）</span><br><span class="line">└── local.properties            # 记录本地Android SDK路径，自动生成</span><br></pre></td></tr></table></figure>

<h3 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h3><p>APK <strong>文件通常包括以下几个主要部分</strong>：</p>
<ol>
<li><strong>AndroidManifest.xml</strong></li>
<li><strong>classes.dex</strong></li>
<li><strong>resources.arsc</strong></li>
<li><strong>assets&#x2F;</strong></li>
<li><strong>lib&#x2F;</strong></li>
<li><strong>res&#x2F;</strong></li>
<li><strong>META-INF&#x2F;</strong></li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>assets目录</td>
<td>存放APK的静态资源文件，比如视频，音频，图片等（不一定有但常见）</td>
</tr>
<tr>
<td>lib目录</td>
<td>armeabi-v7a基本通用所有Android设备，arm64-v8a只是用与64为的Android设备，x86常用于Android模拟器，其目录下的.so文件时c或者c++编译的动态链接库文件（不一定有但常见）</td>
</tr>
<tr>
<td>META-INF目录</td>
<td>保存应用的签名信息，签名信息可以验证APK文件的额完整性，相当于APK的身份验证（验证文件是否又被修改）</td>
</tr>
<tr>
<td>res目录</td>
<td>res目录存放资源文件，包括图片，字符串等，APK的 脸蛋由它的layout文件设计</td>
</tr>
<tr>
<td>AndroidManifest.xml文件</td>
<td>APK的应用清单信息，他描述了应用的名字，版本，权限，引用的库文件等信息</td>
</tr>
<tr>
<td>classes.dex文件</td>
<td>classes.dex是java原码编译后生成的java字节码文件，APK运行的主要逻辑</td>
</tr>
<tr>
<td>reaources.arsc文件</td>
<td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td>
</tr>
</tbody></table>
<h4 id="1-AndroidManifest-xml-关键核心"><a href="#1-AndroidManifest-xml-关键核心" class="headerlink" title="1.AndroidManifest.xml(关键核心)"></a>1.AndroidManifest.xml(关键核心)</h4><p><strong>AndroidManifest.xml</strong> 是每个Android应用不可或缺的配置文件，它包含了应用的关键信息。可以把它看作是应用的“蓝图”或“说明书”，它向系统声明了应用的基本属性、组件以及权限等。AndroidManifest.xml中包括以下重要部分：</p>
<ul>
<li><strong>应用的包名（package）</strong>：每个Android应用都有一个唯一的包名，通过包名来区分不同的应用。</li>
<li><strong>应用的组件（Activities, Services, Broadcast Receivers, Content Providers）</strong>：声明应用包含哪些组件，以及这些组件的属性和功能。</li>
<li><strong>权限声明</strong>：列出应用所需的权限，如访问网络、读取存储、使用相机等。</li>
<li><strong>应用主题和图标</strong>：定义应用的UI样式、图标等。</li>
<li><strong>最小SDK版本和目标SDK版本</strong>：确定应用能在什么版本的Android系统上运行。</li>
</ul>
<p><strong>详细解析Manifest中的关键字段</strong></p>
<ul>
<li>&lt;manifest&gt;：包含整个应用的包信息及权限定义。<ul>
<li><code>package</code>: 定义了应用的包名，通常为反向域名格式，如<code>com.example.app</code>。</li>
<li><code>android:versionCode</code>: 定义应用的版本号。</li>
<li><code>android:versionName</code>: 定义应用的版本名称。</li>
</ul>
</li>
<li>&lt;application&gt;：包含应用的核心配置，如主题、图标等。<ul>
<li><code>android:icon</code>: 定义应用的图标。</li>
<li><code>android:label</code>: 定义应用的名称。</li>
<li><code>android:theme</code>: 应用的UI主题。</li>
</ul>
</li>
<li>&lt;activity&gt; ：声明应用的各个界面（Activity），以及这些Activity的属性和行为。<ul>
<li><code>android:name</code>: Activity的类名。</li>
<li><code>android:label</code>: Activity的标签。</li>
<li><code>android:theme</code>: Activity特有的UI主题。</li>
</ul>
</li>
<li>&lt;uses-permission&gt;：声明应用所需要的权限，如访问网络、发送短信等。</li>
<li>&lt;intent-filter&gt;：定义组件的功能和响应的事件，如Activity的启动方式或Broadcast Receiver接收的广播类型。</li>
</ul>
<h4 id="2-classes-dex"><a href="#2-classes-dex" class="headerlink" title="2. classes.dex"></a>2. classes.dex</h4><p><strong>classes.dex</strong> 文件包含了应用程序的可执行代码。它是应用的Dalvik字节码文件，也是Android应用在运行时通过 <strong>Dalvik虚拟机</strong> 或 <strong>ART（Android Runtime）</strong> 解释执行的核心文件。每个Android应用中，所有的Java源代码都经过编译后形成一个或多个DEX（Dalvik Executable）文件，这些文件包含了应用的业务逻辑和代码实现。<br>在Android 5.0（Lollipop）之后，Google引入了 <strong>ART（Android Runtime）</strong> 代替了传统的Dalvik虚拟机，ART的执行方式比Dalvik更高效，支持Ahead-of-Time（AOT）编译和即时编译（JIT）策略。<br>这部分比较难可以拓展阅读一下,相关文档:</p>
<ul>
<li><a href="https://bbs.kanxue.com/elink@9e4K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2">JAVA虚拟机、Dalvik虚拟机和ART虚拟机简要对比_java dalvik-CSDN博客</a></li>
<li><a href="https://bbs.kanxue.com/elink@4a8K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2">安卓逆向学习—-smali,dex,java等文件之间转换关系_dex与smail-CSDN博客</a></li>
</ul>
<h4 id="3-resources-arsc"><a href="#3-resources-arsc" class="headerlink" title="3. resources.arsc"></a>3. resources.arsc</h4><p><strong>resources.arsc</strong> 文件包含了应用程序的所有编译后的资源映射信息。这个文件并不存储实际的资源内容（如图片或字符串），而是存储资源与资源ID的映射关系。例如，它会保存应用中的字符串、颜色、尺寸、样式等信息以及这些资源的ID。通过这个文件，Android系统能够在应用运行时快速访问和加载所需的资源。</p>
<h4 id="4-assets"><a href="#4-assets" class="headerlink" title="4. assets&#x2F;"></a>4. assets&#x2F;</h4><p><strong>assets&#x2F;</strong> 目录包含了应用程序的原始资源文件，这些资源不经过编译，直接以原始形式存储。通常，开发者可以在该目录中存放字体文件、音频文件、HTML文件等，应用在运行时通过API来读取这些资源。例如，游戏可能会将所有的地图文件或纹理图像存放在此目录中。通过<code>AssetManager</code> API，应用可以访问这些文件。</p>
<h4 id="5-lib"><a href="#5-lib" class="headerlink" title="5. lib&#x2F;"></a>5. lib&#x2F;</h4><p><strong>lib&#x2F;</strong> 目录包含了本地库文件，通常是通过 <strong>JNI（Java Native Interface）</strong> 与C&#x2F;C++编写的本地代码。这些库文件可以针对不同的硬件架构（如arm、x86等）进行编译，因此<code>lib/</code>目录下通常会为每个架构创建相应的子目录。这个目录中存放的本地库可以通过Java代码调用JNI接口实现与系统底层的交互。</p>
<p>不同架构的手机拥有不同的操汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─arm64-v8a</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">├─armeabi-v7a</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">├─x86</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">└─x86_64</span><br><span class="line">        libcyberpeace.so</span><br></pre></td></tr></table></figure>

<h4 id="6-res"><a href="#6-res" class="headerlink" title="6. res&#x2F;"></a>6. res&#x2F;</h4><p><strong>res&#x2F;</strong> 目录包含了Android应用所需的所有资源文件。与 <strong>assets&#x2F;</strong> 目录不同，<strong>res&#x2F;</strong> 目录中的资源文件是<strong>经过编译</strong>的，按照不同类型的资源进行组织，例如：</p>
<ul>
<li><p>**drawable&#x2F;**：存放图像资源（如PNG、JPEG等格式的图片）。</p>
</li>
<li><p>**layout&#x2F;**：存放XML格式的布局文件，定义界面的结构。</p>
</li>
<li><p>values&#x2F;</p>
<p>  ：存放各种配置文件，定义应用的常量、颜色、字符串等资源。例如：</p>
<ul>
<li><code>strings.xml</code>：存储应用的文本字符串。</li>
<li><code>colors.xml</code>：存储应用使用的颜色资源。</li>
<li><code>styles.xml</code>：存储样式资源。</li>
</ul>
</li>
</ul>
<p>在<code>values/</code>目录下，除了<code>strings.xml</code>、<code>colors.xml</code>等常见资源文件，还会有像<code>dimens.xml</code>（尺寸定义文件）和<code>attrs.xml</code>（自定义属性）等资源文件。</p>
<p>可以在文件夹目录中找到也可以在jadx里面查看。</p>
<h4 id="7-META-INF"><a href="#7-META-INF" class="headerlink" title="7.META-INF&#x2F;"></a>7.META-INF&#x2F;</h4><p><strong>META-INF&#x2F;</strong> 目录与Java的JAR文件类似，用于存放APK文件的元数据，如签名文件、校验信息等。此目录主要包括以下文件：</p>
<ul>
<li><strong>MANIFEST.MF</strong>：存放APK的清单文件，包含关于APK文件本身的信息。</li>
<li><strong>CERT.RSA</strong>：包含APK文件的数字签名。</li>
<li><strong>CERT.SF</strong>：存放APK文件的签名摘要。<br>  这些文件确保了APK的完整性和安全性，保证APK文件没有被篡改，且来自合法的开发者。</li>
</ul>
<h2 id="Dalvik字节码"><a href="#Dalvik字节码" class="headerlink" title="Dalvik字节码"></a>Dalvik字节码</h2><p>Dalvik 字节码是安卓系统早期（Android 4.4 及之前）为<strong>Dalvik 虚拟机（DVM）</strong> 设计的中间代码，是安卓应用程序的核心执行载体。它由 Java 源代码编译生成的<code>.class</code>文件，通过安卓 SDK 中的<code>dx</code>工具进一步转换而来，最终存储在 APK 文件的<code>classes.dex</code>（或多 DEX 文件）中。</p>
<h4 id="与-Java-字节码的核心区别："><a href="#与-Java-字节码的核心区别：" class="headerlink" title="与 Java 字节码的核心区别："></a>与 Java 字节码的核心区别：</h4><ul>
<li><strong>设计目标</strong>：Dalvik 字节码针对移动设备的有限内存和低功耗处理器优化，采用更紧凑的指令集和寄存器架构（Java 字节码是栈式架构），执行效率更高。</li>
<li><strong>存储形式</strong>：Java 字节码以<code>.class</code>文件单独存储，而 Dalvik 字节码将所有<code>.class</code>文件合并为单一的<code>.dex</code>文件，减少冗余并提高加载效率。</li>
<li><strong>运行环境</strong>：Java 字节码运行在 JVM（Java 虚拟机），而 Dalvik 字节码运行在 DVM；后期安卓引入 ART 虚拟机（Android Runtime）后，<code>.dex</code>文件会被预编译为本地机器码（<code>.oat</code>文件），但 Dalvik 字节码仍是逆向分析的基础。</li>
</ul>
<h4 id="逆向破解中作用："><a href="#逆向破解中作用：" class="headerlink" title="逆向破解中作用："></a>逆向破解中作用：</h4><ul>
<li>逆向入口：APK 核心逻辑载体，是提取、分析应用功能的起点（通过 dex2jar 等工具解析）。</li>
<li>静态分析基础：指令直接对应应用逻辑（如条件判断、方法调用），可定位关键函数（验证、付费等）、追踪数据流向。</li>
<li>动态调试对象：支持断点调试，可观察寄存器值、单步执行，实时修改指令绕过验证。</li>
<li>破解核心：可反编译为 Smali（汇编形式）修改指令（如反转条件、删除关键调用），重编译后替换原 dex，实现功能篡改。</li>
<li>对抗保护：即使被混淆 &#x2F; 加壳，仍可通过指令特征、动态捕获解密后字节码突破。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
</search>
