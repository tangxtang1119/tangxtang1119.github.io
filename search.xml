<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kotlin基础</title>
    <url>/2025/02/24/Kotlin%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>安卓逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统</title>
    <url>/2025/02/24/Linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="📃基础命令"><a href="#📃基础命令" class="headerlink" title="📃基础命令"></a>📃基础命令</h2><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h3><p>Linux的目录结构是一个树形结构，Windows系统可以拥有多个盘符，即顶级目录，如C盘、D盘、E盘等。</p>
<p>Linux没有盘符这个概念，只有一个顶级目录  &#x2F;  ，所有文件都在它下面。</p>
<p>路径描述：</p>
<ul>
<li>Linux系统中，路径之间的层级关系，使用：&#x2F; 表示</li>
<li>Windows系统中，路径之间的层级关系，使用：\ 表示</li>
</ul>
<h3 id="2-Linux命令入门"><a href="#2-Linux命令入门" class="headerlink" title="2.Linux命令入门"></a>2.Linux命令入门</h3><h4 id="（1）基础介绍"><a href="#（1）基础介绍" class="headerlink" title="（1）基础介绍"></a>（1）基础介绍</h4><p>学习Linux，本质是学习在命令行下熟练使用Linux的各类命令。</p>
<ul>
<li>命令行：即Linux终端（Terminal），是一种命令提示符页面。以纯“字符”的形式操作系统，可以使用各种字符化命令对系统发出操作指令。</li>
<li>命令：即Linux程序。一个命令就是一个Linux的程序。命令没有图形化页面，可以在命令行（终端中）提供字符化的反馈。</li>
</ul>
<p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式：</p>
<p>command  [-options]  [parameter]</p>
<ul>
<li>command：命令本身</li>
<li>-options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节</li>
<li>parameter：[可选，非必填]命令的参数，多数用于命令的指向目标等</li>
</ul>
<p><font size=3 color="red">语法中的[]，表示可选的意思</font></p>
<p>示例：</p>
<ul>
<li>ls -l&#x2F;home&#x2F;itheima，ls是命令本身，-l是选项，&#x2F;home&#x2F;itheima是参数<ul>
<li>意思是以列表的形式，显示&#x2F;home&#x2F;itheima目录内的内容</li>
</ul>
</li>
<li>cp -r test1 test2，cp是命令本身，-r是选项，test1和test2是参数<ul>
<li>意思是复制文件夹test1成为test2</li>
</ul>
</li>
</ul>
<h4 id="（2）ls命令"><a href="#（2）ls命令" class="headerlink" title="（2）ls命令"></a>（2）ls命令</h4><p>ls命令的作用是列出目录下的内容，语法细节如下：</p>
<p>ls  [-a -l -h]  [Linux路径]</p>
<ul>
<li>-a -l -h是可选的选项</li>
<li>Linux路径是此命令可选参数</li>
</ul>
<p>当不使用选项和参数，直接使用ls命令本体，表示：以平铺形式，，如果不给定参数，列出当前工作目录下的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250210173128911.png"></p>
<p>显示根目录下所有内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215100642348.png"></p>
<h5 id="1）-a选项"><a href="#1）-a选项" class="headerlink" title="1）-a选项"></a>1）-a选项</h5><ul>
<li>-a选项，表示：all的意思，即出全部文件（包含隐藏的文件&#x2F;文件夹）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215100911897.png"></p>
<ul>
<li>图中以.开头的，表示的是Linux系统的隐藏文件&#x2F;文件夹（只要以.开头，就能自动隐藏）</li>
<li>只有通过-a选项，才能看到这些隐藏文件&#x2F;文件夹</li>
</ul>
<h5 id="2）-l选项"><a href="#2）-l选项" class="headerlink" title="2）-l选项"></a>2）-l选项</h5><ul>
<li>-l选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215101446505.png"></p>
<p>语法中的选项是可以组合使用的，比如学习的-a和-l可以组合应用。</p>
<p>写法：</p>
<ul>
<li>ls -l -a</li>
<li>ls -la</li>
<li>ls -al</li>
</ul>
<p>上述三种写法，都是一样的，表示同时应用-l和-a的功能</p>
<h5 id="3）-h选项"><a href="#3）-h选项" class="headerlink" title="3）-h选项"></a>3）-h选项</h5><ul>
<li>-h表示以易于阅读的形式，列出文件大小，如K、M、G</li>
<li>-h选项必须搭配-l一起使用</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215104710720.png"></p>
<h3 id="3-目录切换（cd-pwd）"><a href="#3-目录切换（cd-pwd）" class="headerlink" title="3.目录切换（cd&#x2F;pwd）"></a>3.目录切换（cd&#x2F;pwd）</h3><h4 id="（1）cd切换工作目录"><a href="#（1）cd切换工作目录" class="headerlink" title="（1）cd切换工作目录"></a>（1）cd切换工作目录</h4><p>当Linux终端打开时，会默认以用户的HOME目录作为当前的工作目录</p>
<p>我们可以通过cd命令，更改当前所在的工作目录。</p>
<p>cd命令来自英文：Change Directory</p>
<p>语法： cd [Linux路径]</p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215111724874.png"></p>
<h4 id="（2）pwd查看当前工作目录"><a href="#（2）pwd查看当前工作目录" class="headerlink" title="（2）pwd查看当前工作目录"></a>（2）pwd查看当前工作目录</h4><p>通过ls验证当前的工作目录，其实是不恰当的。</p>
<p>可以通过pwd命令，来查看当前所在的工作目录</p>
<p>pwd命令来自：Print WOrkDirectory</p>
<p>语法：pwd</p>
<ul>
<li>pwd命令，无选项，无参数，直接输入pwd即可</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250215112014237.png"></p>
<h3 id="4-路径命令"><a href="#4-路径命令" class="headerlink" title="4.路径命令"></a>4.路径命令</h3><h4 id="（1）相对路径和绝对路径"><a href="#（1）相对路径和绝对路径" class="headerlink" title="（1）相对路径和绝对路径"></a>（1）相对路径和绝对路径</h4><ul>
<li>cd&#x2F;home&#x2F;itheima&#x2F;Desltop	绝对路径写法</li>
<li>cd Desktop      相对路径写法</li>
</ul>
<p>绝对路径：以<font color="red">根目录</font>为起点，描述路径的一种写法，路径描述以&#x2F;开头</p>
<p>相对路径：以<font color="red">当前工作目录</font>为起点，描述路径的一种写法，路径描述无需以&#x2F;开头</p>
<h4 id="（2）特殊路径符"><a href="#（2）特殊路径符" class="headerlink" title="（2）特殊路径符"></a>（2）特殊路径符</h4><ul>
<li>.          表示当前目录，比如：cd.&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li>..         表示上一级目录，比如：cd.. 即可切换到上一级目录，cd..&#x2F;..切换到上两级的目录</li>
<li>~         表示HOME目录，比如：cd~ 即可切换到HOME目录或cd ~&#x2F;Desktop，切换到HOME内的Desktop目录</li>
</ul>
<h3 id="5-创建目录（mkdir）"><a href="#5-创建目录（mkdir）" class="headerlink" title="5.创建目录（mkdir）"></a>5.创建目录（mkdir）</h3><p>通过mkdir命令创建新的目录（文件夹）</p>
<p>mkdir来自英文：Make Directory</p>
<p>语法：mkdir [-p] Linux路径</p>
<ul>
<li>参数必填，表示Linux路径，即要创建文件夹的路径，相对路径或绝对路径均可</li>
<li>-p选项可选，表示自动创建不存在的父目录，是用于创建连续多层级的目录</li>
</ul>
<p>创建test文件尝试，特殊路径符。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250218200654870.png"></p>
<p>如果想一次性创建多个层级的目录，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250218201240142.png"></p>
<p>会报错，因为上级目录one并不存在，所以无法创建two目录</p>
<p>此时可以通过-p选项，将一整个链条都创建完成</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250218201723944.png"></p>
<p>注意：创建文件夹需要修改权限，请确保操作均在HOME文件目录内，不要再HOME外操作涉及到权限问题，HOME外无法完成</p>
<h3 id="6-文件操作（touch、cat、more、cp、mv）"><a href="#6-文件操作（touch、cat、more、cp、mv）" class="headerlink" title="6.文件操作（touch、cat、more、cp、mv）"></a>6.文件操作（touch、cat、more、cp、mv）</h3><h4 id="（1）touch创建文件"><a href="#（1）touch创建文件" class="headerlink" title="（1）touch创建文件"></a>（1）touch创建文件</h4><p>语法：touch Linux路径</p>
<ul>
<li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250218203720157.png"></p>
<p>通过观察可以知道文件夹的颜色为深色，文件为白色。但是仅通过颜色判断不够准确，建议使用ls -l，查看文件和文件夹。</p>
<h4 id="（2）cat命令查看文件内容"><a href="#（2）cat命令查看文件内容" class="headerlink" title="（2）cat命令查看文件内容"></a>（2）cat命令查看文件内容</h4><p>在有了文件后，可以通过cat命令查看文件的内容</p>
<p>语法：cat Linux路径</p>
<ul>
<li>cat同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<p>基于vi编辑器先在txt文件中编辑好内容，使用cat命令查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221163319900.png"></p>
<h4 id="（3）more命令查看文件内容"><a href="#（3）more命令查看文件内容" class="headerlink" title="（3）more命令查看文件内容"></a>（3）more命令查看文件内容</h4><p>和cat的不同之处：</p>
<ul>
<li>cat是直接将内容全部显示出来</li>
<li>more支持翻页，如果文件内容过多，可以一页一页的展示</li>
</ul>
<p>语法：more Linux路径</p>
<ul>
<li>同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
<li>在查看过程中，通过空格翻页</li>
<li>通过q退出查看</li>
</ul>
<p>（4）cp命令复制文件文件夹</p>
<p>cp命令可以用于复制文件\文件夹，cp命令来自英文单词：copy</p>
<p>语法：cp [-r] 参数1 参数2</p>
<ul>
<li>-r选项，可选，用于复制文件夹使用，表示递归</li>
<li>参数1，Linux路径，表示被复制的文件或文件夹</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<p>在test1文件夹中新建一个test2文件夹，并将test1文件夹内的hello.txt复制到test2文件夹中</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221164410505-1740127505166-1.png"></p>
<h4 id="（5）mv命令移动文件或文件夹"><a href="#（5）mv命令移动文件或文件夹" class="headerlink" title="（5）mv命令移动文件或文件夹"></a>（5）mv命令移动文件或文件夹</h4><p>mv命令可以用于移动文件或文件夹，mv命令来自英文单词：move</p>
<p>语法：mv 参数1 参数2</p>
<ul>
<li>参数1，Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<p>在test1文件夹中新建test3文件夹，并将test1文件夹中的hello.txt移动到test3文件夹中。（相同效果对文件夹也有效，只需要在cp 后面加上 -r）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221164928437.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221171025784.png"></p>
<p>在test3文件夹中新建文件hello1.txt，并编写文件输入“ zai xue xi bu yao da rao”，使用mv命令 mv hello.txt hello1.txt ，后会出现提示确认否，输入yes确认后，会发现hello.txt不见了，只剩下了hello1.txt，查看hello1.txt中的内容，显示的是”tang x tang”，可以发现hello1.txt中的内容被hello.txt的内容覆盖，换言之，hello.txt文件的文件名，<font color="red">改名</font>为了hello1.txt。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221165832517.png"></p>
<p>（6）rm命令删除文件夹、文件</p>
<p>rm命令来自英文单词：remove</p>
<p>语法：rm [-r -f] 参数1 参数2……参数n</p>
<ul>
<li>同cp命令一样，-r选项用于删除文件夹</li>
<li>-f表示force，强制删除（不糊i弹出提示确认信息）<ul>
<li>普通用户删除内容不会弹出提示，只有root管理用用户删除内容会有提示</li>
<li>所以一般普通用户用不到-f选项</li>
</ul>
</li>
<li>参数1、参数2……、参数n表示要删除的文件或文件夹路径，按照空格隔开</li>
</ul>
<p>将test1文件夹中的test4文件夹删除</p>
<p><img src="/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20250221171254034-1740129226994-4.png"></p>
<h5 id="删除文件、文件夹-通配符"><a href="#删除文件、文件夹-通配符" class="headerlink" title="删除文件、文件夹 - 通配符"></a>删除文件、文件夹 - 通配符</h5><p>rm命令支持通配符*，用来做模糊匹配</p>
<ul>
<li>符号*表示通配符，即匹配任意内容（包含空），示例：</li>
<li>test*，表示匹配任何以test开头的内容</li>
<li>*test，表示匹配任何以test结尾的内容</li>
<li>*test *，表示匹配任何包含test的内容</li>
<li>删除文件夹，必须使用-r选项才可以</li>
<li>强制删除，-f选项</li>
<li>普通用户可以输入su - root，并输入密码临时切换到root用户体验</li>
<li>通过输入exit命令，退回普通用户。（临时用root，用完记得退出）</li>
</ul>
<p>将test1文件夹中以test开头的文件夹全部删除，在提示是否删除test2文件夹时没有输入yes所以test2文件夹被保留，但test2文件夹中的内容都被删除了</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221171930804.png"></p>
<p><font color="red">注意：rm是一个危险的命令，特别是在处于root（超级管理员）用户的时候，请谨慎使用。如下命令，千万不要再root管理员用户下执行（效果等同于在Windows上执行C盘格式化）：</font></p>
<p><font color="red">rm -rf &#x2F;</font></p>
<p><font color="red">rm -rf &#x2F;*</font></p>
<h3 id="7-查找命令（which、find）"><a href="#7-查找命令（which、find）" class="headerlink" title="7.查找命令（which、find）"></a>7.查找命令（which、find）</h3><h4 id="（1）which查看命令的程序文件位置"><a href="#（1）which查看命令的程序文件位置" class="headerlink" title="（1）which查看命令的程序文件位置"></a>（1）which查看命令的程序文件位置</h4><p>前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序，和Windows系统中的.exe文件，是一个意思。</p>
<p>可以通过which命令，查看所使用的一系列命令的程序文件存放在哪儿</p>
<p>语法：which 要查找的命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221191206787.png"></p>
<h4 id="（2）find命令按文件名查找文件"><a href="#（2）find命令按文件名查找文件" class="headerlink" title="（2）find命令按文件名查找文件"></a>（2）find命令按文件名查找文件</h4><p>类似图形化系统提供的搜索功能，搜索指定文件</p>
<p>在Linux系统中，可以通过find命令去搜索指定的文件。</p>
<p>语法：find 起始路径 -name “被查找文件名”</p>
<p>查找hello.txt文件和查找test文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221191939509.png"></p>
<h5 id="find命令-通配符"><a href="#find命令-通配符" class="headerlink" title="find命令 通配符"></a>find命令 通配符</h5><p>语法：find 起始路径 -name “被查找文件名”</p>
<p>被查找文件名，支持使用通配符*来做模糊查询</p>
<ul>
<li>符号*表示通配符，即匹配人愿意内容（包含空），示例：</li>
<li>test*，表示匹配任何以test开头的内容</li>
<li>*test，表示匹配任何以test结尾的内容</li>
<li>*test *，表示匹配任何包含test的内容</li>
</ul>
<h5 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令 按文件大小查找文件"></a>find命令 按文件大小查找文件</h5><p>语法：find 起始路径 -size +或者-n[KMG]</p>
<ul>
<li>+、-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k（小写字母）表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例：</p>
<ul>
<li>查找小于10KB的文件：find &#x2F; -size -10k</li>
<li>查找大于100MB的文件：find &#x2F; -size +100M</li>
<li>查找大于1GB的文件：find &#x2F; -size +1G</li>
</ul>
<h3 id="8-grep、wc和管道符"><a href="#8-grep、wc和管道符" class="headerlink" title="8.grep、wc和管道符"></a>8.grep、wc和管道符</h3><h4 id="（1）grep命令-通过关键字过滤文件行"><a href="#（1）grep命令-通过关键字过滤文件行" class="headerlink" title="（1）grep命令 通过关键字过滤文件行"></a>（1）grep命令 通过关键字过滤文件行</h4><p>通过grep命令，从文件中通过关键字过滤文件行</p>
<p>语法：grep [-n] 关键字 文件路径</p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其他特殊符号，建议使用“ ”将关键字包围起来</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<p>下图为操作示例</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221194017857.png"></p>
<h4 id="（2）wc命令-数量统计"><a href="#（2）wc命令-数量统计" class="headerlink" title="（2）wc命令 数量统计"></a>（2）wc命令 数量统计</h4><p>通过wc命令统计文件的行数、单词数量等</p>
<p>语法：wc [-c -m -l -w] 文件路径</p>
<ul>
<li>选项，-c，统计bytes数量</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221200417678.png"></p>
<h4 id="（2）管道符"><a href="#（2）管道符" class="headerlink" title="（2）管道符"></a>（2）管道符</h4><p>新的特殊符号：|</p>
<p>含义：将管道符左边命令的结果，作为右边命令的输入</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221200641715.png"></p>
<p>如上图：</p>
<ul>
<li>cat hello.txt的输出结果（文件内容）</li>
<li>作为右边grep命令的输入（被过滤文件）</li>
</ul>
<h3 id="9-echo、tail和重定向符"><a href="#9-echo、tail和重定向符" class="headerlink" title="9.echo、tail和重定向符"></a>9.echo、tail和重定向符</h3><h4 id="（1）echo命令-在命令行内输出指定内容"><a href="#（1）echo命令-在命令行内输出指定内容" class="headerlink" title="（1）echo命令 在命令行内输出指定内容"></a>（1）echo命令 在命令行内输出指定内容</h4><p>语法：echo 输出内容</p>
<ul>
<li>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用“ ”包围</li>
<li>带有空格或\等特殊符号，建议使用双引号包围<ul>
<li>如果不包围的化，空格后很容易被识别为参数2，尽管echo不受影响，但是要养成习惯</li>
</ul>
</li>
</ul>
<p>在终端上显示：Holle Linux</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221201543727.png"></p>
<h5 id="反引号"><a href="#反引号" class="headerlink" title="反引号&#96;"></a>反引号&#96;</h5><p>将命令用反引号（通常也称之为飘号）&#96; 将其包围，被包围的内容，蒋辉作为命令执行，而非普通字符</p>
<p>如下图，本意是想将当前工作目录路径输出，但是pwd被当作普通字符被输出了，通过使用&#96;将其包围，就会被作为命令执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221202100907.png"></p>
<h4 id="（2）重定向符-和"><a href="#（2）重定向符-和" class="headerlink" title="（2）重定向符 &gt;和&gt;&gt;"></a>（2）重定向符 &gt;和&gt;&gt;</h4><p>特殊符号，重定向符：&gt;和&gt;&gt;</p>
<ul>
<li>&gt;，将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li>
<li>&gt;&gt;，将左侧命令的结果，追加写入到符号右侧指定的文件中</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250221203410477.png"></p>
<h4 id="（3）tail命令-查看尾部内容-跟踪最新更改"><a href="#（3）tail命令-查看尾部内容-跟踪最新更改" class="headerlink" title="（3）tail命令 查看尾部内容 跟踪最新更改"></a>（3）tail命令 查看尾部内容 跟踪最新更改</h4><p>语法：tail [-f -num] Linux路径</p>
<ul>
<li>参数，Linux路径，表示被跟踪的文件路径</li>
<li>选项，-f，表示持续跟踪，结束使用ctrl+c</li>
<li>选项，-num，表示查看尾部多少行，不填默认10行，将num替换成数字</li>
</ul>
<p>持续跟踪的操作流程</p>
<p>输入命令后，复制标签建立新窗口，在新窗口对被跟踪文件的操作，会在原窗口显示，比如在hello.txt文件中添加新的字符等。</p>
<h3 id="10-vi编辑器"><a href="#10-vi编辑器" class="headerlink" title="10.vi编辑器"></a>10.vi编辑器</h3><h4 id="（1）基本了解"><a href="#（1）基本了解" class="headerlink" title="（1）基本了解"></a>（1）基本了解</h4><p>vi\vim是visual interface的简称，是Linux中最经典的文本编辑器</p>
<p>同图形化界面中的文本编辑器一样，vi是命令行下对文本文件编辑器的绝佳选择。</p>
<p><font color="red">vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，而且还具有shell程序编辑的功能，可以不同颜色的字体来辨别语语法的正确性，极大的方便了程序的设计和编辑性。</font></p>
<h4 id="（2）三种工作模式"><a href="#（2）三种工作模式" class="headerlink" title="（2）三种工作模式"></a>（2）三种工作模式</h4><h5 id="1）命令模式（Command-mode）"><a href="#1）命令模式（Command-mode）" class="headerlink" title="1）命令模式（Command mode）"></a>1）命令模式（Command mode）</h5><p>​	命令模式下，锁敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。此模式下，不能自由进行文本编辑。</p>
<h5 id="2）输入模式（Insert-mode）"><a href="#2）输入模式（Insert-mode）" class="headerlink" title="2）输入模式（Insert mode）"></a>2）输入模式（Insert mode）</h5><p>​	也就是所有的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。</p>
<h5 id="3）底线命令模式（Last-line-mode）"><a href="#3）底线命令模式（Last-line-mode）" class="headerlink" title="3）底线命令模式（Last line mode）"></a>3）底线命令模式（Last line mode）</h5><p>​	以：开始，通常用于文件的保存、退出。</p>
<p>语法：（推荐使用vim，它兼容全部的vi功能）</p>
<p>vi 文件路径</p>
<p>vim 文件路径</p>
<ul>
<li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li>
<li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li>
</ul>
<p><img src="/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA.assets/image-20250220173127758-1740043953051-1.png" alt="工作模式"></p>
<p>快速体验：</p>
<p>通过vi&#x2F;vim命令编辑文件，会打开一个新窗口，此时这个窗口就是：命令模式窗口</p>
<p>命令模式窗口时vi编辑器的入口和出口，如上图</p>
<ul>
<li>进入vi编辑器会进入命令模式</li>
<li>进入命令模式输入键盘指令，可以进入输入模式</li>
<li>输入模式需要退回到命令模式，然后通过命令可以进入底线命令模式</li>
</ul>
<p>快速体验操作：</p>
<p>1.使用 vi hello.txt，新建一个新文件，执行后进入的是命令模式</p>
<p>2.在命令模式内，按键盘i，进入输入模式</p>
<p>3.再输入模式内输入：tang x tang</p>
<p>4.输入完成后，按esc回退到命令模式</p>
<p>5.在命令模式内，按键盘：，进入底线命令模式</p>
<p>6.在底线命令输入：wq，保存文件并退出vi编辑器</p>
<p>通过ls查看是否存在、创建是否成功，通过cat命令查看文件内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250220174659079.png"></p>
<p>在命令模式下的常见快捷键</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">命令模式</td>
<td align="left">i</td>
<td align="left">在当前光标位置进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">a</td>
<td align="left">在当前光标位置 之后 进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">I</td>
<td align="left">在当前行的 开头 进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">A</td>
<td align="left">在当前行的 结尾 进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">o</td>
<td align="left">在当前光标 下一行 进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">O</td>
<td align="left">在当前光标 上一行 进入输入模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">esc</td>
<td align="left">在任何情况下输入esc都能回到命令模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">0</td>
<td align="left">移动光标到当前行的开头</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">$</td>
<td align="left">移动光标到当前行的结尾</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">&#x2F;</td>
<td align="left">进入搜索模式</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">n</td>
<td align="left">向下继续搜索</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">N</td>
<td align="left">向上继续搜索</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">dd</td>
<td align="left">删除光标所在行的内容</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">ndd</td>
<td align="left">n是数字，表示删除当前光标向下n行</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">yy</td>
<td align="left">复制当前行</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">nyy</td>
<td align="left">n是数字，表示复制当前行和下面的n行</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">p</td>
<td align="left">粘贴复制的内容</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">u</td>
<td align="left">撤销修改</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">ctrl+r</td>
<td align="left">反向撤销修改</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">gg</td>
<td align="left">跳到首行</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">G</td>
<td align="left">跳到行尾</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">dG</td>
<td align="left">从当前行开始，向下全部删除</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">dgg</td>
<td align="left">从当前行开始，向上全部删除</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">d$</td>
<td align="left">从当前光标开始，删除到本行的结尾</td>
</tr>
<tr>
<td align="left">命令模式</td>
<td align="left">d0</td>
<td align="left">从当前光标开始，删除到本行的开头</td>
</tr>
</tbody></table>
<p>底线命令模式，支持如下命令：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>底线命令模式</td>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q</td>
<td>仅退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set paste</td>
<td>设置粘贴模式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向工程计划</title>
    <url>/2025/02/24/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>以下是针对 自学安卓逆向工程 的半年学习路线规划，结合 理论+实战，逐步掌握核心技能。</p>
<hr>
<h3 id="第一阶段：基础准备（1个月）"><a href="#第一阶段：基础准备（1个月）" class="headerlink" title="第一阶段：基础准备（1个月）"></a><strong>第一阶段：基础准备（1个月）</strong></h3><p><strong>目标</strong>：掌握编程基础、安卓开发原理、逆向工程基础工具。</p>
<h4 id="1-编程基础（Java-Kotlin）"><a href="#1-编程基础（Java-Kotlin）" class="headerlink" title="1. 编程基础（Java&#x2F;Kotlin）"></a><strong>1. 编程基础（Java&#x2F;Kotlin）</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>Java语法（重点：类、对象、继承、多线程、反射）。</li>
<li>Kotlin基础（推荐：Android官方推荐语言）。</li>
<li>推荐资源：<ul>
<li>书籍：《Java核心技术 卷Ⅰ》（第11版）。</li>
<li>视频：<a href="https://www.bilibili.com/video/BV1fh411y7R8">B站-韩顺平Java零基础</a>。</li>
<li>Kotlin官方文档：<a href="https://kotlinlang.org/docs/home.html">Kotlin 官方教程</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-安卓开发入门"><a href="#2-安卓开发入门" class="headerlink" title="2. 安卓开发入门"></a><strong>2. 安卓开发入门</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>Android Studio使用、APK打包流程。</li>
<li>四大组件（Activity、Service、BroadcastReceiver、ContentProvider）。</li>
<li>简单App开发（如计算器、天气预报App）。</li>
<li>推荐资源：<ul>
<li>官方文档：<a href="https://developer.android.com/">Android开发者官网</a>。</li>
<li>视频：<a href="https://www.bilibili.com/video/BV1Rt411e76H">B站-《第一行代码》第三版配套视频</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-逆向工具初探"><a href="#3-逆向工具初探" class="headerlink" title="3. 逆向工具初探"></a><strong>3. 逆向工具初探</strong></h4><ul>
<li><strong>工具安装</strong>：<ul>
<li>APKTool（反编译APK）。</li>
<li>Jadx&#x2F;Ghidra（查看Java&#x2F;Smali代码）。</li>
<li>Android Killer&#x2F;JEB（逆向分析工具）。</li>
</ul>
</li>
<li><strong>实践任务</strong>：<ul>
<li>反编译一个简单APK，修改资源文件（如文字&#x2F;图标）并重新打包。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二阶段：逆向核心技能（2个月）"><a href="#第二阶段：逆向核心技能（2个月）" class="headerlink" title="第二阶段：逆向核心技能（2个月）"></a><strong>第二阶段：逆向核心技能（2个月）</strong></h3><p><strong>目标</strong>：掌握Smali语法、ARM汇编、动态调试、Hook技术。</p>
<h4 id="1-Smali语法与静态分析"><a href="#1-Smali语法与静态分析" class="headerlink" title="1. Smali语法与静态分析"></a><strong>1. Smali语法与静态分析</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>Smali语言基础（寄存器、指令、方法调用）。</li>
<li>修改Smali代码实现简单逻辑（如破解注册验证）。</li>
<li>推荐工具：Jadx、Android Killer。</li>
<li>实战案例：破解一个“付费解锁”功能的APK。</li>
</ul>
</li>
</ul>
<h4 id="2-ARM汇编基础"><a href="#2-ARM汇编基础" class="headerlink" title="2. ARM汇编基础"></a><strong>2. ARM汇编基础</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>ARM指令集（MOV、LDR、ADD、BL等）。</li>
<li>反编译Native层代码（IDA Pro基础使用）。</li>
<li>推荐资源：<ul>
<li>书籍：《IDA Pro权威指南》。</li>
<li>视频：<a href="https://www.bilibili.com/video/BV1gK411H7Uq">B站-ARM汇编入门</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-动态调试与Hook"><a href="#3-动态调试与Hook" class="headerlink" title="3. 动态调试与Hook"></a><strong>3. 动态调试与Hook</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>Frida框架（Hook Java&#x2F;Native函数）。</li>
<li>Xposed框架（修改系统级行为）。</li>
<li>实战案例：通过Frida绕过App的Root检测。</li>
<li>推荐工具：<ul>
<li>Frida官方文档：<a href="https://frida.re/docs/home/">Frida Docs</a>。</li>
<li>Xposed模块开发教程：<a href="https://www.bilibili.com/video/BV1pK4y1j7dK">B站-Xposed入门</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第三阶段：实战进阶（2个月）"><a href="#第三阶段：实战进阶（2个月）" class="headerlink" title="第三阶段：实战进阶（2个月）"></a><strong>第三阶段：实战进阶（2个月）</strong></h3><p><strong>目标</strong>：掌握脱壳、反混淆、协议分析、漏洞挖掘。</p>
<h4 id="1-脱壳与反混淆"><a href="#1-脱壳与反混淆" class="headerlink" title="1. 脱壳与反混淆"></a><strong>1. 脱壳与反混淆</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>常见加固技术（如梆梆安全、腾讯御安全）。</li>
<li>脱壳工具使用（Frida-Dump、DrizzleDumper）。</li>
<li>实战案例：脱掉某加固APK并分析代码逻辑。</li>
<li>推荐工具：Frida、Xposed插件（如FDex2）。</li>
</ul>
</li>
</ul>
<h4 id="2-协议分析与抓包"><a href="#2-协议分析与抓包" class="headerlink" title="2. 协议分析与抓包"></a><strong>2. 协议分析与抓包</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>抓包工具（Charles、Fiddler、Wireshark）。</li>
<li>HTTPS证书绕过（JustTrustMe插件）。</li>
<li>实战案例：逆向某App的登录协议并模拟请求。</li>
<li>推荐工具：MitmProxy + Frida脚本。</li>
</ul>
</li>
</ul>
<h4 id="3-漏洞挖掘与CTF实战"><a href="#3-漏洞挖掘与CTF实战" class="headerlink" title="3. 漏洞挖掘与CTF实战"></a><strong>3. 漏洞挖掘与CTF实战</strong></h4><ul>
<li><strong>学习内容</strong>：<ul>
<li>常见漏洞类型（组件暴露、WebView漏洞、逻辑漏洞）。</li>
<li>CTF逆向题练习（如攻防世界、CTFHub）。</li>
<li>推荐资源：<ul>
<li>书籍：《Android安全攻防权威指南》。</li>
<li>平台：<a href="https://ctf.pediy.com/">看雪CTF题库</a>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第四阶段：综合项目与求职准备（1个月）"><a href="#第四阶段：综合项目与求职准备（1个月）" class="headerlink" title="第四阶段：综合项目与求职准备（1个月）"></a><strong>第四阶段：综合项目与求职准备（1个月）</strong></h3><p><strong>目标</strong>：完成实战项目、完善简历、准备面试。</p>
<h4 id="1-实战项目"><a href="#1-实战项目" class="headerlink" title="1. 实战项目"></a><strong>1. 实战项目</strong></h4><ul>
<li><strong>可选方向</strong>：<ul>
<li>逆向分析某金融App的加密算法。</li>
<li>开发一个Xposed模块（如自动抢红包）。</li>
<li>分析恶意软件（如银行木马）的通信协议。</li>
</ul>
</li>
</ul>
<h4 id="2-简历与面试"><a href="#2-简历与面试" class="headerlink" title="2. 简历与面试"></a><strong>2. 简历与面试</strong></h4><ul>
<li><strong>简历重点</strong>：<ul>
<li>突出实战项目（技术细节、成果）。</li>
<li>技能关键词：Smali、Frida、IDA Pro、ARM汇编。</li>
</ul>
</li>
<li><strong>面试准备</strong>：<ul>
<li>高频问题：APK打包流程、Hook原理、脱壳方法。</li>
<li>推荐刷题：<a href="https://bbs.pediy.com/">看雪论坛面试经验帖</a>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="学习资源汇总"><a href="#学习资源汇总" class="headerlink" title="学习资源汇总"></a><strong>学习资源汇总</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th><strong>资源</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>书籍</strong></td>
<td>《Android软件安全与逆向分析》《Frida Android SO逆向深入实践》</td>
</tr>
<tr>
<td align="left"><strong>视频教程</strong></td>
<td>B站搜索“安卓逆向”关键词（推荐：非虫、咸鱼等UP主系列课程）</td>
</tr>
<tr>
<td align="left"><strong>工具导航</strong></td>
<td><a href="https://github.com/rednaga/APKiD">安卓逆向工具包</a></td>
</tr>
<tr>
<td align="left"><strong>社区论坛</strong></td>
<td>看雪安全论坛、吾爱破解、FreeBuf</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>信息安全</tag>
        <tag>学习计划</tag>
        <tag>安卓逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程</title>
    <url>/2025/02/24/Java%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第一章-入门基础"><a href="#第一章-入门基础" class="headerlink" title="第一章 入门基础"></a><strong>第一章 入门基础</strong></h1><h2 id="1-1Java重要特点"><a href="#1-1Java重要特点" class="headerlink" title="1.1Java重要特点"></a><strong>1.1Java重要特点</strong></h2><ol>
<li>java语言是面向对象的（oop）</li>
<li>Java语言是健壮的。Java的强制型机制、异常处理、垃圾的自动手机等是Java程序健壮性的重要保证。</li>
<li>Java语言跨平台性的（一个java文件在编译后的class文件可以在多个不同操作系统上运行）</li>
<li>Java语言是解释性的</li>
</ol>
<p>解释性语言：Javascript，PHP，java ，编译语言：C&#x2F;C++</p>
<p>区别是：解释性语言，编译后的代码，不能直接被机器执行，需要解释器来执行；</p>
<p>编译性语言，编译后的代码，可以直接被机器执行</p>
<h2 id="1-2Java的开发工具"><a href="#1-2Java的开发工具" class="headerlink" title="1.2Java的开发工具"></a><strong>1.2Java的开发工具</strong></h2><ol>
<li>editplus、notepad++</li>
<li>Sublime Text</li>
<li>IDEA</li>
<li>eclipes</li>
</ol>
<p>前期使用文本编辑器本，不太智能的工具（在面试和考试是一般都是手写代码），在一定了解后在使用IDEA和Eclipse开发工具</p>
<h2 id="1-3快速入门"><a href="#1-3快速入门" class="headerlink" title="1.3快速入门"></a><strong>1.3快速入门</strong></h2><p>需求说明：开发一个Hello.java程序，可以输出“hello，world~”</p>
<ol>
<li>开发步骤</li>
</ol>
<p>1）将Java代码编写在扩展名为.java的文件中</p>
<p>&#x2F;&#x2F;创建一个公有类，称为hello</p>
<p>&#x2F;&#x2F;{}大括号表示了一个类的开始和结束</p>
<p>public class hello{</p>
<p>&#x2F;&#x2F;主方法，程序的入口</p>
<p>public static void mian(String[] args){</p>
<p>&#x2F;&#x2F;输出“hello,world~”到屏幕上</p>
<p>&#x2F;&#x2F;注意不要忘记分号，表示语句结束</p>
<p>System.out.printIn(“hello,world~”)；</p>
<p>}</p>
<p>}</p>
<p>2）通过javac命令对该java文件进行编译，生成.class文件</p>
<p>在cmd终端中输入javac hello.java 运行</p>
<p>编译出hello.class文件（又称字节码文件）</p>
<p>3）通过java命令对.class文件进行运行</p>
<h2 id="1-4开发注意事项和细节说明"><a href="#1-4开发注意事项和细节说明" class="headerlink" title="1.4开发注意事项和细节说明"></a><strong>1.4开发注意事项和细节说明</strong></h2><ol>
<li>Java源文件以.java为扩展名。源文件的基本组成部分是类(class)</li>
<li>Java应用程序的执行入口是mian()方法，固定的书写模式：</li>
</ol>
<p>public static void mian(String[] args){…}</p>
<ol start="3">
<li>严格区分大小写</li>
<li>Java方法由一条条语句构成，每个语句的结束都是“;”</li>
<li>大括号都是成对出现，缺一不可，养成习惯先写{}，再写代码</li>
<li>一个源文件最多只能有一个public类。其他类的个数不限</li>
</ol>
<p>每一个类编译后都会生成对应的字节码文件</p>
<ol start="7">
<li>如果源文件中包含了public类，则文件名必须以该类名命名</li>
<li>可以将main()方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法</li>
</ol>
<h2 id="1-5转义字符"><a href="#1-5转义字符" class="headerlink" title="1.5转义字符"></a><strong>1.5转义字符</strong></h2><ol>
<li>\t：一个制表位，实现对齐功能</li>
<li>\n：换行符</li>
<li>\：一个\</li>
<li>\”：一个”</li>
<li>\’：一个’</li>
<li>\r：一个回车 System.out.println(“你好，再见~”);</li>
</ol>
<p>回车后光标到最前面，\r后面的内容会将前面的覆盖</p>
<h2 id="1-6注释（comment）"><a href="#1-6注释（comment）" class="headerlink" title="1.6注释（comment）"></a><strong>1.6注释（comment）</strong></h2><p>养成习惯使用注释解释代码含义，快捷键ctrl+&#x2F;</p>
<ol>
<li>单行注释：</li>
</ol>
<p>格式  &#x2F;&#x2F;注释文字</p>
<ol start="2">
<li>多行注释</li>
</ol>
<p>格式  &#x2F;<em>注释文字</em>&#x2F;</p>
<p>Ø 使用细节</p>
<p>1）被注释的文字，不会被JVM（java虚拟机）解释执行</p>
<p>2）多行注释里面不允许由多行注释嵌套</p>
<ol start="3">
<li>文档注释</li>
</ol>
<p>注释内容会被JDK提供的工具javadoc所解析，生成一套以网页形式体现的该程序文档说明，一般写在类。</p>
<p>格式  &#x2F;**</p>
<p>*@author 唐小唐</p>
<p>*@version 1.0</p>
<p>*&#x2F;</p>
<ol start="4">
<li>终端命令：</li>
</ol>
<p>javadoc -d文件夹名 -xx -yy Demo3.java</p>
<ol start="5">
<li>javadoc的标签</li>
</ol>
<table>
<thead>
<tr>
<th><em><strong>*标签*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*标签类型*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>作者标识</td>
<td>包、 类、接口</td>
</tr>
<tr>
<td>@deprecated</td>
<td>标识当前API已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个API</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>指明当前文档根目录的路径</td>
<td></td>
</tr>
<tr>
<td>@exception</td>
<td>标志一个类抛出的异常</td>
<td>构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>从直接父类继承的注释</td>
<td></td>
</tr>
<tr>
<td></td>
<td>链接到某个特定的成员对应的文档中</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@param</td>
<td>方法的入参名及描述信息，如入参有特别要求，可在此注释</td>
<td>构造函数、方法</td>
</tr>
<tr>
<td>@return</td>
<td>对函数返回值的注释</td>
<td>方法</td>
</tr>
<tr>
<td>@see</td>
<td>引用,查看相关内容，如类、方法、变量等</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@serial</td>
<td>说明一个序列化属性</td>
<td></td>
</tr>
<tr>
<td>@serialData</td>
<td>说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td></td>
</tr>
<tr>
<td>@serialField</td>
<td>说明一个ObjectStreamField组件</td>
<td>@</td>
</tr>
<tr>
<td>@since</td>
<td>描述文本,API在什么程序的什么版本后开发支持</td>
<td>包、类、接口、值域、构造函数、 方法</td>
</tr>
<tr>
<td>@throws</td>
<td>构造函数或方法所会抛出的异常</td>
<td>构造函数、 方法</td>
</tr>
<tr>
<td></td>
<td>显示常量的值，该常量必须是static属性</td>
<td>静态值域</td>
</tr>
<tr>
<td>@version</td>
<td>版本号</td>
<td>包、 类、接口</td>
</tr>
</tbody></table>
<h2 id="1-7DOS（磁盘操作系统）命令"><a href="#1-7DOS（磁盘操作系统）命令" class="headerlink" title="1.7DOS（磁盘操作系统）命令"></a><strong>1.7DOS（磁盘操作系统）命令</strong></h2><ol>
<li>查看当前目录有什么</li>
</ol>
<p>dir dir d:\abc2\test200</p>
<ol start="2">
<li>切换到其他盘下：盘符号cd</li>
</ol>
<p>切换到c盘 cd &#x2F;D c:</p>
<ol start="3">
<li>切换到当前盘的其他目录下（使用相对路径和绝对路径）</li>
</ol>
<p>cd d:\abc2\test200  cd....\abc2\test200</p>
<ol start="4">
<li>切换到上一级：cd..</li>
<li>切换到根目录:cd\</li>
<li>查看指定目录下索引的子级目录：tree</li>
<li>清屏 cls</li>
<li>退出DOS exit</li>
<li>了解：md,rd,copy,del,echo,type,move</li>
</ol>
<h1 id="第二章-变量原理"><a href="#第二章-变量原理" class="headerlink" title="第二章 变量原理"></a><strong>第二章 变量原理</strong></h1><h2 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a><strong>2.1变量</strong></h2><p>概念：</p>
<p> 变量相当于内存中一个数据存储空间的表示，通过变量名访问到变量（值）。不论是使用哪种高级程序语言编写程序，变量都是其程序的基本组成单位。三个基本要素：类型+名称+值，例：int a&#x3D;1119;</p>
<p>Ø 使用注意事项：</p>
<ol>
<li>变量表示内存中的一个存储区域，不同变量，类型不同，占用的空间大小不同</li>
<li>该区域一定由子集的名称[变量名]和类型[数据类型]</li>
<li>变量必须先声明，后使用，即有顺序</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量在同意作业域内不能重名</li>
<li>变量&#x3D;变量名+值+数据类型</li>
</ol>
<h2 id="2-2程序中-号的使用"><a href="#2-2程序中-号的使用" class="headerlink" title="2.2程序中+号的使用"></a><strong>2.2程序中+号的使用</strong></h2><ol>
<li>左右两边为数值型时，做加法运算</li>
<li>左右两边有一方为字符串时，做拼接运算</li>
<li>运算顺序，从左到右</li>
</ol>
<h2 id="2-3数据类型"><a href="#2-3数据类型" class="headerlink" title="2.3数据类型"></a><strong>2.3数据类型</strong></h2><ol>
<li>基本数据类型</li>
</ol>
<p>1）数值型：</p>
<p>a. 整数类型 存放整数：byte[1],short[2],int[4],long[8]（背）</p>
<p>Ø 使用细节：</p>
<p>a）java的整数类型有固定的范围和字段长度，不受具体OS[操作系统]的影响，以保证java程序的可移植性；</p>
<p>b）java整数常量（具体值）默认为int型，声明long型常量须后加‘l’或者‘L’</p>
<p>c）java程序中变量常声明为int型，除非不足以表示大数，才使用long</p>
<p>d）bit：计算机中最小的存储单位。byte计算机中基本存储单位元，1byte&#x3D;8bit</p>
<p>b. 浮点（小数）类型 float[4],double[8]（背）</p>
<p>Ø 使用细节：</p>
<p>a）java的浮点类型有固定的范围和字段长度，不受具体OS[操作系统]的影响，以保证java程序的可移植性；</p>
<p>b）java的浮点型常量（具体值）默认为double型，声明float型常量，须后加‘f’或者‘F’</p>
<p>c）有两种表示形式</p>
<p>十进制数形式：如 5.12  512.0f</p>
<p>科学计数法形式：如 5.12e2[]  5.12E-2[]</p>
<p>d）通常情况下使用double型，比float更精确</p>
<p>2）字符类型</p>
<p>a. 字符型char[2],double[8]存放单个字符（背）</p>
<p>Ø 使用细节：</p>
<p>a）字符常量使用但因阿红（‘’）括起来的单个字符</p>
<p>b）其中允许使用转义字符</p>
<p>c）char本质是一个整数，在输出时，是unicode码对应的字符</p>
<p>d）可以直接给char赋一个整数，输出时，会按照对应的unicode字符输出</p>
<p>e）char类型可以进行运算</p>
<p>b. 本质探讨</p>
<p>a）字符型存储在计算机中，需要将字符对应的码值（整数）找出来</p>
<p>存储：‘a’&#x3D;&gt;码值97  &#x3D;&gt;二进制（1100001）&#x3D;&gt;存储</p>
<p>读取：二进制（1100001）&#x3D;&gt;97  &#x3D;&gt;‘a’&#x3D;&gt;显示</p>
<p>b）字符和码值的对应关系是通过字符编码表决定的（规定好的）</p>
<p>ASCLII编码表，一个字节可以表示256个字符，只用了128个字符，不能表示所有字符</p>
<p>Unicode编码表，固定大小的编码使用两个字节来表示字符，字母和汉字统一都是占用两个字节，浪费空间</p>
<p>utf-8编码表，大小可变的编码，字母使用1个字节，汉字使用3个字节</p>
<p>GBK，可以表示汉字，而且范围广，字母使用1个字节，汉字使用2个字节</p>
<p>GB2312，可以表示汉字，GB2312&lt;GBK</p>
<p>big5码，繁体中文，台湾，香港</p>
<p>3）布尔型</p>
<p>a. boolean[1],存放true，false（背）</p>
<ol start="2">
<li>引用数据类型</li>
</ol>
<p>1）类（class）</p>
<p>2）接口（interface）</p>
<p>3）数组（[]）</p>
<ol start="3">
<li>java API文档</li>
</ol>
<p>应用程序编程接口，是java提供的基本编程接口（提供的类还有相关方法）。</p>
<p>中文在线文档：<a href="https://www.matools.com/">https://www.matools.com</a></p>
<ol start="4">
<li>基本数据自动类型转换</li>
</ol>
<p>精度小的类型自动转换为精度大的数据类型</p>
<p>数据类型按照精度（容量）大小排序（背）：</p>
<p>char &#x3D;&gt; int &#x3D;&gt; long &#x3D;&gt; float &#x3D;&gt; double </p>
<p>byte &#x3D;&gt; short &#x3D;&gt; int &#x3D;&gt; long &#x3D;&gt; float &#x3D;&gt; double </p>
<p>Ø 使用细节：</p>
<p>a）（byte，short）和char之间不会相互自动转换</p>
<p>b）byte，short，char三者之间计算时首先会转换为int类型</p>
<p>c）boolean不参与转换</p>
<p>d）自动提升原则：表达式结果的类型自动提升为操作数中给最大的类型</p>
<ol start="5">
<li>强制类型转换</li>
</ol>
<p>自动类型转换的逆过程，将容量大的数据转换为容量小的数据类型，使用时需要加上强制转换符（），但可能造成精度降低或溢出，需格外注意。</p>
<p>例：int i &#x3D; (int)1.9;</p>
<p>System.out.println(i);&#x2F;&#x2F;1</p>
<p>Ø 使用细节：</p>
<p>a）强转符号只针对于最近的擦欧总数有效，往往使用小括号提升优先级</p>
<p>b）char类型可以保存int的常量值，但不能保存int的变量值，需要强转</p>
<p>c）byte和short在运算时，当作int类型处理</p>
<ol start="6">
<li>基本数据类型和String类型的转换</li>
</ol>
<p>1）基本类型转String类型</p>
<p>将基本类型的值+“”即可</p>
<p>2）String类型转基本类型</p>
<p>通过基本类型的包装类调用parseXX方法即可</p>
<h1 id="第三章-运算符"><a href="#第三章-运算符" class="headerlink" title="第三章****运算符"></a><strong>第三章****运算符</strong></h1><h2 id="3-1基本介绍"><a href="#3-1基本介绍" class="headerlink" title="3.1基本介绍"></a><strong>3.1基本介绍</strong></h2><h3 id="3-1-1算术运算符"><a href="#3-1-1算术运算符" class="headerlink" title="3.1.1算术运算符"></a><strong>3.1.1算术运算符</strong></h3><table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*例子*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法 - 相加运算符两侧的值</td>
<td>A + B 等于 30</td>
</tr>
<tr>
<td>-</td>
<td>减法 - 左操作数减去右操作数</td>
<td>A – B 等于 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘法 - 相乘操作符两侧的值</td>
<td>A * B等于200</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法 - 左操作数除以右操作数</td>
<td>B &#x2F; A等于2</td>
</tr>
<tr>
<td>％</td>
<td>取余 - 左操作数除以右操作数的余数</td>
<td>B%A等于0</td>
</tr>
<tr>
<td>++</td>
<td>自增: 操作数的值增加1</td>
<td>B++ 或 ++B 等于 21（区别详见下文）</td>
</tr>
<tr>
<td>–</td>
<td>自减: 操作数的值减少1</td>
<td>B– 或 –B 等于 19（区别详见下文）</td>
</tr>
</tbody></table>
<p>经典面试题</p>
<p>public class t1{</p>
<p>public void main(String[] args){</p>
<p>int i &#x3D; 1;</p>
<p>i &#x3D; i++;&#x2F;&#x2F;等同于temp &#x3D; i;temp &#x3D; i; i &#x3D; i + 1;</p>
<p>System.out.println(i);&#x2F;&#x2F;1</p>
<p>int i &#x3D;1;</p>
<p>i &#x3D; ++i&#x2F;&#x2F;等同于i &#x3D; i+1;temp &#x3D; i;i &#x3D; temp;</p>
<p>System.out.println(i)&#x2F;&#x2F;2</p>
<p>}</p>
<p>}</p>
<h3 id="3-1-2关系运算符"><a href="#3-1-2关系运算符" class="headerlink" title="3.1.2关系运算符"></a><strong>3.1.2关系运算符</strong></h3><p>关系运算符的结果都是boolean型，也就是要么为真（true），要么为假（false）</p>
<table>
<thead>
<tr>
<th><em><strong>*运算符*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*例子*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td>（A &#x3D;&#x3D; B）为假。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td>(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt; B）为假。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td>（A &lt;B）为真。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A&gt; &#x3D; B）为假。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td>（A &lt;&#x3D; B）为真。</td>
</tr>
</tbody></table>
<h3 id="3-1-3逻辑运算符"><a href="#3-1-3逻辑运算符" class="headerlink" title="3.1.3逻辑运算符"></a><strong>3.1.3逻辑运算符</strong></h3><p>假设布尔变量A为真，变量B为假</p>
<table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*例子*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>称为逻辑与操作符。当且仅当两个操作数都为真，条件才为真。</td>
<td>（A&amp;B）为假</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>称为短路与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td>（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td>|</td>
<td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td>（A|B）为真</td>
</tr>
<tr>
<td>| |</td>
<td>称为短路或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td>（A | | B）为真。</td>
</tr>
<tr>
<td>^</td>
<td>称为逻辑异或操作符。如果热河两个操作数不相同，条件为真。</td>
<td>（A^B）为真</td>
</tr>
<tr>
<td>！</td>
<td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td>！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<p>区分&amp;&amp;和&amp;</p>
<ol>
<li>&amp;&amp;短路与：如果第一个条件为false，第二个条件不会判断，最终结果为false，效率高</li>
<li>&amp;逻辑与：如果第一个条件为false，第二个条件还是会继续判断，效率低</li>
<li>开发中，建议使用短路与&amp;&amp;，效率高</li>
</ol>
<p>区分||和|</p>
<ol>
<li>||短路或：如果第一个条件为true，第二个条件不会判断，最终结果为true，效率高</li>
<li>|逻辑或：不管第一个条件是否为true，第二个条件都会判断，效率低</li>
<li>开发中，建议使用短路或||，效率高</li>
</ol>
<p>例：</p>
<p>boolean x &#x3D; true;</p>
<p>boolean y &#x3D;false;</p>
<p>short z &#x3D; 46;</p>
<p>&#x2F;&#x2F;先比较，z&#x3D;&#x3D;46;为真，再自加，此时z&#x3D;47;</p>
<p>&#x2F;&#x2F;再y赋值为true，为真</p>
<p>&#x2F;&#x2F;短路与，都为真，于是执行z++，此时z&#x3D;48</p>
<p>if(( z++&#x3D;&#x3D;46)&amp;&amp;(y&#x3D;true)) z++;</p>
<p>&#x2F;&#x2F;赋值给x为false，为假</p>
<p>&#x2F;&#x2F;先自加，此时z&#x3D;49，为真</p>
<p>&#x2F;&#x2F;短路或，一假一真为真，于是执行z++，此时z&#x3D;50</p>
<p>if((x&#x3D;false)||(++z&#x3D;&#x3D;49)) z++;</p>
<p>&#x2F;&#x2F;最后输出z为50</p>
<p>System.out.println(“z&#x3D;”+z);</p>
<h3 id="3-1-4位运算符"><a href="#3-1-4位运算符" class="headerlink" title="3.1.4位运算符"></a><strong>3.1.4位运算符</strong></h3><table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*例子*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>＆</td>
<td>如果相对应位都是1，则结果为1，否则为0</td>
<td>（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>如果相对应位都是 0，则结果为 0，否则为 1</td>
<td>（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>如果相对应位值相同，则结果为0，否则为1</td>
<td>（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td>〜</td>
<td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td>（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td>A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td>A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td>A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody></table>
<h3 id="3-1-5赋值运算符"><a href="#3-1-5赋值运算符" class="headerlink" title="3.1.5赋值运算符"></a><strong>3.1.5赋值运算符</strong></h3><table>
<thead>
<tr>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
<th><em><strong>*例子*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td>C &#x3D; A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td>+ &#x3D;</td>
<td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td>C + &#x3D; A等价于C &#x3D; C + A</td>
</tr>
<tr>
<td>- &#x3D;</td>
<td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td>C - &#x3D; A等价于C &#x3D; C - A</td>
</tr>
<tr>
<td>* &#x3D;</td>
<td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td>C * &#x3D; A等价于C &#x3D; C * A</td>
</tr>
<tr>
<td>&#x2F; &#x3D;</td>
<td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td>C &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td>（％）&#x3D;</td>
<td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td>C％&#x3D; A等价于C &#x3D; C％A</td>
</tr>
<tr>
<td>&lt;&lt; &#x3D;</td>
<td>左移位赋值运算符</td>
<td>C &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt; &#x3D;</td>
<td>右移位赋值运算符</td>
<td>C &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td>＆&#x3D;</td>
<td>按位与赋值运算符</td>
<td>C＆&#x3D; 2等价于C &#x3D; C＆2</td>
</tr>
<tr>
<td>^ &#x3D;</td>
<td>按位异或赋值操作符</td>
<td>C ^ &#x3D; 2等价于C &#x3D; C ^ 2</td>
</tr>
<tr>
<td>| &#x3D;</td>
<td>按位或赋值操作符</td>
<td>C | &#x3D; 2等价于C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h3 id="3-1-6三元运算符"><a href="#3-1-6三元运算符" class="headerlink" title="3.1.6三元运算符"></a><strong>3.1.6三元运算符</strong></h3><h4 id="v-基本语法"><a href="#v-基本语法" class="headerlink" title="v 基本语法"></a>v 基本语法</h4><p>条件表达式？表达式1:表达式2;</p>
<p>运算规则</p>
<ol>
<li>如果条件表达式为true，运算后的结果是表达式1；</li>
<li>如果条件表达式为false，运算后的结果是表达式2；</li>
</ol>
<h4 id="O-使用细节："><a href="#O-使用细节：" class="headerlink" title="Ø 使用细节："></a>Ø 使用细节：</h4><p>a. 表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）</p>
<p>b. 三元运算符可以转为if–else语句</p>
<h3 id="3-1-7运算符的优先级"><a href="#3-1-7运算符的优先级" class="headerlink" title="3.1.7运算符的优先级"></a><strong>3.1.7运算符的优先级</strong></h3><table>
<thead>
<tr>
<th><em><strong>*类别*</strong></em></th>
<th><em><strong>*操作符*</strong></em></th>
<th><em><strong>*关联性*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>后缀</td>
<td>() [] . (点操作符)</td>
<td>左到右</td>
</tr>
<tr>
<td>一元</td>
<td>expr++ expr–</td>
<td>从左到右</td>
</tr>
<tr>
<td>一元</td>
<td>++expr –expr + - ～ ！</td>
<td>从右到左</td>
</tr>
<tr>
<td>乘性</td>
<td>* &#x2F;％</td>
<td>左到右</td>
</tr>
<tr>
<td>加性</td>
<td>+ -</td>
<td>左到右</td>
</tr>
<tr>
<td>移位</td>
<td>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</td>
<td>左到右</td>
</tr>
<tr>
<td>关系</td>
<td>&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td>
<td>左到右</td>
</tr>
<tr>
<td>相等</td>
<td>&#x3D;&#x3D; !&#x3D;</td>
<td>左到右</td>
</tr>
<tr>
<td>按位与</td>
<td>＆</td>
<td>左到右</td>
</tr>
<tr>
<td>按位异或</td>
<td>^</td>
<td>左到右</td>
</tr>
<tr>
<td>按位或</td>
<td>|</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;&amp;</td>
<td>左到右</td>
</tr>
<tr>
<td>逻辑或</td>
<td>| |</td>
<td>左到右</td>
</tr>
<tr>
<td>条件</td>
<td>？：</td>
<td>从右到左</td>
</tr>
<tr>
<td>赋值</td>
<td>&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;</td>
<td>从右到左</td>
</tr>
<tr>
<td>逗号</td>
<td>，</td>
<td>左到右</td>
</tr>
</tbody></table>
<p>小结：</p>
<p>括号&gt;单目运行&gt;算术运算符&gt;位移运算符&gt;比较运算符&gt;逻辑运算符&gt;三元运算符&gt;赋值运算符</p>
<h2 id="3-2-标识符的命名规则和规范"><a href="#3-2-标识符的命名规则和规范" class="headerlink" title="3.2 标识符的命名规则和规范"></a><strong>3.2 标识符的命名规则和规范</strong></h2><ol>
<li>命名规则（必须遵守）：</li>
</ol>
<p>a. 由26个英文字母大小写，0-9，或$组成</p>
<p>b. 不可以数字开头</p>
<p>c. 不可以使用关键字和保留字，但可以包含关键字和保留字</p>
<p>d. Java中严格区分大小写，长度无限制</p>
<p>e. 标识符不能包含空格</p>
<ol start="2">
<li>命名规范</li>
</ol>
<p>a. 包名：多单词组成时单词都小写</p>
<p>b. 类名、接口名：多单词组成时，所有单词首字母大写</p>
<p>c. 变量名、方法名：多单词组成时，第一个单词首字母小写，后面的每个单词的首字母大写</p>
<p>d. 常量名：所有字母都大写。多单词时每个单词用下划线连接</p>
<h2 id="3-3-键盘输入语句"><a href="#3-3-键盘输入语句" class="headerlink" title="3.3 键盘输入语句"></a><strong>3.3 键盘输入语句</strong></h2><p>用于接收用户输入的数据，需要java.util包中的一个扫描器（对象），就是Scanner</p>
<p>步骤：</p>
<p>&#x2F;&#x2F;1.引入Scanner类所在的包</p>
<p>import java.util.Scanner;</p>
<p>public class input{</p>
<p>public static void main{</p>
<p>&#x2F;&#x2F;2.创建Scanner对象，new创建一个对象</p>
<p>Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>&#x2F;&#x2F;提示用户输入</p>
<p>System.out.println(“请输入名称：”);</p>
<p>&#x2F;&#x2F;3.接受用户输入，使用相关方法</p>
<p>String name &#x3D; Scanner.next();&#x2F;&#x2F;接收用户输入字符串</p>
<p>System.out.println(“请输入年龄：”);</p>
<p>int age &#x3D; Scanner.nextInt();&#x2F;&#x2F;接收用户输入int</p>
<p>System.out.println(“请输入薪水：”);</p>
<p>double sal &#x3D; Scanner.nextDouble();&#x2F;&#x2F;接收用户输入double</p>
<p>System.out.println(“姓名：” + name + “年龄：” + age + “薪水” + sal);</p>
<p>} </p>
<p>}</p>
<h2 id="3-4-进制"><a href="#3-4-进制" class="headerlink" title="3.4 进制"></a><strong>3.4 进制</strong></h2><ol>
<li>进制介绍：</li>
</ol>
<p>a. 二进制：0,1，满2进1，以0b或0B开头</p>
<p>b. 十进制：0-9，满10进1</p>
<p>c. 八进制：0-7，满8进1，以数字0开头表示</p>
<p>d. 十六进制：0-9及A(10)-F(15)，满16进1，以0x或0X开头表示。此处A-F不区分大小写</p>
<ol start="2">
<li>进制的转换</li>
</ol>
<p>a. 第一组（其他进制转十进制）</p>
<p>规则：从最低位（右边）开始，将每个位上的数提出来，乘以x（x进制）的（位数-1）次方，然后求和。</p>
<p>a) 二进制转十进制</p>
<p>0b1110&#x3D;0<em>2^0+1</em>2^1+1<em>2^2+1</em>2^3&#x3D;16</p>
<p>b) 八进制转十进制</p>
<p>0126&#x3D;6<em>8^0+2</em>8^1+1*8^2&#x3D;86</p>
<p>c) 十六进制转十进制</p>
<p>0x19&#x3D;9<em>16^0+1</em>16^1&#x3D;25</p>
<p>b. 第二组</p>
<p>规则：将该数不断除以x（x进制）直到商为0为止，然后将每步得到的余数倒过来，就是对应的 x进制。</p>
<p>a) 十进制转二进制（注意前面用0填充补位，一个字节是八位）</p>
<p>34&#x3D;0b00100010</p>
<p>b) 十进制转八进制</p>
<p>131&#x3D;0203</p>
<p>c) 十进制转十六进制</p>
<p>237&#x3D;0xED</p>
<p>c. 第三组</p>
<p>规则：从低位开始，及那个二进制数每（八进制是三位，十六进制是四位）为一组，转成对应的x进制数即可。</p>
<p>a) 二进制转八进制</p>
<p>0b1(1)111(7)110(6)&#x3D;176</p>
<p>b) 二进制转十六进制</p>
<p>0b11(3)1111(15)1001(9)&#x3D;0x3F9</p>
<p>d. 第四组</p>
<p>规则：将每一位数转成对应的一个（八进制是三位，十六进制是四位）的二进制数即可。</p>
<p>a) 八进制转二进制</p>
<p>025&#x3D;0b010101</p>
<p>b) 十六进制转二进制</p>
<p>0x25&#x3D;0b00100101</p>
<h2 id="3-5-原码、反码、补码"><a href="#3-5-原码、反码、补码" class="headerlink" title="3.5 原码、反码、补码"></a><strong>3.5 原码、反码、补码</strong></h2><p>理解：</p>
<p>对于有符号的而言：</p>
<ol>
<li>二进制的最高位（最左边）是符号位：0是正数，1是负数</li>
<li>正数的原码、反码、补码都一样</li>
<li>负数的反码 &#x3D; 它的原码符号不变，其他位取反（0-&gt;1,1-&gt;0）</li>
<li>负数的补码 &#x3D; 它的反码+1，负数的反码 &#x3D; 负数的补码 - 1</li>
<li>0的反码、补码都是0</li>
<li>java没有无符号数，换言之，java中的数都是有符号的</li>
<li>在计算机运算的时候，都是以补码的方式来运算的</li>
<li>当我们要看运算结果的时候，要看他的原码</li>
</ol>
<h1 id="第四章-控制结构"><a href="#第四章-控制结构" class="headerlink" title="第四章 控制结构"></a><strong>第四章 控制结构</strong></h1><h2 id="4-1顺序控制"><a href="#4-1顺序控制" class="headerlink" title="4.1顺序控制"></a><strong>4.1顺序控制</strong></h2><p>程序默认控制顺序，从上往下，中间没有任何判断和跳转</p>
<p>java中定义变量是采用合法的向前引用。</p>
<h2 id="4-2-分支控制（if-else-switch）"><a href="#4-2-分支控制（if-else-switch）" class="headerlink" title="4.2 分支控制（if-else,switch）"></a><strong>4.2 分支控制（if-else,switch）</strong></h2><h3 id="4-2-1-if-else"><a href="#4-2-1-if-else" class="headerlink" title="4.2.1 if-else"></a><strong>4.2.1 if-else</strong></h3><p>让程序有选择的执行，分为三种：单分支、双分支、多分支。</p>
<h4 id="4-2-1-1-单分支if"><a href="#4-2-1-1-单分支if" class="headerlink" title="4.2.1.1 单分支if"></a><strong>4.2.1.1 单分支if</strong></h4><h5 id="v-基本语法："><a href="#v-基本语法：" class="headerlink" title="v 基本语法："></a>v 基本语法：</h5><p>if(条件表达式){</p>
<p>执行代码块；(可以多条语句)</p>
<p>}</p>
<h5 id="说明：当条件表达式为true是，就会执行-的代码。如果是false就不会执行。"><a href="#说明：当条件表达式为true是，就会执行-的代码。如果是false就不会执行。" class="headerlink" title="说明：当条件表达式为true是，就会执行{}的代码。如果是false就不会执行。"></a>说明：当条件表达式为true是，就会执行{}的代码。如果是false就不会执行。</h5><p>特别说明，如果{}中只有一条语句，可以不用写{}，但是建议写上。</p>
<h4 id="4-2-1-2-双分支if-else"><a href="#4-2-1-2-双分支if-else" class="headerlink" title="4.2.1.2 双分支if-else"></a><strong>4.2.1.2 双分支if-else</strong></h4><h5 id="v-基本语法：-1"><a href="#v-基本语法：-1" class="headerlink" title="v 基本语法："></a>v 基本语法：</h5><p>if(条件表达式){</p>
<p>执行代码块1；</p>
<p>}</p>
<p>else{</p>
<p>执行代码块2;</p>
<p>}</p>
<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>当条件表达式成立，即执行代码块1，否则执行代码块2。</p>
<p>特别说明，如果{}中只有一条语句，可以不用写{}，但是建议写上。</p>
<h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><p>编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第二个数小于20.0，打印两数之和。</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>public static void main(String[] args){</p>
<p>Scanner scanner &#x3D; new Scanner(System.in);</p>
<p>System.out.println(“please input num1:”);</p>
<p>double num1 &#x3D; scanner.nextDouble();</p>
<p>System.out.println(“please input num2:”);</p>
<p>double num2 &#x3D; sanner.nextDouble();</p>
<p>if(num1&gt;10.0 &amp;&amp; num2&lt;20.0){</p>
<p>System.out.println(“num1+num2&#x3D;”+(num1+num2));</p>
<p>}</p>
<p>scanner.close();</p>
<p>}</p>
<p>}</p>
<h4 id="4-2-1-3-多分支if-else"><a href="#4-2-1-3-多分支if-else" class="headerlink" title="4.2.1.3 多分支if-else"></a><strong>4.2.1.3 多分支if-else</strong></h4><h5 id="v-基本语法：-2"><a href="#v-基本语法：-2" class="headerlink" title="v 基本语法："></a>v 基本语法：</h5><p>if(条件表达式){</p>
<p>执行代码块1；</p>
<p>}</p>
<p>else{</p>
<p>执行代码块2;</p>
<p>}</p>
<p>……</p>
<p>else{</p>
<p>执行代码块n;</p>
<p>}</p>
<h5 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h5><p>输入用户的信用分：</p>
<p>如果：</p>
<ol>
<li>信用分为100分时，输出信用极好；</li>
<li>信用分为（80,99]，输出信用一般；</li>
<li>信用分为[60,80]时，输出信用一般；</li>
<li>其他情况，输出信用不及格</li>
<li>请从键盘输入用户 的信用分，并加以判断。</li>
</ol>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p>  Scanner scanner &#x3D; new Scanner(System.in);</p>
<p>  System.out.println(“please input your num:”);</p>
<p>  int num &#x3D; scanner.nextInt();  </p>
<p>  if(num&gt;0 &amp;&amp; num&lt;&#x3D;100 ){</p>
<p>   if( num&#x3D;&#x3D;100){</p>
<p>   System.out.println(“your num is”+ num + “信用极好”);</p>
<p>   }else if(num&lt;&#x3D;99 &amp;&amp; num&gt;80){</p>
<p>​    System.out.println(“your num is”+ num + “xinyongyouxiu”);</p>
<p>​    }else if(num&lt;&#x3D;80 &amp;&amp; num&gt;&#x3D;60){</p>
<p>​     System.out.println(“your num is”+ num + “xinyongyiban”);</p>
<p>​     }else {System.out.println(“your num is”+ num + “xinyongbujige”);}</p>
<p>  }else{</p>
<p>   System.out.println(“please input num in 0-100,try again:”);</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<h4 id="4-2-1-4-嵌套分支if-else"><a href="#4-2-1-4-嵌套分支if-else" class="headerlink" title="4.2.1.4 嵌套分支if-else"></a><strong>4.2.1.4 嵌套分支if-else</strong></h4><p>在一个分支结构中有完整的嵌套了另一个完整的分支结构，里面的分支的结构成为内层分支，外层的分支结构称为外层分支。建议：不要超过三层，可读性不好。</p>
<h5 id="v-基本语法：-3"><a href="#v-基本语法：-3" class="headerlink" title="v 基本语法："></a>v 基本语法：</h5><p>if(){</p>
<p>if(){</p>
<p>&#x2F;&#x2F;if-else</p>
<p>}else{</p>
<p>&#x2F;&#x2F;if-else</p>
<p>}</p>
<p>}</p>
<h5 id="例题：-2"><a href="#例题：-2" class="headerlink" title="例题："></a>例题：</h5><p>出票系统：根据淡旺季的月份和游客的年龄，打印票价</p>
<p>4-10月旺季：成人（18-60）60元 儿童（&lt;18）半价 老人（&gt;60）1&#x2F;3</p>
<p>淡季：成人40元 其他20元</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D;new Scanner(System.in);</p>
<p>​    System.out.println(“请输入当前月份 “);</p>
<p>​    int mouth &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入当前年龄 “);</p>
<p>​    int age &#x3D; myScanner.nextInt();    </p>
<p>​    if(mouth&gt;4 &amp;&amp; mouth &lt;10){</p>
<p>​      &#x2F;&#x2F; System.out.println(“当前为旺季”)</p>
<p>​      if(age&lt;18){</p>
<p>​        System.out.println(“儿童的票价是30元。”);</p>
<p>​      }else if(age&gt;18 &amp;&amp; age&lt;60){</p>
<p>​        System.out.println(“成年人的票价是60元。”);</p>
<p>​      }else{</p>
<p>​        System.out.println(“老年人的票价是20元。”);</p>
<p>​      }</p>
<p>​    }else if(age&gt;18 &amp;&amp; age&lt;60){</p>
<p>​        System.out.println(“成年人的票价是40元。”);</p>
<p>​      }else{</p>
<p>​        System.out.println(“其他人员的票价是20元。”);</p>
<p>​      }</p>
<p>  } </p>
<p>}</p>
<h4 id="4-2-1-5-switch分支结构"><a href="#4-2-1-5-switch分支结构" class="headerlink" title="**4.2.1.**5 switch分支结构"></a>**4.2.1.**<strong>5 switch分支结构</strong></h4><h5 id="v-基本语法：-4"><a href="#v-基本语法：-4" class="headerlink" title="v 基本语法："></a>v 基本语法：</h5><p>switch（表达式）{</p>
<p>case常量1:&#x2F;&#x2F;当……</p>
<p>语句块1;</p>
<p>break;&#x2F;&#x2F;跳出switch循环，不是结束程序</p>
<p>……</p>
<p>case常量n:</p>
<p>break;</p>
<p>default;</p>
<p>default语句块;</p>
<p>break;</p>
<p>}</p>
<h5 id="O-说明："><a href="#O-说明：" class="headerlink" title="Ø 说明："></a>Ø 说明：</h5><p>1、switch关键字，表示switch分支</p>
<p>2、表达式对应一个值</p>
<p>3、case常量1:当表达式的值等于常量1，就执行语句块1</p>
<p>4、break:表示退出switch</p>
<p>5、如果和case常量1匹配，就执行语句块1，如果没有匹配，就继续匹配case常量2</p>
<p>6、default子句是可选的，如果一个都没匹配上，就执行default</p>
<p>7、如果case常量1 执行完语句块1后没有break会不取匹配case常量2直接去执行语句块2，会顺序执行到switch结尾</p>
<p>8、表达式数据类型，应和case后的常量类型一致，或者可以自动转成相互比较的类型，比如输入的是字符，而常量是int</p>
<p>9、switch（表达式）的返回值必须是：（byte、short、int、char、enum、String）</p>
<p>10、case子句中的值必须是常量，而不能是变量</p>
<p>例题</p>
<p>1、编写一个程序，接受第一个字符比如a，b，……，其中a表示星期一，b表示星期二……，根据用户的输入显示相依的信息，要求使用switch语句完成。</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入字符”);</p>
<p>​    char character &#x3D; myScanner.next().charAt(0);</p>
<p>​    switch(character){</p>
<p>​      case ‘a’:</p>
<p>​        System.out.println(“周一”);</p>
<p>​        break;</p>
<p>​      case ‘b’:</p>
<p>​        System.out.println(“周二”);</p>
<p>​        break;</p>
<p>​      case ‘c’:</p>
<p>​        System.out.println(“周三”);</p>
<p>​        break;</p>
<p>​      case ‘d’:</p>
<p>​        System.out.println(“周四”);</p>
<p>​        break;</p>
<p>​      case ‘e’:</p>
<p>​        System.out.println(“周五”);  </p>
<p>​        break;</p>
<p>​      case ‘f’:</p>
<p>​        System.out.println(“周六”);</p>
<p>​      case ‘g’:</p>
<p>​        System.out.println(“周七”);        </p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入字符</p>
<p>f</p>
<p>周六</p>
<p>周七</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入字符</p>
<p>a</p>
<p>周一</p>
<p>2、使用switch把小写类型的char型转为大写（键盘输入）。只转换a，b，c，其他的输出“other”</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入需要转换的字母：”);</p>
<p>​    char character &#x3D; myScanner.next().charAt(0);</p>
<p>​    switch(character){</p>
<p>​      case ‘a’:</p>
<p>​        System.out.println(“A”);</p>
<p>​        break;</p>
<p>​      case ‘b’:</p>
<p>​        System.out.println(“B”);</p>
<p>​        break;</p>
<p>​      case ‘c’:</p>
<p>​        System.out.println(“C”);</p>
<p>​        break;</p>
<p>​      default:</p>
<p>​        System.out.println(“other”);</p>
<p>​        break;</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入需要转换的字母：</p>
<p>a</p>
<p>A</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入需要转换的字母：</p>
<p>b</p>
<p>B</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入需要转换的字母：</p>
<p>t</p>
<p>other</p>
<p>3、根据用于指定月份，打印该月份所属的季节。3、4、5春季，6、7、8夏季，9、10、11秋季，12、1、2冬季（提示使用穿透）</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入当前的月份：”);</p>
<p>​    int mouth &#x3D; myScanner.nextInt();</p>
<p>​    switch(mouth){</p>
<p>​      case 3:</p>
<p>​      case 4:</p>
<p>​      case 5:</p>
<p>​        System.out.println(“春季”);</p>
<p>​        break;</p>
<p>​      case 6:</p>
<p>​      case 7:</p>
<p>​      case 8:</p>
<p>​        System.out.println(“夏季”);</p>
<p>​        break;</p>
<p>​      case 9:</p>
<p>​      case 10:</p>
<p>​      case 11:</p>
<p>​        System.out.println(“秋季”);</p>
<p>​        break;</p>
<p>​      case 12:</p>
<p>​      case 1:</p>
<p>​      case 2:</p>
<p>​        System.out.println(“冬季”);</p>
<p>​        break;</p>
<p>​      default:</p>
<p>​        System.out.println(“你输入的月份不对，请输入1-12月份”);        </p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入当前的月份：</p>
<p>13</p>
<p>你输入的月份不对，请输入1-12月份</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>请输入当前的月份：</p>
<p>1</p>
<p>冬季</p>
<h4 id="4-2-1-6-switch和if的比较"><a href="#4-2-1-6-switch和if的比较" class="headerlink" title="4.2.1.6 switch和if的比较"></a><strong>4.2.1.6 switch和if的比较</strong></h4><p>1、如果判断的具体数值不多，并且符合返回值按类型是：（byte、short、int、char、enum[美枚举]、String），建议使用switch；</p>
<p>2、其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。</p>
<h2 id="4-3-循环控制（for-while-do-while-多重循环）"><a href="#4-3-循环控制（for-while-do-while-多重循环）" class="headerlink" title="4.3 循环控制（for,while,do-while,多重循环）"></a><strong>4.3 循环控制（for,while,do-while,多重循环）</strong></h2><h3 id="4-3-1-for循环控制"><a href="#4-3-1-for循环控制" class="headerlink" title="4.3.1 for循环控制"></a><strong>4.3.1 for循环控制</strong></h3><h4 id="v-基本语法：-5"><a href="#v-基本语法：-5" class="headerlink" title="v 基本语法："></a>v 基本语法：</h4><p>for（循环变量初始化;循环判断条件;循环变量迭代）{</p>
<p>循环操作（可以多条语句）;</p>
<p>}</p>
<h4 id="O-说明：-1"><a href="#O-说明：-1" class="headerlink" title="Ø 说明："></a>Ø 说明：</h4><p>1、for关键字，表示循环控制</p>
<p>2、四要素：循环变量初始化，循环判断条件，循环操作，循环变量迭代</p>
<p>3、基础操作，这里可以多条语句，也就是循环执行的代码</p>
<p>4、如果，循环操作（语句）只有一句语句，可以省略{}符号，建议不省略</p>
<p>5、循环判断条件时的返回的一个布尔值的表达式</p>
<p>6、for（;循环判断条件;）中的初始化和变量迭代可以写在其他地方，但是条件的两边的分号不能省略</p>
<p>7、循环初始值可以是多条初始化语句，但是要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用都好隔开</p>
<p>8、使用内存分析法，</p>
<p>public class t1{</p>
<p>  public static void main(String[] agrs){</p>
<p>​    int count &#x3D; 3;</p>
<p>​    for( ①<u>int i &#x3D; 0,j &#x3D; 0</u>;  ② <u>i &lt; count</u>;  ④ <u>i++,j+&#x3D;2</u>){</p>
<p>​      ③<u>System.out.println(“i&#x3D;” + i + “j&#x3D;”+ j)</u>;</p>
<p>&#x2F;&#x2F;注意执行顺序</p>
<p>​    }</p>
<p>  } </p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>i&#x3D;0j&#x3D;0</p>
<p>i&#x3D;1j&#x3D;2</p>
<p>i&#x3D;2j&#x3D;4</p>
<p>例子：</p>
<p>public class t1{</p>
<p>  public static void main(String[] agrs){</p>
<p>​    for(int i&#x3D;0; i&lt;&#x3D;10; i++){</p>
<p>​      System.out.println(“你好”+i);</p>
<p>​    }</p>
<p>  } </p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java</p>
<p>你好0</p>
<p>你好1 </p>
<p>你好2 </p>
<p>你好3 </p>
<p>你好4 </p>
<p>你好5 </p>
<p>你好6 </p>
<p>你好7 </p>
<p>你好8 </p>
<p>你好9 </p>
<p>你好10</p>
<p>练习：</p>
<p>1、打印自定义范围之间所有的能被某整除的数，统计个数及总和。</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] agrs){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    int count &#x3D; 0;</p>
<p>​    int sum &#x3D; 0;</p>
<p>​    &#x2F;&#x2F;从用户端接收范围</p>
<p>​    System.out.println(“请输入范围开始的数：”);    </p>
<p>​    int start &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入范围结束的数：”);  </p>
<p>​    int end &#x3D; myScanner.nextInt();</p>
<p>​    &#x2F;&#x2F;被几整除</p>
<p>​    System.out.println(“请输入整除数：”);  </p>
<p>​    int t &#x3D; myScanner.nextInt();</p>
<p>​    for(int i &#x3D; start; i &lt; end; i++){</p>
<p>​      if(i % t &#x3D;&#x3D; 0){</p>
<p>​        System.out.println(“i &#x3D; “+i);</p>
<p>​        count +&#x3D; 1;</p>
<p>​        sum +&#x3D; i;</p>
<p>​      }</p>
<p>​    }</p>
<p>​    System.out.println(“count &#x3D; “+count);</p>
<p>​    System.out.println(“sum &#x3D; “+sum);</p>
<p>  } </p>
<p>}</p>
<p>2、完成下面的表达式的输出（自定义字符）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200929404.png"></p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] agrs){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入操作字符：”);</p>
<p>​    int num &#x3D; myScanner.nextInt();</p>
<p>​    &#x2F;&#x2F; for(int i &#x3D; 0; i &lt;&#x3D; num; i++){</p>
<p>​    &#x2F;&#x2F;  System.out.println(i+”+”+(num-i)+”&#x3D;”+num);</p>
<p>​    &#x2F;&#x2F; }</p>
<p>​    for(int i &#x3D; num, j &#x3D; 0; i &gt;&#x3D; 0; i–, j++){</p>
<p>​      System.out.println(i+”+”+j+”&#x3D;”+(i+j));</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<h3 id="4-3-2-while循环"><a href="#4-3-2-while循环" class="headerlink" title="4.3.2 while循环"></a><strong>4.3.2 while循环</strong></h3><h4 id="v-基本语法：-6"><a href="#v-基本语法：-6" class="headerlink" title="v 基本语法："></a>v 基本语法：</h4><p>循环初始化;</p>
<p>while(循环条件){</p>
<p>循环体（语句）;</p>
<p>循环变量迭代;</p>
<p>}</p>
<h4 id="O-说明：-2"><a href="#O-说明：-2" class="headerlink" title="Ø 说明："></a>Ø 说明：</h4><p>1、while循环也有四要素</p>
<p>2、四要素的放置位置与for的不一样</p>
<p>3、返回值是布尔值的表达式</p>
<p>4、注意区分，while是<u>先判断再循环</u></p>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>打印自定义范围之间所有能被自定义数字整除的数（使用while）</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入范围开始指：”);</p>
<p>​    int start &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入范围结束值：”);</p>
<p>​    int end &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入整除数：”);</p>
<p>​    int num &#x3D; myScanner.nextInt();</p>
<p>​    while(start &lt;&#x3D; end){</p>
<p>​      if (start % num &#x3D;&#x3D; 0)  {</p>
<p>​        System.out.println(“n&#x3D;”+ start);</p>
<p>​      }</p>
<p>​      start++;&#x2F;&#x2F;位置在哪儿很重要</p>
<p>​    }</p>
<p>​    System.out.println(“结束”);</p>
<p>​    myScanner.close();</p>
<p>  }</p>
<p>}</p>
<h3 id="4-3-3-do…while循环控制"><a href="#4-3-3-do…while循环控制" class="headerlink" title="4.3.3  do…while循环控制"></a><strong>4.3.3  do…while循环控制</strong></h3><h4 id="v-基本语法：-7"><a href="#v-基本语法：-7" class="headerlink" title="v 基本语法："></a>v 基本语法：</h4><p>循环变量初始化;</p>
<p>do{</p>
<p>循环体（语句）;</p>
<p>循环变量迭代;</p>
<p>}while(循环条件);</p>
<h4 id="O-说明：-3"><a href="#O-说明：-3" class="headerlink" title="Ø 说明："></a>Ø 说明：</h4><p>1、do while是关键字</p>
<p>2、也有四要素但是放置位置不一样</p>
<p>3、先执行、再判断，也就是说，一定会执行一次</p>
<p>4、最后有一个分号;</p>
<p>5、注意do…while和while的区别</p>
<h4 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h4><p>1、打印自定义范围之间所有的能被某整除但不能被某整除的个数。</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>   public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“请输入范围开始指：”);</p>
<p>​    int start &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入范围结束值：”);</p>
<p>​    int end &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入能被整除数：”);</p>
<p>​    int yesnum &#x3D; myScanner.nextInt();</p>
<p>​    System.out.println(“请输入不能被整除数：”);</p>
<p>​    int nonum &#x3D; myScanner.nextInt();</p>
<p>​    int count &#x3D; 0;</p>
<p>​    do{</p>
<p>​      if (start % 5 &#x3D;&#x3D; 0 &amp;&amp; start % 3 !&#x3D; 0 ) {</p>
<p>​        System.out.println(“n&#x3D;”+start);</p>
<p>​        count++;</p>
<p>​      }</p>
<p>​      start++;</p>
<p>​    }while(start &lt;&#x3D; end);</p>
<p>​    System.out.println(“count&#x3D;”+count);</p>
<p> }</p>
<p>}</p>
<p>1、如果t1不说n，则t0将一直说你好，直到t1说n为止</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>   public static void main(String[] args){</p>
<p>​    Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>​    System.out.println(“以下问题请回答y&#x2F;n”);</p>
<p>​    char yn &#x3D;’ ‘;</p>
<p>​    do{</p>
<p>​      System.out.println(“你好”);</p>
<p>​      yn &#x3D; myScanner.next().charAt(0);</p>
<p>​      System.out.println(“你好”);      </p>
<p>​    }while(yn &#x3D;&#x3D; ‘n’);</p>
<p>​    System.out.println(“再见”);</p>
<p> }</p>
<p>}</p>
<h3 id="4-3-4-多重循环"><a href="#4-3-4-多重循环" class="headerlink" title="4.3.4 多重循环"></a><strong>4.3.4 多重循环</strong></h3><p>介绍：</p>
<p>1、讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for，while，do…while均可作为外层循环体和内层循环。（建议一般使用两层，最多不超过3层，否则，代码的可读性会很差）</p>
<p>2、实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可以结束外层循环的当次循环，开始下一次的循环</p>
<p>3、设外层循环次数为m次，内层为n层，则内层循环体实际上需要执行m*n次</p>
<p>for(int i &#x3D; 1; i &lt;&#x3D; 7; i++){</p>
<p>for(int j &#x3D; 1; j &lt;&#x3D; 2; j++){</p>
<p>System.out.println(“ok~~~”);&#x2F;&#x2F;7*2&#x3D;14</p>
<p>}</p>
<p>}</p>
<p>例题练习：</p>
<p>1、统计三个班的成绩情况，每个班有五名同学，求出各个班的平均分和所有班级的平均分[学生从键盘输入]</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>  int class1 &#x3D; 0;</p>
<p>  System.out.println(“请输入1班的成绩”);</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) {</p>
<p>​    System.out.println(“第”+i+”位同学：”);</p>
<p>​    int num1 &#x3D; myScanner.nextInt();</p>
<p>​    class1 +&#x3D; num1;</p>
<p>  }</p>
<p>  int class2 &#x3D; 0;</p>
<p>  System.out.println(“请输入2班的成绩”);</p>
<p>  for(int j &#x3D; 1; j &lt;&#x3D; 5; j++) {</p>
<p>​    System.out.println(“第”+j+”位同学：”);</p>
<p>​    int num2 &#x3D; myScanner.nextInt();</p>
<p>​    class2 +&#x3D; num2;</p>
<p>  }</p>
<p>  int class3 &#x3D; 0;</p>
<p>  System.out.println(“请输入3班的成绩”);</p>
<p>  for(int c &#x3D; 1; c &lt;&#x3D; 5; c++) {</p>
<p>​    System.out.println(“第”+c+”位同学：”);</p>
<p>​    int num3 &#x3D; myScanner.nextInt();</p>
<p>​    class3 +&#x3D; num3;</p>
<p>  }</p>
<p>  System.out.println(“各个班的平均成绩：”);</p>
<p>  System.out.println(“1班的平均成绩：”+(class1&#x2F;5));</p>
<p>  System.out.println(“2班的平均成绩：”+(class2&#x2F;5));  </p>
<p>  System.out.println(“3班的平均成绩：”+(class3&#x2F;5));</p>
<p>  System.out.println(“各个班的平均成绩：”+((class1+class2+class3)&#x2F;3));</p>
<p> }</p>
<p>}</p>
<p>2、统计出三个班及格人数，每个班有5名同学</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>  int class1 &#x3D; 0;</p>
<p>  System.out.println(“请输入1班的成绩”);</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) {</p>
<p>​    System.out.println(“第”+i+”位同学：”);</p>
<p>​    int num1 &#x3D; myScanner.nextInt();</p>
<p>​    if(num1 &gt;&#x3D; 60){</p>
<p>​      class1 +&#x3D; 1;</p>
<p>​    }</p>
<p>  }</p>
<p>  int class2 &#x3D; 0;</p>
<p>  System.out.println(“请输入2班的成绩”);</p>
<p>  for(int j &#x3D; 1; j &lt;&#x3D; 5; j++) {</p>
<p>​    System.out.println(“第”+j+”位同学：”);</p>
<p>​    int num2 &#x3D; myScanner.nextInt();</p>
<p>​    if(num2 &gt;&#x3D; 60){</p>
<p>​      class2 +&#x3D; 1;</p>
<p>​    }</p>
<p>  }</p>
<p>  int class3 &#x3D; 0;</p>
<p>  System.out.println(“请输入3班的成绩”);</p>
<p>  for(int c &#x3D; 1; c &lt;&#x3D; 5; c++) {</p>
<p>​    System.out.println(“第”+c+”位同学：”);</p>
<p>​    int num3 &#x3D; myScanner.nextInt();</p>
<p>​    if(num3 &gt;&#x3D; 60){</p>
<p>​      class3 +&#x3D; 1;</p>
<p>​    }</p>
<p>  }</p>
<p>  System.out.println(“各个班的平均成绩：”);</p>
<p>  System.out.println(“1班的及格人数：”+class1);</p>
<p>  System.out.println(“2班的及格人数：”+class2);  </p>
<p>  System.out.println(“3班的及格人数：”+class3);</p>
<p>  System.out.println(“所有班总共及格人数：”+(class1+class2+class3));</p>
<p> }</p>
<p>}</p>
<p>优化后：</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p> Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p> int classnum &#x3D; 0;</p>
<p> for(int i &#x3D; 1; i &lt;&#x3D; 3; i++){</p>
<p>  for(int j &#x3D; 1; j &lt;&#x3D; 5; j++){</p>
<p>​    System.out.println(“请输入”+i+”班”+”第”+j+”位同学的成绩：”);</p>
<p>​    int num &#x3D; myScanner.nextInt();  </p>
<p>​    classnum +&#x3D; num;</p>
<p>  }</p>
<p>  System.out.println(“班的平均成绩是：”+(classnum&#x2F;5));   </p>
<p> }</p>
<p> }</p>
<p>}</p>
<p>3、打印出九九乘法表梯形</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p> Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>&#x2F;&#x2F;  System.out.println(“请输入想要的层数：”);</p>
<p>&#x2F;&#x2F;  int layers &#x3D; myScanner.nextInt(); </p>
<p> for(int i &#x3D; 1; i &lt;&#x3D; 9; i++){</p>
<p>  for(int j &#x3D; 1; j &lt;&#x3D; i; j++){</p>
<p>   System.out.print(i+”<em>“+j+”&#x3D;”+(i</em>j)+”\t”);</p>
<p>  }</p>
<p>  System.out.println();</p>
<p> }</p>
<p>}</p>
<p>}</p>
<p>附加练习：</p>
<p>（星号金字塔）：</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>  System.out.println(“请输入想要的层数：”);</p>
<p>  int layers &#x3D; myScanner.nextInt(); </p>
<p>  &#x2F;&#x2F; 打印金字塔</p>
<p>  &#x2F;&#x2F;有i层</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; layers; i++){</p>
<p>​    &#x2F;&#x2F;有多少个空格</p>
<p>​    for(int k &#x3D; 1; k &lt;&#x3D; layers-i; k++){</p>
<p>​      System.out.print(“ “);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F;输出*号</p>
<p>​    for(int j &#x3D; 1; j &lt;&#x3D; 2 * i -1; j++){</p>
<p>​      System.out.print(“*”);</p>
<p>​    }</p>
<p>​    System.out.println();</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java </p>
<p>请输入想要的层数：</p>
<p>5</p>
<ul>
<li></li>
</ul>
<hr>
<hr>
<hr>
<hr>
<p>（空心金字塔）：</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>  System.out.println(“请输入想要的层数：”);</p>
<p>  int layers &#x3D; myScanner.nextInt(); </p>
<p>  &#x2F;&#x2F; 打印金字塔</p>
<p>  &#x2F;&#x2F;有i层</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; layers; i++){</p>
<p>​    &#x2F;&#x2F;有多少个空格</p>
<p>​    for(int k &#x3D; 1; k &lt;&#x3D; layers-i; k++){</p>
<p>​      System.out.print(“ “);</p>
<p>​    }</p>
<p>​    &#x2F;&#x2F;输出*号</p>
<p>​    for(int j &#x3D; 1; j &lt;&#x3D; 2 * i -1; j++){</p>
<p>​      if (j &#x3D;&#x3D; 1 || j &#x3D;&#x3D; 2 * i - 1 || i &#x3D;&#x3D; layers) {</p>
<p>​        System.out.print(“*”);</p>
<p>​      }else{</p>
<p>​        System.out.print(“ “);</p>
<p>​      }</p>
<p>​    }</p>
<p>​    System.out.println();</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java </p>
<p>请输入想要的层数：</p>
<p>8</p>
<p>​    *</p>
<p>   * *</p>
<p>   *  *</p>
<p>  *   *</p>
<p>  *    *</p>
<p> *     *</p>
<p> *      *</p>
<hr>
<h2 id="4-4-break"><a href="#4-4-break" class="headerlink" title="4.4 break"></a><strong>4.4 break</strong></h2><p>介绍：</p>
<p>break语句用于终止某个语句块的执行，一般使用在switch或者循环[for]中</p>
<p>v 基本语法：</p>
<p>{	……</p>
<p>break;</p>
<p>……</p>
<p>}</p>
<p>Ø 说明：</p>
<p>1、break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一句语句块</p>
<p>2、标签的基本使用：</p>
<p>label1:{……</p>
<p>label2:	{……</p>
<p>label3		{……</p>
<p>break label2;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>Ø 说明：</p>
<p>（1）break语句可以指定终止退出哪层</p>
<p>（2）label1是标签，名字有程序员指定</p>
<p>（3）break后指定到哪个label就退出到哪儿</p>
<p>（4）在实验的开发中，尽量不要使用标签</p>
<p>（5）如果没有指定label，就默认退出最近的循环体</p>
<p>附加：</p>
<p>随机生成数字可以使用</p>
<p>System.out.println((int)(Math.random()*100));</p>
<p>Ø 说明：</p>
<p>1、原始Math.randon()输出的是0.……</p>
<p>2、int是转换为整数，控制输出为整数</p>
<p>3、*100，是控制想要的位数，当前为输出两位数</p>
<h3 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h3><p>1、1-100以内的数求和，求出 当和第一次大于20的当前数[for+break]</p>
<p>public class t1{</p>
<p> public static void main(String[] args){</p>
<p>  int sum &#x3D; 0;</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; 100; i++){</p>
<p>​    sum +&#x3D; i;</p>
<p>​    if (sum &gt; 20) {</p>
<p>​      System.out.println(“i&#x3D;”+i);</p>
<p>​      break;</p>
<p>​    }</p>
<p> }</p>
<p>}</p>
<p>}</p>
<p>运行结果：</p>
<p>PS E:\myself\Java&gt; javac t1.java</p>
<p>PS E:\myself\Java&gt; java t1.java </p>
<p>i&#x3D;6</p>
<p>2、实现登录验证，有三次机会，吐过用户名为“丁真”，密码“666”提示登陆成功，否则提示还有几次机会，请使用for+break完成</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>&#x2F;&#x2F;现在外面定义字符串</p>
<p>  String name &#x3D; “ “;</p>
<p>  String paw &#x3D; “ “;</p>
<p>  for(int i &#x3D; 1; i &lt;&#x3D; 3; i++){</p>
<p>​    System.out.println(“请输入用户名：”);</p>
<p>​    name &#x3D; myScanner.next();</p>
<p>​    System.out.println(“请输入密码：”);</p>
<p>​    paw &#x3D; myScanner.next();</p>
<p>&#x2F;&#x2F;equals方法，将字符串的内容进行比较，返回的是boolean值</p>
<p>​    if (“丁真”.equals(name) &amp;&amp; “666”.equals(paw)) {</p>
<p>​      System.out.println(“恭喜登陆成功”);</p>
<p>​    }else{</p>
<p>​      System.out.println(“你还有”+(3-i)+”次机会。”); </p>
<p>​    }</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<h2 id="4-5-continue"><a href="#4-5-continue" class="headerlink" title="4.5 continue"></a><strong>4.5 continue</strong></h2><p>介绍：</p>
<p>1、continue语句用于结束本次循环，继续执行下次循环</p>
<p>2、continue语句现在出现在多层嵌套的循环语句体中国，可以通过标签指明窈窕过的是哪一层循环，和break的使用规则一样</p>
<p>v 基本语法：</p>
<p>{	……</p>
<p>continue；</p>
<p>……</p>
<p>}</p>
<h2 id="4-6-return"><a href="#4-6-return" class="headerlink" title="4.6 return"></a><strong>4.6 return</strong></h2><p>介绍：</p>
<p>return使用在方法，表示跳出所在的方法。现只简单记录。</p>
<p>注意：如果return写在main方法中，退出程序。</p>
<h2 id="本章练习题"><a href="#本章练习题" class="headerlink" title="本章练习题"></a><strong>本章练习题</strong></h2><p>1、编程实现如下功能：</p>
<p>某人有100，000元，每经过一次路口，需要交费，规则如下：</p>
<p>1）当现金&gt;50000时，每次交5%；</p>
<p>2）当现金&lt;&#x3D;50000时，每次交1000</p>
<p>编程计算该人可以经过多少次路口，要求使用while，break方式完成。</p>
<p>讲解视频链接如下：</p>
<p><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=148&vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc">https://www.bilibili.com/video/BV1fh411y7R8?p=148&amp;vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc</a></p>
<p>2、实现判断一个整数，属于哪个范围：大于0；小于0；等于0</p>
<p>3、判断一个年份是否为润年</p>
<p>4、判断一个整体是否是水仙花数，所谓水仙花数是指3位数，其各个位上数字立方和，等于其本身。例如：153&#x3D;1<em>1</em>1+5<em>5</em>5+3<em>3</em>3</p>
<p>5、输出1-100之间的不能被5整除的数，每5个一行</p>
<p>6、输出小写的a-z以及大写的Z-A</p>
<p>7、求出1-1&#x2F;2+1&#x2F;3-1&#x2F;4……1&#x2F;100的和</p>
<p>8、求 1+（1+2）+（1+2+3）+……+（1+2+……+100）的结果</p>
<h1 id="第五章-数组Array"><a href="#第五章-数组Array" class="headerlink" title="第五章 数组Array"></a><strong>第<strong><strong>五</strong></strong>章</strong> <strong>数组Array</strong></h1><h2 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a><strong>5.1 数组</strong></h2><p>介绍：</p>
<p>数组可以同时存放多个同一类型的数据。数组也是一种数据类型，是引用类型。</p>
<p>即：数组就是一组数据。</p>
<h3 id="v-使用方式："><a href="#v-使用方式：" class="headerlink" title="v 使用方式："></a>v 使用方式：</h3><p>1、动态初始化</p>
<p>（1）数组的定义</p>
<p>数据类型 数组名[] &#x3D;  new 数据类型[大小]</p>
<p>int a[] &#x3D; new int[5];&#x2F;&#x2F;创建了一个数组，名字a，存放5个int</p>
<p>（2）数组的引用（使用&#x2F;访问&#x2F;获取数组元素）</p>
<p>数组名[下标&#x2F;索引&#x2F;index] 比如：访问数组的第三个元素 a[2]</p>
<p>数组的是从0开始的</p>
<p>（3）快速入门案例</p>
<p>循环输入5个成绩，保存到double数组，并输出</p>
<p>import java.util.Scanner;</p>
<p>public class t1{</p>
<p>  public static void main(String[] args){</p>
<p>  Scanner myScanner &#x3D; new Scanner(System.in);</p>
<p>  double a[] &#x3D; new double[5];</p>
<p>  for(int i &#x3D; 0; i &lt; a.length; i++){</p>
<p>​    System.out.println(“请输入第”+(i+1)+”个元素的值：”);</p>
<p>​    a[i] &#x3D; myScanner.nextDouble();</p>
<p>  }</p>
<p>  for(int i &#x3D; 0; i &lt; a.length; i++){</p>
<p>​    System.out.println(“第”+(i+1)+”个元素的值是：”+a[i]);</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<p>2、动态初始化</p>
<p>（1）先声明数组</p>
<p>语法：数据类型 数组名[];也可以 数据类型[] 数组名;</p>
<p>int a[]; 或者 int[] a;</p>
<p>（2）创建数组</p>
<p>语法：数组名 &#x3D; new 数据类型[大小]</p>
<p>a &#x3D; new int[10];</p>
<p>3、静态初始化</p>
<p>（1）初始化数组</p>
<p>语法：数据类型 数组名[] &#x3D; {元素值,元素值……}</p>
<p>int a[]&#x3D;{1,2,3,……}</p>
<p>如果知道数组有多少元素，具体值用上面的用法，相当于：</p>
<p>int a[] &#x3D; new int[3];</p>
<p>a[0]&#x3D;2;a[1]&#x3D;5;a[2]&#x3D;9;</p>
<p>（2）快速入门案例</p>
<p>double hens[] &#x3D; {1,2,3……}</p>
<p>等价于</p>
<p>hens[0]&#x3D;1;hens[1]&#x3D;2;……</p>
<h3 id="O-说明：-4"><a href="#O-说明：-4" class="headerlink" title="Ø 说明："></a>Ø 说明：</h3><p>1、数组是多个相同数据类型的组合，实现对这些数据的统一的管理</p>
<p>2、数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</p>
<p>3、数组创建后，如果没有赋值，有默认值：int-0,short-0,byte-0,long-0,float-0.0,double-0.0,char\u0000,boolean-false,String-null</p>
<p>4、使用数组的步骤：声明数组并开辟空间；给数组各个元素赋值；使用数组。</p>
<p>5、数组的下标是从0开始的</p>
<p>6、数组的下标必须在指定范围内使用，否则报错：下标越界异常，比如int[] arr &#x3D;new int[5];则有效下标位0-4</p>
<p>7、数组属引用类型，数组型数据是对象（object）</p>
<p>应用案例：</p>
<p>1、创建一个char类型的26个元素的数组，分别放置 ‘A’ - ‘Z’ 。使用for循环访问所有元素并打印踹。提示：char类型数据运算 ‘A’ + 1 -&gt; ‘B’</p>
<p>2、请求出一个数组int[]的最大值{4，-1，9，10，23}，并得到对应的下标</p>
<p>3、请求出一个数组的和 和 平均值。</p>
<p>附加：</p>
<p>可以通过 数组名.length 得到数组的大小&#x2F;长度</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>安卓逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意软件分析计划</title>
    <url>/2025/02/22/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>以下是半年恶意软件分析学习计划，分为基础构建、专业提升、实战应用三个阶段。计划兼顾零基础起点和恶意软件分析的专业需求，注重高效学习和实践结合：</p>
<hr>
<h3 id="📅-第一阶段：计算机基础与编程入门（第1-2个月）"><a href="#📅-第一阶段：计算机基础与编程入门（第1-2个月）" class="headerlink" title="📅 第一阶段：计算机基础与编程入门（第1-2个月）"></a><strong>📅 第一阶段：计算机基础与编程入门（第1-2个月）</strong></h3><p><strong>目标</strong>：掌握计算机基础操作、网络基础、Python和C语言基础。</p>
<ol>
<li><p><strong>计算机基础（1周）</strong></p>
<ul>
<li><strong>操作系统</strong>：学习Windows&#x2F;Linux基础命令（文件管理、进程管理）、虚拟机安装（VMware&#x2F;VirtualBox）。</li>
<li><strong>网络基础</strong>：理解IP地址、端口、TCP&#x2F;UDP协议，用Wireshark抓包分析HTTP流量。</li>
</ul>
</li>
<li><p><strong>编程入门（3周）</strong></p>
<ul>
<li><strong>Python</strong>：学习语法、文件操作、正则表达式、网络请求（<code>requests</code>库），完成简单爬虫或日志分析脚本。</li>
<li><strong>C语言</strong>：掌握指针、内存管理、结构体，编写简单的内存操作程序（如模拟缓冲区溢出）。</li>
</ul>
</li>
<li><p><strong>工具准备（1周）</strong></p>
<ul>
<li>搭建虚拟机实验环境（Windows + Linux双系统）。</li>
<li>安装基础工具：IDA Pro Free版、Ghidra、Wireshark、Process Monitor。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="📚-第二阶段：信息安全与恶意软件分析基础（第3-4个月）"><a href="#📚-第二阶段：信息安全与恶意软件分析基础（第3-4个月）" class="headerlink" title="📚 第二阶段：信息安全与恶意软件分析基础（第3-4个月）"></a><strong>📚 第二阶段：信息安全与恶意软件分析基础（第3-4个月）</strong></h3><p><strong>目标</strong>：掌握安全核心概念，学习静态&#x2F;动态分析基础。</p>
<ol>
<li><p><strong>信息安全基础（2周）</strong></p>
<ul>
<li><strong>密码学</strong>：AES&#x2F;RSA算法原理，使用Python实现加密解密。</li>
<li><strong>漏洞类型</strong>：缓冲区溢出、Shellcode注入原理，用C编写漏洞示例程序。</li>
<li><strong>网络攻防</strong>：分析ARP欺骗案例，用Scapy模拟数据包伪造。</li>
</ul>
</li>
<li><p><strong>恶意软件分析入门（4周）</strong></p>
<ul>
<li><strong>静态分析</strong>：<ul>
<li>使用PEiD分析样本的编译器和加壳情况。</li>
<li>用Ghidra反编译样本，识别关键函数（如<code>CreateProcess</code>、注册表操作）。</li>
</ul>
</li>
<li><strong>动态分析</strong>：<ul>
<li>在虚拟机中运行样本，用Process Monitor监控文件&#x2F;注册表行为。</li>
<li>使用x64dbg调试样本，跟踪API调用链（如<code>LoadLibrary</code>、<code>GetProcAddress</code>）。</li>
</ul>
</li>
<li><strong>工具进阶</strong>：<ul>
<li>编写Python脚本自动化提取样本字符串特征。</li>
<li>配置Cuckoo沙箱分析样本的恶意行为报告。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🔍-第三阶段：逆向工程与实战进阶（第5-6个月）"><a href="#🔍-第三阶段：逆向工程与实战进阶（第5-6个月）" class="headerlink" title="🔍 第三阶段：逆向工程与实战进阶（第5-6个月）"></a><strong>🔍 第三阶段：逆向工程与实战进阶（第5-6个月）</strong></h3><p><strong>目标</strong>：掌握逆向工程核心技能，完成真实样本分析。</p>
<ol>
<li><p><strong>逆向工程深化（3周）</strong></p>
<ul>
<li><strong>汇编语言</strong>：学习x86&#x2F;x64指令集，用IDA Pro分析样本的反汇编代码。</li>
<li><strong>反混淆技术</strong>：<ul>
<li>手动脱UPX壳（使用OllyDbg的单步跟踪法）。</li>
<li>分析字符串加密逻辑，编写Python解密脚本。</li>
</ul>
</li>
<li><strong>高级调试</strong>：<ul>
<li>使用IDA Pro的远程调试功能分析Linux恶意软件。</li>
<li>通过修改寄存器值绕过反调试检测。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实战项目（3周）</strong></p>
<ul>
<li><strong>样本分析</strong>：<ol>
<li>分析勒索软件（如HelloKitty）的加密流程和密钥生成逻辑。</li>
<li>逆向远控木马（如Poison Ivy）的C2通信协议。</li>
</ol>
</li>
<li><strong>报告撰写</strong>：<ul>
<li>按照MITRE ATT&amp;CK框架标注样本的攻击技术（如T1055进程注入）。</li>
<li>使用YARA编写规则检测同类样本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>知识整合（1周）</strong></p>
<ul>
<li>复现CTF逆向题目（如<a href="https://flare-on.com/">flare-on</a>历年赛题）。</li>
<li>参与漏洞平台众测（如HackerOne的简单任务）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="📦-资源推荐"><a href="#📦-资源推荐" class="headerlink" title="📦 资源推荐"></a><strong>📦 资源推荐</strong></h3><ul>
<li><strong>书籍</strong>：《逆向工程核心原理》《加密与解密》</li>
<li><strong>靶场</strong>：<a href="https://any.run/">Any.Run</a>（交互式沙箱）、<a href="https://malwaretrafficanalysis.net/">MalwareTrafficAnalysis</a>（带流量分析的样本）</li>
<li><strong>样本来源</strong>：VirusTotal（需谨慎）、<a href="https://github.com/ytisf/theZoo">Zoo</a>（GitHub合法样本库）</li>
</ul>
<hr>
<h3 id="⚠️-关键注意事项"><a href="#⚠️-关键注意事项" class="headerlink" title="⚠️ 关键注意事项"></a><strong>⚠️ 关键注意事项</strong></h3><ol>
<li><strong>实验安全</strong>：所有分析必须在隔离的虚拟机中进行，禁用共享文件夹和剪贴板。</li>
<li><strong>法律合规</strong>：仅分析开源样本或明确授权的数据，避免触碰灰色地带。</li>
<li><strong>效率技巧</strong>：使用Jupyter Notebook记录分析过程，搭配截图和代码片段提升复盘效率。</li>
</ol>
<hr>
<p><strong>调整建议</strong>：如果遇到瓶颈（如逆向工程难以突破），可暂时跳过深入理论，通过分析简单样本（如VBS脚本病毒）建立信心。坚持每天记录学习日志，重点标注未理解的概念，每周集中解决。遇到工具使用问题，优先查阅官方文档和GitHub Issue。</p>
<p>针对<strong>第一阶段（计算机基础与编程入门）</strong>的详细学习平台和资源推荐，兼顾零基础学习者的理解能力和实践需求：</p>
<hr>
<h3 id="💻-计算机基础学习平台"><a href="#💻-计算机基础学习平台" class="headerlink" title="💻 计算机基础学习平台"></a><strong>💻 计算机基础学习平台</strong></h3><h4 id="1-操作系统与Linux入门"><a href="#1-操作系统与Linux入门" class="headerlink" title="1. 操作系统与Linux入门"></a><strong>1. 操作系统与Linux入门</strong></h4><table>
<thead>
<tr>
<th>平台&#x2F;资源</th>
<th>特点</th>
<th>推荐内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://learn.microsoft.com/zh-cn/windows/">微软官方文档</a></strong></td>
<td>权威的Windows操作指南</td>
<td>Windows文件管理、进程管理、CMD&#x2F;PowerShell基础命令</td>
</tr>
<tr>
<td><strong><a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程 - Linux</a></strong></td>
<td>中文零基础教程</td>
<td>Linux常用命令（<code>ls</code>&#x2F;<code>cd</code>&#x2F;<code>grep</code>&#x2F;<code>chmod</code>）</td>
</tr>
<tr>
<td><strong><a href="https://www.youtube.com/c/NetworkChuck">YouTube: NetworkChuck</a></strong></td>
<td>趣味实操演示</td>
<td>“Linux for Hackers”系列（搭配虚拟机操作）</td>
</tr>
</tbody></table>
<h4 id="2-网络基础"><a href="#2-网络基础" class="headerlink" title="2. 网络基础"></a><strong>2. 网络基础</strong></h4><table>
<thead>
<tr>
<th>平台&#x2F;资源</th>
<th>特点</th>
<th>推荐内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://www.coursera.org/">Coursera - 计算机网络基础</a></strong></td>
<td>体系化理论教学</td>
<td>密歇根大学《计算机网络导论》（中文字幕）</td>
</tr>
<tr>
<td><strong><a href="https://www.wireshark.org/docs/">Wireshark官方教程</a></strong></td>
<td>实战导向</td>
<td>抓包分析HTTP&#x2F;TCP协议（配合<a href="https://wiki.wireshark.org/SampleCaptures">SampleCaptures</a>）</td>
</tr>
<tr>
<td><strong><a href="https://www.bilibili.com/">B站：湖科大王道计算机网络</a></strong></td>
<td>中文系统讲解</td>
<td>考研向课程，但适合打基础</td>
</tr>
</tbody></table>
<hr>
<h3 id="👨💻-编程入门平台"><a href="#👨💻-编程入门平台" class="headerlink" title="👨💻 编程入门平台"></a><strong>👨💻 编程入门平台</strong></h3><h4 id="1-Python学习"><a href="#1-Python学习" class="headerlink" title="1. Python学习"></a><strong>1. Python学习</strong></h4><table>
<thead>
<tr>
<th>平台&#x2F;资源</th>
<th>特点</th>
<th>推荐内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://www.codecademy.com/learn/learn-python-3">Codecademy</a></strong></td>
<td>交互式编程</td>
<td>免费版Python 3语法和文件操作</td>
</tr>
<tr>
<td><strong><a href="https://docs.python.org/zh-cn/3/tutorial/">Python官网教程</a></strong></td>
<td>权威文档</td>
<td>正则表达式（<code>re</code>模块）、网络请求（<code>requests</code>库）</td>
</tr>
<tr>
<td><strong><a href="https://www.bilibili.com/">B站：小甲鱼零基础学Python</a></strong></td>
<td>中文趣味教学</td>
<td>配套《零基础入门学习Python》书籍</td>
</tr>
</tbody></table>
<h4 id="2-C语言学习"><a href="#2-C语言学习" class="headerlink" title="2. C语言学习"></a><strong>2. C语言学习</strong></h4><table>
<thead>
<tr>
<th>平台&#x2F;资源</th>
<th>特点</th>
<th>推荐内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong><a href="https://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程 - C语言</a></strong></td>
<td>简洁中文教程</td>
<td>指针、结构体、内存管理专题</td>
</tr>
<tr>
<td><strong><a href="https://www.learn-c.org/">Learn-C.org</a></strong></td>
<td>在线编译器</td>
<td>实时练习指针和内存操作代码</td>
</tr>
<tr>
<td><strong><a href="https://www.bilibili.com/">B站：浙江大学翁恺C语言</a></strong></td>
<td>高校精品课</td>
<td>深入理解指针与内存模型</td>
</tr>
</tbody></table>
<hr>
<h3 id="🔧-工具准备资源"><a href="#🔧-工具准备资源" class="headerlink" title="🔧 工具准备资源"></a><strong>🔧 工具准备资源</strong></h3><table>
<thead>
<tr>
<th>工具</th>
<th>学习资源</th>
<th>重点内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>虚拟机（VMware&#x2F;VirtualBox）</strong></td>
<td><a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/index.html">VMware官方指南</a></td>
<td>创建隔离的Windows&#x2F;Linux实验环境</td>
</tr>
<tr>
<td><strong>IDA Pro Free</strong></td>
<td><a href="https://hex-rays.com/ida-free/">官方快速入门</a></td>
<td>基本反汇编操作（函数识别、交叉引用）</td>
</tr>
<tr>
<td><strong>Process Monitor</strong></td>
<td><a href="https://search.bilibili.com/all?keyword=Process%20Monitor">B站实操演示</a></td>
<td>监控恶意软件的文件&#x2F;注册表行为</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <tags>
        <tag>信息安全</tag>
        <tag>恶意软件分析</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware虚拟机</title>
    <url>/2025/02/20/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="📚专业术语"><a href="#📚专业术语" class="headerlink" title="📚专业术语"></a>📚专业术语</h2><p>.iso：是电脑上光盘镜像（CD Mirror）的存储格式之一，因为其是i根据ISO-9660有关CD-ROM文件系统标准存储的文件，许哦一通常在电脑中以后缀,iso命名，俗称iso镜像文件。</p>
<p>镜像文件：镜像文件可以类比为图书馆的一本书的副本。一本珍贵的书，想要确保即使在原书损坏或丢失的情况下，书的内容仍然可以得到保留和使用。为此，制作了这本书的精确复制品，这个复制品包含了原书的所有页面和文字，但它可能是以特殊的格式存储的，比如扫描后的PDF文件或者一系列图片。</p>
<h2 id="🖥创建新的虚拟机"><a href="#🖥创建新的虚拟机" class="headerlink" title="🖥创建新的虚拟机"></a>🖥创建新的虚拟机</h2><h3 id="1-Window系统"><a href="#1-Window系统" class="headerlink" title="1.Window系统"></a>1.Window系统</h3><p>点击软件首页的创建新的虚拟机，进入新建导向</p>
<p>选择自定义（高级）然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206165405761.png"></p>
<p>硬件兼容性选择软件版本，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182831247.png"></p>
<p>选择安装程序光盘映像文件（iso），选择安装好的光盘映像文件，可以去微软官网上去下载，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182926495.png"></p>
<p>完成windows简易安装信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182950623.png"></p>
<p>对新建的虚拟机进行命名，名字注意区分其他并易懂，还有保存位置，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183009197.png"></p>
<p>选择虚拟机的固件类型，即引导设备，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183034037.png"></p>
<p>选择虚拟机处理器配置，处理器数量、每个处理器的内核数量，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183051953.png"></p>
<p>设置虚拟机的内存，不要太大也不要太小，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183110891.png"></p>
<p>选择网络模式，使用网络地址转换（NAT），然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183132574.png"></p>
<p>选择I&#x2F;O控制器类型，按照新建向导的推荐选择，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183147255.png"></p>
<p>选择磁盘类型，按照新建向导的推荐选择，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122431324.png"></p>
<p>选择磁盘容量，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122452975.png"></p>
<p>确定号新建的虚拟机的设置信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122514411.png"></p>
<p>至此，Windows10虚拟机创建成功，等待启动然后设置，激活系统。</p>
<h3 id="2-Linux系统"><a href="#2-Linux系统" class="headerlink" title="2.Linux系统"></a><strong>2.Linux系统</strong></h3><p>点击软件首页的创建新的虚拟机，进入新建导向</p>
<p>选择自定义（高级）然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206163543615.png"></p>
<p>保持默认不变，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206163649773.png"></p>
<p>选择稍后安装操作系统，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164001987.png"></p>
<p>在选择客户机i操作系统时选择Linux系统，版本选择自己准备的ISO文件的版本，一定要匹配，然后单击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164041840.png"></p>
<p>给本虚拟机命名，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164349880.png"></p>
<p>处理器配置，为虚拟机指定处理器数量，设置为2，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164527143.png"></p>
<p>设置内存，一般两个G，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164616967.png"></p>
<p>后续一直保持默认推荐，然后点击下一步</p>
<p>确认新建虚拟机的基本信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206165452662.png"></p>
<p>至此虚拟机的创建已完成，然后检查一下网络配置</p>
<p>点击编辑&gt;虚拟网络编辑器，查看VMnet8，子网的ip地址是否和NAT设置中的ip地址前三位一致。正常来说是默认配置好的。只是检查以下，不是乱去设置。</p>
<p>接下来去给<strong>虚拟机配置镜像</strong>。</p>
<p>点击编辑虚拟机设置&gt;CD&#x2F;DVD&gt;选择使用镜像文件，点击浏览找到提前下载好的镜像文件，然后点确定，完成后点击开启虚拟机。</p>
<p>然后点击install CentOS，选项变白就是选中了</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206170409114.png"></p>
<p>然后选中想要的语言，选择简体中文就行,点击继续</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206170558494.png"></p>
<p>进入安装信息摘要基本不用改，完成以下安装位置确认，然后点击安装。设置Root密码。创建用户根据个人需要，就是权限比较低的用户。</p>
<p>至此安装成功，点击重启就行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171032438.png"></p>
<p>注意进入后输入用户和密码，密码是不会显示的，输完后回车就行，出现root@localhost就是成功了。</p>
<p>输入cd &#x2F;，再输入ll，查看所有文件。(注意cd 后面要有一个空格)</p>
<p>接下来配置虚拟机的网络。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-06%20171537.jpg"></p>
<p>手动输入，以下路径，虚拟机内无法复制粘贴</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171841943.png"></p>
<p>然后找到ifcfg-ens33，打开它编辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171953000.png" alt="image-20250206171953000"></p>
<p>使用vi ifcfg-ens33，进入修改。按i，进入修改模式，将BOOTPROTO&#x3D;dhcp（默认），ONBOOT修改为yes。然后按esc退出修改模式。输入:wq，回车强制保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206172438904.png"></p>
<p>接下来就是去重启网络，service network restart，然后测试是否能访问外网，ping一下百度，出现连接网速表示成功，ctrl+c结束。</p>
<p>后续参考视频【【2024最新】Vmware虚拟机安装Linux系统及配置网络超详细教学安装Centos使用Vmare安装附带安装包及镜像】<a href="https://www.bilibili.com/video/BV1MriFeaEci?vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc">https://www.bilibili.com/video/BV1MriFeaEci?vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc</a></p>
<h2 id="📺操作系统的操作模式"><a href="#📺操作系统的操作模式" class="headerlink" title="📺操作系统的操作模式"></a>📺操作系统的操作模式</h2><p>对操作系统的使用，有2种使用形式：</p>
<ul>
<li><p>图形化页面使用操作系统</p>
</li>
<li><p>以命令的形式使用操作系统</p>
</li>
</ul>
<p>不论是Windows系统还是Linux系统或是MacOS系统，以获得图形化反馈的形式去使用操作系统。</p>
<ul>
<li><p>图形化：使用操作系统提供的图形化页面，以获得图形化反馈形式去使用操作系统。</p>
</li>
<li><p>命令行：使用操作系统提供的各类命令，以获得字符反馈的形式去使用操作系统。</p>
</li>
</ul>
<p>无论是企业开发亦或是个人开发，使用Linux擦欧总系统，多数都是使用的：命令行。</p>
<p>这是因为：</p>
<ul>
<li>Linux从诞生至今，在图形化页面的优化上，并未重点发力。所以LInux操作系统的图形化页面：不好用、不稳定。</li>
<li>在开发中，使用命令行形式，效率更高，更加直观，并且资源占用低、程序运行更稳定。</li>
</ul>
<h2 id="💻网络连接的三种模式"><a href="#💻网络连接的三种模式" class="headerlink" title="💻网络连接的三种模式"></a>💻网络连接的三种模式</h2><h3 id="1-桥接模式：直接连接物理网络"><a href="#1-桥接模式：直接连接物理网络" class="headerlink" title="1.桥接模式：直接连接物理网络"></a>1.桥接模式：直接连接物理网络</h3><p>使用主机中的物理网卡VMnet0，有线网卡或者无线网卡，可以连接主机，并且可以访问局域内的计算机，如果主机可以连接外网，虚拟机也可以连接外网，此时物理主机相当于一个交换机，把所有桥接模式的虚拟机都连接在同一个交换机上，自己在这个局域网中。注意：容易造成IP冲突。</p>
<h3 id="2-NAT模式：用于共享主机的IP地址"><a href="#2-NAT模式：用于共享主机的IP地址" class="headerlink" title="2.NAT模式：用于共享主机的IP地址"></a>2.NAT模式：用于共享主机的IP地址</h3><p>使用的是虚拟机的网卡VMnet8，可以连接主机，也可以来连接外网，虚拟机IP地址经过NAT转换，与物理机IP地址不在同一网段，所以不能访问局域网内的计算机。</p>
<h3 id="3-仅主机模式：与主机共享的专用网络"><a href="#3-仅主机模式：与主机共享的专用网络" class="headerlink" title="3.仅主机模式：与主机共享的专用网络"></a>3.仅主机模式：与主机共享的专用网络</h3><p>使用的是虚拟机中的VMnet1，可以连接到主机，不能访问局域网内的计算机，也不能连接外网，当我们要组成一个与物理网络相隔离的虚拟网络时可以选择仅主机模式。</p>
<h2 id="📼虚拟机克隆"><a href="#📼虚拟机克隆" class="headerlink" title="📼虚拟机克隆"></a>📼虚拟机克隆</h2><p>如果已经安装了一台linux操作系统，还想再更多的，没必要再重新安装，只需要克隆就行。</p>
<h3 id="1-直接拷贝一份安装好的虚拟机文件"><a href="#1-直接拷贝一份安装好的虚拟机文件" class="headerlink" title="1.直接拷贝一份安装好的虚拟机文件"></a>1.直接拷贝一份安装好的虚拟机文件</h3><p>将虚拟机文件拷贝到另一个盘的文件夹下，文件名可以重命名，也可以保留原名。通过VMware的打开文件，打开拷贝虚拟机文件。</p>
<h3 id="2-使用VMware的克隆操作"><a href="#2-使用VMware的克隆操作" class="headerlink" title="2.使用VMware的克隆操作"></a>2.使用VMware的克隆操作</h3><p>注意：克隆时，需要先关闭正在运行的linux系统。</p>
<p>虚拟机&gt;右键至管理&gt;克隆</p>
<p>克隆类型有两种：创建链接克隆、创建完整克隆。</p>
<p>创建链接克隆，是对原虚拟机的引用，所需要的存储磁盘空间较少，访问的是原虚拟机，是同一个系统。</p>
<p>创建完整克隆：是原虚拟机当前状态的完整副本，此选项使得虚拟机完全独立，需要较多的存储磁盘空间。</p>
<h2 id="📷虚拟机快照"><a href="#📷虚拟机快照" class="headerlink" title="📷虚拟机快照"></a>📷虚拟机快照</h2><p>如果在使用虚拟机系统的时候，想回到原先的某一个状态，也就是说担心有些操作造成系统异常，需要回到原先某个正常运行的状态，VMware提供了一个这样的功能，就叫做快照管理。</p>
<p>推荐关机操作，没关机也可以就是会时间久一点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250210163939993.png"></p>
]]></content>
      <tags>
        <tag>VMware</tag>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghidra的安装</title>
    <url>/2025/02/06/Ghidra%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Typora的使用</title>
    <url>/2025/01/24/Typora%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[史上最全Typora教程—-程序员必学软件之一-CSDN博客](<a href="https://blog.csdn.net/m0_62648611/article/details/133713273#:~:text=%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Typora%E6%95%99%E7%A8%8B----%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B9%8B%E4%B8%80">https://blog.csdn.net/m0_62648611/article/details/133713273#:~:text=史上最全Typora教程----程序员必学软件之一</a> 1 1. 标题 一级标题：Ctrl%2B1 或%23 二级标题：Ctrl%2B2 或%23%23,代码 插入不确定编程语言代码，快捷键：CTRL%2Bshift%2Bk 插入确定语言代码， &#96;&#96;&#96; 语言名称 如： … 更多项目)</p>
<p>存在待补充</p>
<h2 id="Typora是什么？"><a href="#Typora是什么？" class="headerlink" title="Typora是什么？"></a>Typora是什么？</h2><p>​		Typora是一款由Abner Lee开发的轻量级Markdown编辑器，适用于OS X、Windows和Linux三种操作系统，是一款免费软件。与其他Markdown编辑器不同的是，Typora没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式</p>
<span id="more"></span>


<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a><strong>1.标题</strong></h4><p>快捷键，Ctrl+数字（1、2、3、4、5、6），一共六个数字由大到小六个标题等级。</p>
<h4 id="2-文本"><a href="#2-文本" class="headerlink" title="2.文本"></a><strong>2.文本</strong></h4><h6 id="2-1-分割线"><a href="#2-1-分割线" class="headerlink" title="2.1 分割线"></a>2.1 分割线</h6><p>三个+++、***、或—，如下：</p>
<hr>
<h6 id="2-2-下划线"><a href="#2-2-下划线" class="headerlink" title="2.2 下划线"></a>2.2 下划线</h6><p>Ctrl+U或&lt; u &gt;标签包住文本，如：<u>kedai</u></p>
<h6 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h6><p>Alt+Shift+5或使用一对 “ ~ “符号包括文本，如：<del>kedai</del></p>
<h6 id="2-4-斜体"><a href="#2-4-斜体" class="headerlink" title="2.4 斜体"></a>2.4 斜体</h6><p>Ctrl+l、或使用一对 “ _ “符号包括文本，如：<em>kedai</em></p>
<h6 id="2-5-粗体"><a href="#2-5-粗体" class="headerlink" title="2.5 粗体"></a>2.5 粗体</h6><p>Ctrl+B、使用一对 “ ** “符号包括文本、或使用一对 “ __ “符号包括文本，如：<strong>kedai</strong></p>
<h6 id="2-6-粗体倾斜"><a href="#2-6-粗体倾斜" class="headerlink" title="2.6 粗体倾斜"></a>2.6 粗体倾斜</h6><p>使用一对三个“ * ” 符号包括文本，如：<em><strong>kedai</strong></em></p>
<h6 id="2-7-设置字体颜色及大小"><a href="#2-7-设置字体颜色及大小" class="headerlink" title="2.7 设置字体颜色及大小"></a>2.7 设置字体颜色及大小</h6><p>&lt; font size&#x3D;2 color&#x3D;”yellow” &gt;设置字体大小为2，颜色为黄色&lt; &#x2F;font  &gt; ，如：<font size=2 color="yellow">kedai</font> </p>
<h6 id="2-8-设置字体高亮"><a href="#2-8-设置字体高亮" class="headerlink" title="2.8 设置字体高亮"></a>2.8 设置字体高亮</h6><p>使用一对“ &#x3D;&#x3D; ”符号包括文本，如：&#x3D;&#x3D;kedai&#x3D;&#x3D;</p>
<h6 id="2-9-文本对齐"><a href="#2-9-文本对齐" class="headerlink" title="2.9 文本对齐"></a>2.9 文本对齐</h6><p>&lt; p align&#x3D;”lift” &gt;左对齐&lt; &#x2F;p &gt;</p>
<p align="lift">左对齐</p>

<p>&lt; p align&#x3D;”center” &gt;居中对齐&lt; &#x2F;p &gt;</p>
<p align="center" >居中对齐</p >

<p>&lt; p align&#x3D;”right” &gt;左对齐&lt; &#x2F;p &gt;</p>
<p align="right" >右对齐</p >

<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a><strong>3.插入</strong></h4><h6 id="3-1链接文字"><a href="#3-1链接文字" class="headerlink" title="3.1链接文字"></a>3.1链接文字</h6><p>① 当链接地址为外部地址时，格式：[ 链接文字 ] (src“描述链接”) ，其中的描述可以写也可以不写。快捷键为Ctrl+K，用Ctrl+鼠标左键点击进入链接。如：<a href="https://taobao.com/">这是一个淘宝链接</a></p>
<p>② 当链接地址为本地地址时，其中本地地址可以是相对地址和绝对地址</p>
<ul>
<li><p>绝对地址 格式：[ 绝对地址 ] (src “本地地址链接”)，用Ctrl+鼠标左键点击进入链接，上传远程后是没有效果的。</p>
</li>
<li><p>相对地址 格式：[ 相对地址\ ] ( src “&#x2F;标题.png”)，其中.&#x2F;代表.md文件所在的地址…&#x2F;表示的是.md文件的上级地址。</p>
</li>
</ul>
<h6 id="3-2图片"><a href="#3-2图片" class="headerlink" title="3.2图片"></a>3.2图片</h6><p>一共有四种方式</p>
<p>①外部链接 </p>
<p>格式：！[ alt ] (src)，快捷键：Ctrl+Shift+l</p>
<p>和链接文件、文档差不多，指示在前面加了一个！。alt：是图片的注释（可以为空），src：既可以是本地图片的绝对&#x2F;相对路径。</p>
<p>②html标签 </p>
<p>格式：&lt; img src&#x3D;”.&#x2F;图片演示.png” alt&#x3D;”替代文本” title&#x3D;”图片标题” width&#x3D;”200” height&#x3D;”200” &gt;</p>
<p>width和height设置大小，align设置位置，style中margin设置外边距、border设置边框</p>
<p>③本地文件 </p>
<p>格式：！[ alt ] (src)</p>
<p>直接拖拽、复制就行，也可以进行图片链接。拖拽和复制本质上和第一种图片链接是一样的。但是Typora默认的是绝对地址，图片没有复制到.md文件同一目录下。如果移动了.md文件或者图片位置，都会丢失图片。</p>
<p>④ TYpora支持从剪贴板中粘贴图片，但是因为 Markdown 文件是纯文本文件，所以用户无法在 Markdown 文件中直接插入图片文件，而是通过在 Markdown 文件中引用文件路径或者 URL 的方式插入图片，所以默认情况下，Typora 会先将文件保存到一个固定的目录，在 Windows 上，是保存到~\AppData\Roaming\Typora\typora-user-images\目录下。</p>
<p>所以需要修改设置（文件 &gt; 偏好设置 &gt; 图像 &gt; 对本地位置的图片应用上述规则 &gt; 下拉勾选其中一个）</p>
<p>第一个选项 [无特殊操作]，是默认选项。</p>
<p>第二个选项 [复制图片到当前文件夹（.&#x2F;）]，意思就是在插入图片时，将图片复制到正在编辑的Markdown文件所在的目录下。</p>
<p>第三个选项 [复制图片到.&#x2F;filename.assets文件夹]，意思是在插入图片时，会在当前目录下创建一个名为“{filename.asset}”的文件夹，然后把图片保存在这个文件夹下，其中${filename}&#96;指的是当前你正在编辑的Markdown文件的文件名。</p>
<p>第四个选项 [上传图片]，就是在你插入图片时，使用图片上传服务将图片上传到服务器。</p>
<p>第五个选项 [复制到指定路径]，选择该选项后，会出现一个输入框输入保存图片的路径，这里也就是使用${filrname}来指代当前编辑的Markdowan文件的文件名，也可以点击右边的文件夹按钮在弹出的对话框中选择一个路径。</p>
<p>因为如果在 Markdown 文件中使用了图片，那说明这张图片和写的东西是有关联的，那最好把图片和 Markdown 文件放在一起，这样也便于以后查找。还要注意的是，如果选择了[复制图片到当前文件夹（.&#x2F;）]，那么要把下面的[优先使用相对路径]选项勾选上，这样，Typora 在引用图片时就会使用相对路径，以后即使移动 Markdown 文件到别的目录下，只要图片随着 Markdown 文件一起移动， Typora 就永远都能找到这张图片。再配合[上传图片]，就能使 Markdown 文件的维护成本最小化。</p>
<h6 id="3-3表格"><a href="#3-3表格" class="headerlink" title="3.3表格"></a>3.3表格</h6><p>插入表格可以使用代码的方式插入，但是感觉太麻烦了。采用快捷键Ctrl+T</p>
<h4 id="4-上传图片-详细说明"><a href="#4-上传图片-详细说明" class="headerlink" title="4.[上传图片] 详细说明"></a><strong>4.[上传图片] 详细说明</strong></h4><p>如果src是 URL 的话，你在分享的时候只要分享一个 Markdown 文件就可以了，只要能联网，Markdown 的渲染引擎就能根据 URL 找到你引用的图片。</p>
<p>要想把本地的图片路径转换成 URL，就得把图片上传到网络上某个位置，然后拿到这个图片的 URL。使用[Typora + 第三方图片上传服务]就可以自动完成这一操作。</p>
<p><strong>⚠警告：</strong></p>
<p><u><em>Typora是通过调用第三方的软件实现图片上传的，它本身并不会上传图片，提供存储图片服务的也是第三方的云存储服务，它们并不属于Typora。所以在使用上传图片功能的时候，要注意这些第三方服务的许可证书、用户协议、服务稳定性以及可靠性。</em></u></p>
<p><u><em>在偏好设置中开启上传图片的功能后，Typora 会将要上传的图片发送给第三方图片上传软件，然后他们会把你的图片上传到第三方（甚至是第四方）图床，Typora 不会控制这个过程，也无法保证这个过程的顺利，所以一定要选择一个可靠的服务来保证数据的安全。</em></u></p>
<p><u><em>除了隐私和可靠性问题，你还需注意，有些服务在保存图片时可能会设置过期时间；有些服务没有提供 [删除] 的功能，即使你不小心上传了敏感图片；有些服务遵守的不是你所在国家的法律，可能会封禁一些特定国家的特定类型的图片或者用户等等。</em></u></p>
<p><u><em>总而言之，在选择某个图片上传应用及服务之前，一定要仔细阅读他们的用户手册。</em></u></p>
<p>配置：</p>
<p>在偏好设置面板中可以开启并配置图片上传服务，Typora支持以下图片上传服务：</p>
<ul>
<li>PicGo.app (macOS &#x2F; Windows &#x2F; Linux, 只有简体中文版)</li>
<li>PicGo (命令行应用) (Windows &#x2F; Linux)</li>
<li>自定义 (macOS &#x2F; Windows &#x2F; Linux)</li>
</ul>
<p>在选择了其中一个上传服务后，你需要下载并安装相应的应用，做一些简单的配置，比如你想使用那个云存储服务来保存上传的图片，然后点击 [验证图片上传选项]，验证Typora使用当前服务和配置是否能上传本地图片。</p>
<p>点击 [验证图片上传选项] 按钮后，Typora会尝试使用当前服务和配置上传图片，如果出现 [验证成功] 的对话框，说明图片上传服务可以用了。如果显示的时 [验证失败] 的对话框，有可能时你电脑上还没有安装相应的服务或者网络问题，可以根据对话框中的提示进行检查。</p>
<p><strong><u>Typora + PicGo + Gitee&#x2F;GitHub 搭建个人图床，实现图片上传。</u></strong></p>
<p>Typora 的作用</p>
<p>具有对图片路径进行管理和转换的功能。当用户在 Typora 中插入图片时，它可以将图片的本地路径转换为符合 Markdown 语法的链接形式。而且 Typora 可以与 PicGo 进行集成，将图片上传的操作集成到其操作流程中，使得用户在撰写文档插入图片时，能够直接调用 PicGo 进行图片上传，而无需额外切换到其他工具进行上传操作。</p>
<p>PicGo 的作用</p>
<p>PicGo 是一个专门用于图片上传的工具，它支持多种图床平台，其核心原理是通过调用不同图床平台的 API，将本地图片数据以二进制流等形式发送到对应的图床服务器上。_在与 Typora 和 Gitee&#x2F;GitHub 配合时，PicGo 充当了桥梁的角色。_当在 Typora 中触发图片上传操作时，PicGo 会获取到图片的本地路径和相关信息，然后根据用户在 PicGo 中配置的 Gitee 或 GitHub 图床参数，将图片数据按照相应平台的要求进行格式化和封装，再通过 HTTP 请求等方式将图片上传到 Gitee 或 GitHub 的仓库中。上传成功后，PicGo 会获取到图片在 Gitee 或 GitHub 上的访问链接，并将这个链接返回给 Typora，以便 Typora 将其插入到 Markdown 文档中，实现图片的引用。</p>
<p>Gitee&#x2F;GitHub 的作用</p>
<p>GitHub 本质上是代码托管平台，但它们也可以用于存储图片等静态资源。它们提供了版本控制、仓库管理等功能，用户可以在上面创建仓库来存储各种文件。当 PicGo 将图片上传到  GitHub 仓库时，实际上是利用了这些平台的文件存储功能。这些平台会为每个上传的文件分配一个唯一的存储位置，并生成一个对应的访问链接。这个链接遵循平台的特定规则，通过这个链接，用户可以在互联网上访问到存储在  GitHub 仓库中的图片资源。同时， GitHub 都有一定的免费存储空间和流量额度，这使得用户可以在一定范围内免费使用它们来搭建个人图床，存储和分享自己的图片。</p>
<p><strong>步骤：</strong></p>
<h5 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a><strong>配置GitHub</strong></h5><p>创建一个新的仓库用来保存图片。</p>
<p>选择<u>Add a README file</u>。注意确保选择”<u>Public</u>“，否则之后再外部访问图床中的图片，会由于没有权限导致访问失败。</p>
<p>在个人设置中，选择“<u>Developer settings</u>”。</p>
<p>随后，选择“<u>Personal access tokens</u>”，并选择其中下方的“<u>Tokens (classic)</u>”；随后，选择右上角“<u>Generate new token</u>”，并再选择“<u>Generate new token (classic)</u>”。</p>
<p>随后，在弹出的配置界面中，首先填写“<u>Note</u>”，这个是当前token的注释，也用一个和图片有关的名称来填写即可；随后，配置token的有效期。其实我们可以将有效期选择为永久，但是<u>GitHub</u>官方强烈不推荐这种<u>永久</u>期限的token，因此可以选择 <u>90</u>天，之后过期了我们继续来设置新的有效期就好。随后，配置勾选项，我这里是将全部的勾选项都选中了，但是其实只要保证 <u>repo</u> 开头的勾选项选中即可。</p>
<p>接下来，即可看到此时token的序号已经获取了，如下图所示。这里大家一定需要<u>保存一下当前的序号</u>，之后就看不到这个序号了。</p>
<p>至此，我们就完成了GitHub上的配置操作。</p>
<h5 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a><strong>配置PicGo</strong></h5><p>将图片上传到GitHub中。下载地址：<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a></p>
<p>随后，<u>安装PicGo</u>并打开，如下图所示。其中，我们需要在“<u>图床设置</u>”中找到“<u>GitHub</u>”，并配置各项信息。其中，<u>仓库名</u>就是我们前面创建的<u>Repository的名称</u>；Token就是前面我们获取的token序号；存储路径这里我们可以空着，如果大家需要指定将图片存储到仓库中的某个路径下，就在这里设置即可；分支名由于github网站的调整，仓库的默认分支名称需要修改为<u>main</u>。随后的自定义域名，可以填写<a href="https://cdn.jsdelivr.net/gh/%E2%80%9C%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9D/%E2%80%9C%E4%BB%93%E5%BA%93%E5%90%8D%E2%80%9D@master%E3%80%82">https://cdn.jsdelivr.net/gh/“用户名”/“仓库名”@master。</a></p>
<h5 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a><strong>配置Typora</strong></h5><p>在“<u>文件</u>”中选择“<u>偏好设置…</u>”，随后选择“<u>图像</u>”，下拉选择“<u>上传图片</u>”，勾选“<u>对本地位置的图片应用上述规则</u>”、“<u>插入是自动转义图片URL</u>”。</p>
<p>随后，选择“<u>验证图片上传选项</u>”，如果出现验证成功窗口，则表明成功配置完毕。</p>
<h5 id="上传方式"><a href="#上传方式" class="headerlink" title="上传方式"></a><strong>上传方式</strong></h5><p><strong>全局设置</strong></p>
<p>在偏好设置面板中，[插入图片时…] 下方的下拉框中，选择 [上传图片] 选项，Typora就会在你插入图片时自动上传。如果只想上传本地图片，那么就只勾选 [对本地位置的图片应用上述规则] ，如果插入的图片本来就位于网络上，但是你想再上传一遍图床，那就把 [对网络位置的图片应用上述规则] 也勾选上。</p>
<p><strong>针对每一个文件单独设置</strong></p>
<p>手下需要勾选上偏好设置面板中的 [允许根据YAML设置自动上传图片] ，然后，如果你的Markdown文件再TYAML中包含如下配置：</p>
<p><code>typora-copy-image-to: upload</code></p>
<p>当插入图片时，Typora会使用这个选项自动上传图片。</p>
<p>或者可以在菜单栏中点击 格式 &gt; 图像 &gt; 当插入本地图片时…  插入YAML配置，开启这个功能。</p>
<p><strong>上传指定的图片</strong></p>
<p>可以在Typora中，右击点击要上传的图片，选择 [上传图片] 。</p>
<p><strong>上传所有本地图片</strong></p>
<p>如果文件中含有大量的本地图片，想要一次性都上传，可以点击菜单栏中的 格式 &gt; 图像 &gt; 上传所有本地图片 。</p>
<h4 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5.快捷键"></a><strong>5.快捷键</strong></h4><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>新建一个新的窗口</td>
<td>Ctrl+N</td>
</tr>
<tr>
<td>创建一个新的窗口</td>
<td>Ctrl+Shift+N</td>
</tr>
<tr>
<td>打开资源管理器（初始在.md文件）</td>
<td>Ctrl+O</td>
</tr>
<tr>
<td>快速打开近期使用过的Markdown文件搜索框</td>
<td>Ctrl+P</td>
</tr>
<tr>
<td>保存</td>
<td>Ctrl+S</td>
</tr>
<tr>
<td>保存为（另存为）</td>
<td>Ctrl+Shift+S</td>
</tr>
<tr>
<td>打开偏好设置界面</td>
<td>Ctrl+,</td>
</tr>
<tr>
<td>关闭当前窗口</td>
<td>Ctrl+W</td>
</tr>
<tr>
<td>开始一个新段落</td>
<td>Enter</td>
</tr>
<tr>
<td>开始一个新行</td>
<td>Shift+Enter</td>
</tr>
<tr>
<td>复制选中的文本为Markdown语言</td>
<td>Ctrl+Shift+C</td>
</tr>
<tr>
<td>将复制的内容以纯文本的格式粘贴</td>
<td>Ctrl+Shift+V</td>
</tr>
<tr>
<td>在段落内选中一句\在表内选中一行</td>
<td>Ctrl+L</td>
</tr>
<tr>
<td>删除表中的一行</td>
<td>Ctrl+Shift+Backspace</td>
</tr>
<tr>
<td>选中一个段元格</td>
<td>Ctrl+E</td>
</tr>
<tr>
<td>选择一个单元格</td>
<td>Ctrl+D</td>
</tr>
<tr>
<td>跳转到文章最顶部</td>
<td>Ctrl+Home</td>
</tr>
<tr>
<td>跳转到文章底部</td>
<td>Ctrl+End</td>
</tr>
<tr>
<td>跳转到光标所在位置</td>
<td>Ctrl+J</td>
</tr>
<tr>
<td>删除一个单词</td>
<td>Ctrl+Shift+D</td>
</tr>
<tr>
<td>查找</td>
<td>Ctrl+F</td>
</tr>
<tr>
<td>查找已经查找的的上一个单词</td>
<td>Shift+F3\Shift+Enter</td>
</tr>
<tr>
<td>查找当前查找的的下一个单词</td>
<td>F3\Enter</td>
</tr>
<tr>
<td>替换</td>
<td>Ctrl+H</td>
</tr>
<tr>
<td>设置文本为标题1-6</td>
<td>Ctrl+ 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td>
</tr>
<tr>
<td>设置文本为段落</td>
<td>Ctrl+0</td>
</tr>
<tr>
<td>给标题升1级</td>
<td>Ctrl+&#x3D;</td>
</tr>
<tr>
<td>给标题降1级</td>
<td>Ctrl±</td>
</tr>
<tr>
<td>插入表</td>
<td>Ctrl+T</td>
</tr>
<tr>
<td>插入代码块</td>
<td>Ctrl+Shift+k</td>
</tr>
<tr>
<td>插入数学符号的文本</td>
<td>Ctrl+Shift+M</td>
</tr>
<tr>
<td>插入引用代码</td>
<td>Ctrl+Shift+Q</td>
</tr>
<tr>
<td>插入有序列表</td>
<td>Ctrl+Shift+[</td>
</tr>
<tr>
<td>插入无序列表</td>
<td>Ctrl+Shift+]</td>
</tr>
<tr>
<td>缩进</td>
<td>Tab \ Ctrl+[</td>
</tr>
<tr>
<td>取消缩进</td>
<td>Shift+Tab \ Ctrl+]</td>
</tr>
<tr>
<td>加粗字体</td>
<td>Ctrl+B</td>
</tr>
<tr>
<td>文本删除线</td>
<td>Alt+Shift+5</td>
</tr>
<tr>
<td>斜体</td>
<td>Ctrl+I</td>
</tr>
<tr>
<td>标记为代码</td>
<td>Ctrl+Shift+5</td>
</tr>
<tr>
<td>插入超链接</td>
<td>Ctrl+K</td>
</tr>
<tr>
<td>插入图片链接</td>
<td>Ctrl+Shift+I</td>
</tr>
<tr>
<td>消除文本格式</td>
<td>Ctrl+\</td>
</tr>
<tr>
<td>切换侧边栏</td>
<td>Ctrl+Shift+L</td>
</tr>
<tr>
<td>切换成出大纲</td>
<td>Ctrl+Shift+1</td>
</tr>
<tr>
<td>切换到文件栏</td>
<td>Ctrl+Shift+2</td>
</tr>
<tr>
<td>展示文件目录</td>
<td>Ctrl+Shift+3</td>
</tr>
<tr>
<td>切换成源码格式（Markdown）</td>
<td>Ctrl+&#x2F;</td>
</tr>
<tr>
<td>专注模式</td>
<td>F8</td>
</tr>
<tr>
<td>打字机模式</td>
<td>F9</td>
</tr>
<tr>
<td>全屏模式</td>
<td>F11</td>
</tr>
<tr>
<td>扩大</td>
<td>Ctrl+Shift+&#x3D;</td>
</tr>
<tr>
<td>缩小</td>
<td>Ctrl+Shift±</td>
</tr>
<tr>
<td>重置大小（好像windows有快捷键冲突）</td>
<td>Ctrl+Shift+0</td>
</tr>
<tr>
<td>在两个打开的文件进行切换</td>
<td>Ctrl+Tab</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github 部署博客</title>
    <url>/2025/01/23/hexo-github-%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>静态博客：是指没有后端数据库的博客，所有文章都是以文件的形式存储，是一种纯前端的博客框架。</p>
<hr>
<h1 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a><strong>一、准备工具</strong></h1><p>Hexo是通过Node.js生成的。</p>
<h2 id="1-下载并安装Node-js"><a href="#1-下载并安装Node-js" class="headerlink" title="1.下载并安装Node.js"></a><strong>1.下载并安装Node.js</strong></h2><p>win+R  #进入终端</p>
<p>node -v  #查看node版本，v20.18.0，显示版本号，则说明安装成功</p>
<h2 id="2-安装Hexo框架"><a href="#2-安装Hexo框架" class="headerlink" title="2.安装Hexo框架"></a><strong>2.安装Hexo框架</strong></h2><p>Node.js的包管理器，称为npm。</p>
<p>发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。</p>
<p>win+R进入终端</p>
<p>npm -v  #查看npm版本，11.0.0</p>
<p>由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。</p>
<p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>  #通过npm安装cnpm</p>
<p>cnpm -v  #查看cnpm版本</p>
<p>npm install -g hexo-cli  #安装hexo框架</p>
<p>hexo -v  #查看版本</p>
<h2 id="3-安装git工具"><a href="#3-安装git工具" class="headerlink" title="3.安装git工具"></a><strong>3.安装git工具</strong></h2><p>下载网址<a href="https://git-scm.com/downloads/win">https://git-scm.com/downloads/win</a></p>
<p>安装版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224192736510.png" alt="安装版本号"></p>
<p>配置用户名和邮箱</p>
<p>很重要，因为每一个都会使用这些信息，它们会写入道每一次提交中，不可更改。</p>
<p>签名的作用是区分操作者的身份，用户的签名信息在每一个版本的提交信息能够看到，以此确认本次提交的是谁做的。Git首次安装必须设置一下用户签名，否则无法提交代码。这里设置用户签名和将来登录GitLab（或者其他代码托管中心）的账号没有任何关系。</p>
<p>在桌面任意位置右键，点击Git bash here，在弹出界面中输入</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-24%20200214.jpg"></p>
<p>输入git config –global –list 命令，检查配置好没有</p>
<p>安装完成后，确保将 git 的可执行文件所在的目录添加到系统的环境变量中。</p>
<p>安装路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200256455.png"></p>
<p>设置环境变量</p>
<p>系统变量中Path，编辑E:\git\Git\cmd</p>
<h1 id="二、搭建仓库"><a href="#二、搭建仓库" class="headerlink" title="二、搭建仓库"></a><strong>二、搭建仓库</strong></h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a><strong>github</strong></h2><h3 id="1-搭建仓库"><a href="#1-搭建仓库" class="headerlink" title="1.搭建仓库"></a><strong>1.搭建仓库</strong></h3><p>在<a href="https://github.com/%E7%BD%91%E5%9D%80%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7">https://github.com/网址准备一个账号</a></p>
<p>新建一个仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200319395.png"></p>
<p>仓库名（Repository name）是要和github的名字一样，例如github名字叫aaa，仓库名字就必须是aaa.github.io，不能是bbb.github.io之类的。</p>
<p>Repository name ： tangxtang1119.github.io</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200335806.png"></p>
<p>勾选Public和Add a README file</p>
<p>然后点击创建Create repository</p>
<h1 id="三、配置ssh-key"><a href="#三、配置ssh-key" class="headerlink" title="三、配置ssh key"></a><strong>三、配置ssh key</strong></h1><h2 id="github-1"><a href="#github-1" class="headerlink" title="github"></a><strong>github</strong></h2><h4 id="1-生成SSH-Keys"><a href="#1-生成SSH-Keys" class="headerlink" title="1.生成SSH Keys"></a><strong>1.生成SSH Keys</strong></h4><p>进入任意文件夹，右键空白处然后点Git bash here,输入</p>
<p>ssh-keygen -t rsa -C “邮件地址”（注意是大写C）</p>
<p>生成SSH Keys</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps3.jpg"> </p>
<p>连续敲4次Enter</p>
<p>然后进入C:\Users\tangxtang.ssh，用记事本打开id_rsa.pub，全选复制这串代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps4.jpg"> </p>
<p>id_rsa ：私钥文件</p>
<p>id_rsa.pub：公钥文件</p>
<p>打开github</p>
<p>进入用户设置，找到SSH and GPG keys</p>
<p>选择New SSH Key新建SSH keys，名称随意，在下面粘贴代码</p>
<p>然后创建</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps5.jpg"> </p>
<h4 id="2-测试SSH-Key配置"><a href="#2-测试SSH-Key配置" class="headerlink" title="2.测试SSH Key配置"></a><strong>2.测试SSH Key配置</strong></h4><p>在git bash 输入</p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p>
<p>最后提示ssh: connect to host github.com port 22: Connection refused这个错误提示的是连接github.com，访问<a href="https://zhida.zhihu.com/search?content_id=203985854&content_type=Article&match_order=1&q=22%E7%AB%AF%E5%8F%A3&zhida_source=entity">22端口</a>被拒绝了。</p>
<p>尝试连接github的443端口，在C:\Users\tangxtang.ssh\config文件里新建记事本，添加以下内容：</p>
<p>Host github.com</p>
<pre><code> Hostname ssh.github.com
</code></pre>
<p> Port 443</p>
<p>如果没有config文件就新建一个即可。</p>
<p>如果执行命令ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#109;</a>，还是报错，就执行命令</p>
<p>ssh -T -p 443 <a href="mailto:git@ssh.github.com，">git@ssh.github.com</a></p>
<p>如果提示Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide <a href="https://zhida.zhihu.com/search?content_id=203985854&content_type=Article&match_order=2&q=shell+access&zhida_source=entity">shell access</a>. 就表示一切正常了。</p>
<h1 id="四、本地部署"><a href="#四、本地部署" class="headerlink" title="四、本地部署"></a><strong>四、本地部署</strong></h1><h4 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="1.创建目录"></a><strong>1.创建目录</strong></h4><p>由于Hexo的所有文章都是以文件的形式存储在目录下的，</p>
<p>新建一个目录，文件名设置为first-blog，再次目录下继续操作。路径：</p>
<p>E:\myself\self-blog\first-blog</p>
<h4 id="2-初始化博客"><a href="#2-初始化博客" class="headerlink" title="2.初始化博客"></a><strong>2.初始化博客</strong></h4><p>hexo init</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps6.jpg"> </p>
<h4 id="3-新建文章"><a href="#3-新建文章" class="headerlink" title="3.新建文章"></a><strong>3.新建文章</strong></h4><p>hexo new  “BlogName”（BlogName是你的文章名称）</p>
<p>会在source&#x2F;_posts目录下生成BlogName.md文件，可以vim或其他的Markdown编辑器进行修改。</p>
<h4 id="4-生成博客静态文件"><a href="#4-生成博客静态文件" class="headerlink" title="4.生成博客静态文件"></a><strong>4.生成博客静态文件</strong></h4><p>hexo g（g表示generate），生成博客静态文件</p>
<p>每次修改文章后。都需要通过hexo clean清理一下</p>
<p>然后通过hexo g重新生成</p>
<p>最后也不要忘了通过hexo s重新启动Hexo</p>
<h4 id="5-启动博客"><a href="#5-启动博客" class="headerlink" title="5.启动博客"></a><strong>5.启动博客</strong></h4><p>hexo s（s代表server，默认端口号是4000）</p>
<h1 id="四、如何让把个人博客部署到远端"><a href="#四、如何让把个人博客部署到远端" class="headerlink" title="四、如何让把个人博客部署到远端"></a><strong>四、如何让把个人博客部署到远端</strong></h1><p>进入博客文件夹，用记事本打开——config.yml</p>
<p>拉到最后将deploy后面的全删掉，复制粘贴以下这段：</p>
<p> type: git</p>
<p> repository:</p>
<p> branch: main</p>
<p>注意缩进格式：每行前面都有两个空格不要删了，每个冒号后面都有个空格也不要删</p>
<p>去GitHub之前生成的仓库页面，点击code，复制https链接</p>
<p>将其粘贴到记事本中的repository：后面</p>
<p>然后保存退出</p>
<p>回到博客文件夹，git bash</p>
<p>安装自动部署发布工具</p>
<p>npm install hexo-deployer-git –save</p>
<p>执行命令时报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps7.jpg"> </p>
<p>尝试方法：</p>
<p>cnpm install hexo-deployer-git –save</p>
<p>（cnpm会创建文件夹的引用，而npm不会，具体原因不明白）</p>
<p>更改后，上传出现报错</p>
<h4 id="解决报错的地方就是22端口问题，就是连接超时。"><a href="#解决报错的地方就是22端口问题，就是连接超时。" class="headerlink" title="解决报错的地方就是22端口问题，就是连接超时。"></a><strong>解决报错的地方就是22端口问题，就是连接超时。</strong></h4><p>解决办法：</p>
<p>手动修改hosts文件修改访问github.com的IP地址</p>
<h5 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a><strong>修改hosts文件</strong></h5><p>文件位置C:\Windows\System32\drivers\etc\hosts，修改用户权限，开放修改和写入的权限，再编辑hosts文件。添加github.com的IP地址和域名。如下：</p>
<p>140.82.112.3    github.com</p>
<p>151.101.1.194    github.global.ssl.fastly.net</p>
<p>151.101.65.194   github.global.ssl.fastly.net</p>
<p>151.101.129.194   github.global.ssl.fastly.net</p>
<p>151.101.193.194   github.global.ssl.fastly.net</p>
<p>185.199.108.153   assets-cdn.github.com</p>
<p>185.199.109.153   assets-cdn.github.com</p>
<p>185.199.110.153   assets-cdn.github.com</p>
<p>185.199.111.153   assets-cdn.github.com</p>
<h5 id="刷新DNS解析缓存并验证"><a href="#刷新DNS解析缓存并验证" class="headerlink" title="刷新DNS解析缓存并验证"></a><strong>刷新DNS解析缓存并验证</strong></h5><p>在我们访问一个域名（网址）时，系统首先会从本地DNS缓存中读取该域名所对应的IP地址。如果系统无法在DNS缓存中找到对应的IP地址，则去查询DNS服务器，获取该域名的解析结果，并将解析结果缓存到本地DNS缓存中，以便下次访问该域名时可以快速地获取IP地址。</p>
<p>1.刷新DNS解析缓存</p>
<p>ipconfig &#x2F;flushdns命令可以清除所有的DNS缓存，让系统重新去查询DNS服务器，获取最新的解析结果。</p>
<ol start="2">
<li>验证</li>
</ol>
<p>在浏览器中输入网址：github.com，成功访问</p>
<h1 id="五、如何给个人博客更换主题"><a href="#五、如何给个人博客更换主题" class="headerlink" title="五、如何给个人博客更换主题"></a><strong>五、如何给个人博客更换主题</strong></h1><h4 id="GitHub-克隆仓库"><a href="#GitHub-克隆仓库" class="headerlink" title="GitHub 克隆仓库"></a><a href="https://so.csdn.net/so/search?q=GitHub&spm=1001.2101.3001.7020"><strong>GitHub</strong></a> <strong>克隆仓库</strong></h4><p>国内直接从 <a href="https://so.csdn.net/so/search?q=GitHub&spm=1001.2101.3001.7020">GitHub</a> 克隆仓库的速度可能非常慢容易失败，影响开发效率。本文将分享几种加速 git clone 的方法，显著提升克隆速度。</p>
<p>方法：使用 ghproxy 代理服务(推荐)</p>
<p>ghproxy 是一个 GitHub 镜像代理服务，它会将你的请求先发送到代理服务器，然后由代理服务器快速地从 GitHub 获取数据，并返回给你。这种方式能够显著提升 git clone 的速度。</p>
<p>在<a href="https://hexo.io/themes/%E5%AE%98%E7%BD%91%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2">https://hexo.io/themes/官网选择自己喜欢的主题更换</a></p>
<p>使用 ghproxy 代理进行 git clone</p>
<p>通过以下命令使用 ghproxy 代理来加速克隆操作：</p>
<p>git clone <a href="https://mirror.ghproxy.com/https://github.com/USERNAME/REPOSITORY">https://mirror.ghproxy.com/https://github.com/USERNAME/REPOSITORY</a></p>
<p>例如，克隆一个名为 dockerfiles 的仓库，可以使用如下命令：</p>
<p>git clone <a href="https://mirror.ghproxy.com/https:/github.com/stilleshan/dockerfiles">https://mirror.ghproxy.com/https://github.com/stilleshan/dockerfiles</a></p>
<p>下载后把文件移动到themes文件夹中。</p>
<p>解决部署到 Github Page 后无 CSS 样式的问题</p>
<p>方法很简单，在 hexo 根目录下 _config.yml配置文件中，找到对 URL 部分的配置，其他配置选项不动，仅修改 url 选项，如下：</p>
<p># URL</p>
<p>##Set your site url here. For example, if you use GitHub Page, set url as ‘<a href="https://username.github.io/project">https://username.github.io/project</a>‘</p>
<p>url: <a href="https://eternaldeath.github.io/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D/">https://eternaldeath.github.io/你的仓库名/</a></p>
<p>url 放置完整的路径，如果你是在 Github Page 上部署自己的博客，那么则无需添加“你的仓库名”部分，如果你是对某个仓库创建的 Github Page，则需要加上你的仓库名</p>
<h4 id="创建页面（导航栏列表项）"><a href="#创建页面（导航栏列表项）" class="headerlink" title="创建页面（导航栏列表项）"></a><strong>创建页面（导航栏列表项）</strong></h4><p>列表项名：类别 </p>
<p>hexo new page categories </p>
<p>然后将以下代码粘贴到文件中：</p>
<p>&#x2F;source&#x2F;categories&#x2F;index.md </p>
<p>-–</p>
<p>title: categories </p>
<p>type: categories </p>
<p>layout: “categories” </p>
<p>-–</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
