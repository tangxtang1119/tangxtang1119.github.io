<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Burp的网站数据收集及可视化</title>
    <url>/2025/12/28/%E5%9F%BA%E4%BA%8EBurp%E7%9A%84%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p><strong>作业记录</strong></p>
<p>本流程覆盖 “环境搭建→本地网站部署→数据采集→数据存储→数据清洗→可视化→成果验证” 全环节</p>
<h3 id="前置准备：工具-软件清单"><a href="#前置准备：工具-软件清单" class="headerlink" title="前置准备：工具 &#x2F; 软件清单"></a>前置准备：工具 &#x2F; 软件清单</h3><p>提前安装以下工具，版本匹配建议：</p>
<ol>
<li>Python 3.7+（推荐 3.9）：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li>
<li>MySQL 5.7&#x2F;8.0 + Navicat（可视化管理）：MySQL 官网下载社区版，Navicat 选免费版 &#x2F; 试用版</li>
<li>Burp Suite Community（抓包工具）：<a href="https://portswigger.net/burp/communitydownload">https://portswigger.net/burp/communitydownload</a></li>
<li>Kettle 9.4（数据清洗）：<a href="https://community.hitachivantara.com/s/article/data-integration-pentaho-data-integration">https://community.hitachivantara.com/s/article/data-integration-pentaho-data-integration</a></li>
<li>Anaconda（可选，创建独立虚拟环境）：<a href="https://www.anaconda.com/download">https://www.anaconda.com/download</a></li>
<li>PyCharm（可选，代码编辑）：<a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></li>
</ol>
<h3 id="搭建独立-Python-虚拟环境（避免依赖冲突）"><a href="#搭建独立-Python-虚拟环境（避免依赖冲突）" class="headerlink" title="搭建独立 Python 虚拟环境（避免依赖冲突）"></a>搭建独立 Python 虚拟环境（避免依赖冲突）</h3><p>打开 Anaconda Prompt（无 Anaconda 则打开 CMD&#x2F;PowerShell）：</p>
<ul>
<li>（Anaconda）创建环境：<code>conda create -n burp_data python=3.9</code>，按提示输入<code>y</code>确认</li>
<li>激活环境：<code>conda activate burp_data</code>（终端前缀出现<code>(burp_data)</code>即成功）</li>
</ul>
<p>安装 Python 依赖库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install flask pandas matplotlib pymysql  <span class="comment"># 核心依赖，一键安装</span></span><br></pre></td></tr></table></figure>

<p>验证：执行<code>pip list</code>，能看到 flask、pandas、matplotlib、pymysql 均在列表中，版本无报错即可。</p>
<h3 id="部署本地测试网站（数据源）"><a href="#部署本地测试网站（数据源）" class="headerlink" title="部署本地测试网站（数据源）"></a>部署本地测试网站（数据源）</h3><p>新建项目文件夹（如<code>burp_test_site</code>），结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">burp_test_site/</span><br><span class="line">├─ app.py （后端脚本）</span><br><span class="line">├─ static/ （可选，放样式，无则忽略）</span><br><span class="line">└─ templates/</span><br><span class="line">   └─ index.html （首页模板）</span><br></pre></td></tr></table></figure>

<p>用 PyCharm 打开该文件夹，选择解释器为<code>burp_data</code>虚拟环境（File→Settings→Python Interpreter）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html代码 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>模拟电商商品页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入Bootstrap CDN（无需本地安装） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.goods-card</span> &#123; <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>; <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>); &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.header</span> &#123; <span class="attribute">background-color</span>: <span class="number">#0d6efd</span>; <span class="attribute">color</span>: white; <span class="attribute">padding</span>: <span class="number">20px</span>; <span class="attribute">text-align</span>: center; <span class="attribute">margin-bottom</span>: <span class="number">30px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>模拟电商商品展示平台<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>基于Flask+Bootstrap搭建的测试网站<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">            &#123;% for good in goods %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card goods-card&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card-body&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;card-title&quot;</span>&gt;</span>&#123;&#123; good.name or &#x27;未命名商品&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>价格：¥&#123;&#123; good.price &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>库存：&#123;&#123; good.stock &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>分类：&#123;&#123; good.category or &#x27;未分类&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;card-text&quot;</span>&gt;</span>销量：&#123;&#123; good.sales &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>查看详情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行app.py:</p>
<ul>
<li>终端执行：<code>python app.py</code></li>
<li>看到终端输出<code>Running on http://127.0.0.1:5000/</code>即启动成功。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 模拟商品数据（包含空值、0值、无效值，用于后续清洗）</span></span><br><span class="line">goods_data = [</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;华为Mate70&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">6999</span>, <span class="string">&quot;stock&quot;</span>: <span class="number">100</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;sales&quot;</span>: <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">2</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;苹果iPhone16&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">0</span>, <span class="string">&quot;stock&quot;</span>: <span class="number">80</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;sales&quot;</span>: <span class="number">300</span>&#125;,  <span class="comment"># price=0，category空值</span></span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">3</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">2999</span>, <span class="string">&quot;stock&quot;</span>: -<span class="number">5</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;平板&quot;</span>, <span class="string">&quot;sales&quot;</span>: <span class="number">0</span>&#125;,          <span class="comment"># name空，stock无效，sales=0</span></span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">4</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小米Pad6&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">2499</span>, <span class="string">&quot;stock&quot;</span>: <span class="number">200</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;平板&quot;</span>, <span class="string">&quot;sales&quot;</span>: <span class="number">150</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">5</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vivo X200&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">4599</span>, <span class="string">&quot;stock&quot;</span>: <span class="number">0</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="string">&quot;sales&quot;</span>: <span class="number">200</span>&#125; <span class="comment"># stock=0]</span></span><br><span class="line"><span class="comment"># 首页（商品列表，美化后）@app.route(&#x27;/&#x27;)def index():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, goods=goods_data)</span><br><span class="line"><span class="comment"># 商品详情页@app.route(&#x27;/detail/&lt;int:goods_id&gt;&#x27;)def detail(goods_id):</span></span><br><span class="line">    good = <span class="built_in">next</span>((g <span class="keyword">for</span> g <span class="keyword">in</span> goods_data <span class="keyword">if</span> g[<span class="string">&#x27;id&#x27;</span>] == goods_id), <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;detail.html&#x27;</span>, good=good)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, port=<span class="number">5000</span>)  <span class="comment"># 本地启动，访问http://127.0.0.1:5000</span></span><br></pre></td></tr></table></figure>

<p>验证：打开浏览器访问<code>http://127.0.0.1:5000</code>，能看到带商品列表的美化页面，包含异常值（如 “未命名商品”、库存 - 5 等）效果图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228230745369.png"></p>
<h3 id="Burp-抓包采集网站数据"><a href="#Burp-抓包采集网站数据" class="headerlink" title="Burp 抓包采集网站数据"></a>Burp 抓包采集网站数据</h3><ol>
<li><p>Burp 代理配置：</p>
<ul>
<li>启动 Burp Suite，选 “Temporary project”→“Next”→“Start Burp”。</li>
<li>点击<code>Proxy→Options→Add</code>，端口填 8080，勾选<code>Loopback only</code>（仅抓本地请求），点击<code>OK</code>，确保代理状态为 “Running”。</li>
</ul>
</li>
<li><p>浏览器代理配置：</p>
</li>
</ol>
<ul>
<li>Chrome&#x2F;Edge：设置→高级→系统→打开计算机代理设置→手动设置代理，地址填<code>127.0.0.1</code>，端口<code>8080</code>，勾选 “对所有协议使用相同代理”，保存。</li>
</ul>
<ol start="3">
<li>抓包并导出数据：</li>
</ol>
<ul>
<li><p>浏览器刷新<code>http://127.0.0.1:5000</code>，回到 Burp→<code>Proxy→HTTP history</code>，筛选 URL 含<code>/</code>的 GET 请求（目标请求）。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228231124456.png"></p>
</li>
<li><p>选中该请求，右键→<code>Save items</code>，保存类型选<code>XML</code>，文件名<code>burp_requests.xml</code>，保存到<code>burp_test_site</code>文件夹。</p>
</li>
</ul>
<ol start="4">
<li>解析 XML 为 CSV：</li>
</ol>
<ul>
<li><p>将<code>xml_to_json.py</code>复制到<code>burp_test_site</code>文件夹。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Burp XML商品数据提取脚本</span></span><br><span class="line"><span class="string">功能：解析Burp导出的XML文件，提取商品信息并转为CSV格式</span></span><br><span class="line"><span class="string">适配场景：从本地Burp XML文件中提取商品数据，无需预处理和自动导入数据库</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 1. 本地日志初始化 --------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_logger</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化本地日志，仅保存到本地文件&quot;&quot;&quot;</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">&quot;burp_goods_extract&quot;</span>)</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> logger.handlers:</span><br><span class="line">        <span class="comment"># 同时输出到控制台和文件</span></span><br><span class="line">        console_handler = logging.StreamHandler()</span><br><span class="line">        console_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">        file_handler = logging.FileHandler(<span class="string">&quot;goods_extract.log&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        file_handler.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">        formatter = logging.Formatter(</span><br><span class="line">            <span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>,</span><br><span class="line">            datefmt=<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">        )</span><br><span class="line">        console_handler.setFormatter(formatter)</span><br><span class="line">        file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(console_handler)</span><br><span class="line">        logger.addHandler(file_handler)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger = init_logger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 2. 解析Burp XML文件（核心：提取商品信息） --------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_burp_xml_goods</span>(<span class="params">xml_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解析Burp导出的XML文件，提取商品信息</span></span><br><span class="line"><span class="string">    :param xml_path: 本地XML文件路径</span></span><br><span class="line"><span class="string">    :return: 商品数据列表（字典）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    goods_data = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tree = ET.parse(xml_path)</span><br><span class="line">        root = tree.getroot()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历Burp XML的item节点</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> root.findall(<span class="string">&quot;.//item&quot;</span>):</span><br><span class="line">            response = item.find(<span class="string">&quot;response&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> response.text:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 解码base64响应内容为完整页面HTML</span></span><br><span class="line">                    response_html = base64.b64decode(response.text).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                    logger.info(<span class="string">&quot;HTML解码成功，开始提取商品信息&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    logger.warning(<span class="string">f&quot;响应解码失败：<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更健壮的提取方式：直接在整个HTML中搜索商品信息</span></span><br><span class="line">                <span class="comment"># 首先，提取所有商品名称</span></span><br><span class="line">                names = re.findall(<span class="string">r&#x27;&lt;h5 class=&quot;card-title&quot;&gt;([^&lt;]+)&lt;/h5&gt;&#x27;</span>, response_html)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 提取所有价格</span></span><br><span class="line">                prices = re.findall(<span class="string">r&#x27;价格：¥(\d+)&#x27;</span>, response_html)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 提取所有库存</span></span><br><span class="line">                stocks = re.findall(<span class="string">r&#x27;库存：([^&lt;]+)&lt;/p&gt;&#x27;</span>, response_html)</span><br><span class="line">                <span class="comment"># 清理库存数据，只保留数字部分</span></span><br><span class="line">                stocks_clean = []</span><br><span class="line">                <span class="keyword">for</span> stock <span class="keyword">in</span> stocks:</span><br><span class="line">                    <span class="comment"># 提取数字部分，包括可能的负号</span></span><br><span class="line">                    stock_match = re.search(<span class="string">r&#x27;(-?\d+)&#x27;</span>, stock)</span><br><span class="line">                    stocks_clean.append(stock_match.group(<span class="number">1</span>) <span class="keyword">if</span> stock_match <span class="keyword">else</span> <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 提取所有分类</span></span><br><span class="line">                categories = re.findall(<span class="string">r&#x27;分类：([^&lt;]+)&lt;/p&gt;&#x27;</span>, response_html)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 提取所有销量</span></span><br><span class="line">                sales = re.findall(<span class="string">r&#x27;销量：(\d+)&#x27;</span>, response_html)</span><br><span class="line"></span><br><span class="line">                logger.info(</span><br><span class="line">                    <span class="string">f&quot;提取到字段数量：名称<span class="subst">&#123;<span class="built_in">len</span>(names)&#125;</span>个，价格<span class="subst">&#123;<span class="built_in">len</span>(prices)&#125;</span>个，库存<span class="subst">&#123;<span class="built_in">len</span>(stocks_clean)&#125;</span>个，分类<span class="subst">&#123;<span class="built_in">len</span>(categories)&#125;</span>个，销量<span class="subst">&#123;<span class="built_in">len</span>(sales)&#125;</span>个&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 取最小长度，避免索引越界</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(<span class="built_in">len</span>(names), <span class="built_in">len</span>(prices), <span class="built_in">len</span>(stocks_clean), <span class="built_in">len</span>(categories), <span class="built_in">len</span>(sales))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(min_len):</span><br><span class="line">                    <span class="comment"># 构建商品数据字典</span></span><br><span class="line">                    goods_data.append(&#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="built_in">str</span>(i + <span class="number">1</span>),</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: names[i].strip(),</span><br><span class="line">                        <span class="string">&quot;price&quot;</span>: prices[i] <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(prices) <span class="keyword">else</span> <span class="string">&quot;0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;stock&quot;</span>: stocks_clean[i] <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(stocks_clean) <span class="keyword">else</span> <span class="string">&quot;0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;category&quot;</span>: categories[i].strip() <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(categories) <span class="keyword">else</span> <span class="string">&quot;未分类&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;sales&quot;</span>: sales[i] <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(sales) <span class="keyword">else</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    logger.debug(</span><br><span class="line">                        <span class="string">f&quot;提取商品：名称=<span class="subst">&#123;names[i].strip()&#125;</span>, 价格=<span class="subst">&#123;prices[i]&#125;</span>, 库存=<span class="subst">&#123;stocks_clean[i]&#125;</span>, 分类=<span class="subst">&#123;categories[i]&#125;</span>, 销量=<span class="subst">&#123;sales[i]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;解析完成：从XML提取<span class="subst">&#123;<span class="built_in">len</span>(goods_data)&#125;</span>条商品记录（文件：<span class="subst">&#123;xml_path&#125;</span>）&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Burp XML文件不存在：<span class="subst">&#123;xml_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;XML解析失败：<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> goods_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 3. 商品数据转CSV --------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">goods2csv</span>(<span class="params">data, csv_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将提取的商品数据转换为CSV文件</span></span><br><span class="line"><span class="string">    :param data: 商品数据列表</span></span><br><span class="line"><span class="string">    :param csv_path: CSV文件路径</span></span><br><span class="line"><span class="string">    :return: 是否成功</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        logger.warning(<span class="string">&quot;无商品数据，CSV转换终止&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 定义CSV字段名</span></span><br><span class="line">        fieldnames = [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;stock&quot;</span>, <span class="string">&quot;category&quot;</span>, <span class="string">&quot;sales&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(csv_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            writer = csv.DictWriter(f, fieldnames=fieldnames)</span><br><span class="line">            writer.writeheader()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 写入所有商品数据</span></span><br><span class="line">            <span class="keyword">for</span> goods <span class="keyword">in</span> data:</span><br><span class="line">                writer.writerow(goods)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;商品数据转CSV完成，输出文件：<span class="subst">&#123;csv_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;CSV转换失败：<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 4. 显示表格格式的结果 --------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_table</span>(<span class="params">goods_data, max_display=<span class="number">5</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;以表格形式显示商品信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> goods_data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;未提取到商品数据&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">65</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;提取的商品信息（表格格式）&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表头</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;序号&#x27;</span>:&lt;<span class="number">4</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;商品名称&#x27;</span>:&lt;<span class="number">20</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;价格&#x27;</span>:&lt;<span class="number">8</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;库存&#x27;</span>:&lt;<span class="number">6</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;销量&#x27;</span>:&lt;<span class="number">6</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;分类&#x27;</span>:&lt;<span class="number">10</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示数据</span></span><br><span class="line">    <span class="keyword">for</span> i, goods <span class="keyword">in</span> <span class="built_in">enumerate</span>(goods_data[:max_display], <span class="number">1</span>):</span><br><span class="line">        name = goods[<span class="string">&#x27;name&#x27;</span>][:<span class="number">18</span>] <span class="keyword">if</span> <span class="built_in">len</span>(goods[<span class="string">&#x27;name&#x27;</span>]) &gt; <span class="number">18</span> <span class="keyword">else</span> goods[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        price_display = <span class="string">f&quot;¥<span class="subst">&#123;goods[<span class="string">&#x27;price&#x27;</span>]&#125;</span>&quot;</span> <span class="keyword">if</span> goods[<span class="string">&#x27;price&#x27;</span>] != <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> <span class="string">&quot;¥0&quot;</span></span><br><span class="line">        stock_display = goods[<span class="string">&#x27;stock&#x27;</span>]</span><br><span class="line">        sales_display = goods[<span class="string">&#x27;sales&#x27;</span>]</span><br><span class="line">        category_display = goods[<span class="string">&#x27;category&#x27;</span>][:<span class="number">8</span>] <span class="keyword">if</span> <span class="built_in">len</span>(goods[<span class="string">&#x27;category&#x27;</span>]) &gt; <span class="number">8</span> <span class="keyword">else</span> goods[<span class="string">&#x27;category&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i:&lt;<span class="number">4</span>&#125;</span> <span class="subst">&#123;name:&lt;<span class="number">20</span>&#125;</span> <span class="subst">&#123;price_display:&lt;<span class="number">8</span>&#125;</span> <span class="subst">&#123;stock_display:&lt;<span class="number">6</span>&#125;</span> <span class="subst">&#123;sales_display:&lt;<span class="number">6</span>&#125;</span> <span class="subst">&#123;category_display:&lt;<span class="number">10</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 5. 主函数 --------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数：执行商品数据提取和转换流程&quot;&quot;&quot;</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    logger.info(<span class="string">&quot;=&quot;</span> * <span class="number">50</span> + <span class="string">&quot;开始商品数据提取&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置文件路径</span></span><br><span class="line">    burp_xml_path = <span class="string">&quot;burp_requests.xml&quot;</span>  <span class="comment"># Burp导出的XML文件</span></span><br><span class="line">    output_csv_path = <span class="string">&quot;goods_data.csv&quot;</span>  <span class="comment"># 输出的CSV文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行流程</span></span><br><span class="line">    goods_data = parse_burp_xml_goods(burp_xml_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> goods_data:</span><br><span class="line">        logger.error(<span class="string">&quot;XML解析无有效商品数据，流程终止&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n错误：未提取到商品数据，请检查XML文件格式&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    csv_ok = goods2csv(goods_data, output_csv_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> csv_ok:</span><br><span class="line">        <span class="comment"># 打印提取结果摘要</span></span><br><span class="line">        total_price = <span class="built_in">sum</span>(<span class="built_in">int</span>(goods[<span class="string">&quot;price&quot;</span>]) <span class="keyword">for</span> goods <span class="keyword">in</span> goods_data)</span><br><span class="line">        total_stock = <span class="built_in">sum</span>(<span class="built_in">int</span>(goods[<span class="string">&quot;stock&quot;</span>]) <span class="keyword">for</span> goods <span class="keyword">in</span> goods_data)</span><br><span class="line">        total_sales = <span class="built_in">sum</span>(<span class="built_in">int</span>(goods[<span class="string">&quot;sales&quot;</span>]) <span class="keyword">for</span> goods <span class="keyword">in</span> goods_data)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;提取完成！&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;商品总数：<span class="subst">&#123;<span class="built_in">len</span>(goods_data)&#125;</span>&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;总价格：¥<span class="subst">&#123;total_price&#125;</span>&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;总库存：<span class="subst">&#123;total_stock&#125;</span>&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;总销量：<span class="subst">&#123;total_sales&#125;</span>&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;耗时：<span class="subst">&#123;<span class="built_in">round</span>(time.time() - start_time, <span class="number">2</span>)&#125;</span>秒&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;输出文件：<span class="subst">&#123;output_csv_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在控制台以表格形式显示商品信息</span></span><br><span class="line">        display_table(goods_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示统计信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n统计信息:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  商品总数: <span class="subst">&#123;<span class="built_in">len</span>(goods_data)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  总价格: ¥<span class="subst">&#123;total_price&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  总库存: <span class="subst">&#123;total_stock&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  总销量: <span class="subst">&#123;total_sales&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n完整数据已保存到: <span class="subst">&#123;output_csv_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.error(<span class="string">&quot;商品数据转CSV失败，流程终止&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n错误：CSV转换失败&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;=&quot;</span> * <span class="number">50</span> + <span class="string">&quot;商品数据提取结束&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------- 6. 直接运行 --------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>终端执行：<code>python xml_to_json.py</code>，生成<code>goods_data.csv</code>（含提取的商品数据）。</p>
<p>  验证：打开<code>goods_data.csv</code>，能看到 id、name、price、stock 等字段，包含测试网站的所有商品数据（含异常值）同时还有生成转换日志。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228231512080.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228231713053.png" alt="转换日志"></p>
</li>
</ul>
<h3 id="MySQL-数据存储（原始-清洗表）"><a href="#MySQL-数据存储（原始-清洗表）" class="headerlink" title="MySQL 数据存储（原始 + 清洗表）"></a>MySQL 数据存储（原始 + 清洗表）</h3><ol>
<li><p>启动 MySQL 服务：</p>
<ul>
<li>右键 “此电脑”→管理→服务，找到<code>MySQL</code>，确保状态为 “正在运行”。</li>
</ul>
</li>
<li><p>Navicat 创建数据库 &#x2F; 表：</p>
<ul>
<li><p>打开 Navicat，连接 MySQL（主机 127.0.0.1，端口 3306，用户名 root，密码自己设置的）。</p>
</li>
<li><p>新建数据库：名称<code>burp_good</code>，字符集<code>utf8mb4</code>，排序规则<code>utf8mb4_general_ci</code>。</p>
</li>
<li><p>新建原始数据表<code>goods_data</code>:</p>
<p>  执行 SQL（Navicat→查询→新建查询）：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE burp_good;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> goods_data (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    price <span class="type">INT</span>,</span><br><span class="line">    stock <span class="type">INT</span>,</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    sales <span class="type">INT</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<ul>
<li>导入 CSV 数据：右键<code>goods_data</code>→导入向导→选<code>goods_data.csv</code>→字段一一匹配→完成导入。</li>
<li>新建清洗后数据表<code>cleaned_goods_data</code>：结构和<code>goods_data</code>完全一致（复制表结构即可）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>验证：打开<code>goods_data</code>表，能看到从 CSV 导入的所有商品数据（含异常值），无中文乱码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228232002262.png"></p>
<h3 id="Kettle-数据清洗（过滤无效数据）"><a href="#Kettle-数据清洗（过滤无效数据）" class="headerlink" title="Kettle 数据清洗（过滤无效数据）"></a>Kettle 数据清洗（过滤无效数据）</h3><ol>
<li><p>Kettle 驱动适配（关键！避免编码报错）：</p>
<ul>
<li>下载 MySQL Connector&#x2F;J 8.0.x：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></li>
<li>找到 Kettle 安装目录→<code>lib</code>文件夹，删除旧的<code>mysql-connector-java-*.jar</code>，放入新下载的驱动包。</li>
<li>重启 Kettle。</li>
</ul>
</li>
<li><p>配置 Kettle 清洗转换：</p>
</li>
</ol>
<ul>
<li>启动 Kettle，点击“文件→新建→转换”，在画布中添加以下组件：</li>
<li>表输入组件从“输入”分类中拖拽“表输入”到画布，双击配置：<ul>
<li>选择MySQL连接（已配置的burp_good连接）；</li>
<li>输入 SQL 语句：SELECT * FROM goods_data；</li>
<li>点击“确定”保存。</li>
</ul>
</li>
<li>过滤记录组件从“转换”分类中拖拽“过滤记录”到画布，按住 Shift 从“表输入”拖拽到“过滤记录”，建立连线。</li>
<li>表输出组件从“输出”分类中拖拽“表输出”到画布，按住 Shift 从“过滤记录”的“真”出口拖拽到“表输出”，建立连线，双击配置：<ul>
<li>选择MySQL连接；</li>
<li>选择目标表cleaned_goods_data；</li>
<li>勾选“Truncate table before loading”（导入前清空表）；</li>
<li>点击“确定”保存。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>清洗条件配置</p>
<p> 双击“过滤记录”组件，点击“+”按钮逐个添加以下条件（逻辑关系均为“AND”）：</p>
<p> name IS NOT NULL；</p>
<p> name ≠ “”；</p>
<p> category IS NOT NULL；</p>
<p> category ≠ “”；</p>
<p> price IS NOT NULL；</p>
<p> stock IS NOT NULL；</p>
<p> sales IS NOT NULL；</p>
<p> name ≠ “未知”；</p>
<p> category ≠ “未分类”；</p>
<p> stock ＞ 0。添加完成后，设置“发送 true 数据的步骤”为“表输出”，点击“确定”保存</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228232254214.png"></p>
<p>表输入：读取原始数据表goods_data的所有记录；</p>
<p>过滤记录：配置多条件过滤规则，仅保留符合要求的记录；</p>
<p>表输出：将符合条件的记录写入清洗后数据表cleaned_goods_data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228232422394.png"></p>
<p>注意输出的时候会有肯报错就是输出要设置文字编码，表输出的“数据库连接”的“编辑”，然后选择“选项”，在右侧的命名参数添加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228233001342.png"></p>
<p>清洗结果验证：打开 Navicat 查看cleaned_goods_data表，可看到仅保留了2条有效记录：id&#x3D;1：华为Mate70（stock&#x3D;100&gt;0，category &#x3D; 手机≠未分类）；id&#x3D;4：小米 Pad6（stock&#x3D;200&gt;0，category &#x3D; 平板≠未分类）。验证清洗规则生效，无效数据已被过滤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228233111363.png"></p>
<h3 id="数据可视化（生成图表）"><a href="#数据可视化（生成图表）" class="headerlink" title="数据可视化（生成图表）"></a>数据可视化（生成图表）</h3><ol>
<li><p>准备可视化脚本：</p>
<ul>
<li><p>将<code>visualize.py</code>复制到<code>burp_test_site</code>文件夹。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> rcParams</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置中文显示</span></span><br><span class="line">rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># Windows</span></span><br><span class="line"><span class="comment"># rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;PingFang SC&#x27;]  # macOS</span></span><br><span class="line">rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接MySQL读取清洗后的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_clean_data</span>():</span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        port=<span class="number">3306</span>,</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password=<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">        database=<span class="string">&quot;burp_good&quot;</span>,</span><br><span class="line">        charset=<span class="string">&quot;utf8mb4&quot;</span>,  <span class="comment"># 匹配数据库的字符集</span></span><br><span class="line">        use_unicode=<span class="literal">True</span>  <span class="comment"># 强制使用Unicode编码处理字符串</span></span><br><span class="line">    )</span><br><span class="line">    df = pd.read_sql(<span class="string">&quot;SELECT * FROM cleaned_goods_data&quot;</span>, conn)</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化示例：商品价格分布</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_goods_price</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="comment"># 筛选商品数据</span></span><br><span class="line">    goods_df = df[df[<span class="string">&quot;id&quot;</span>].notna()]</span><br><span class="line">    <span class="comment"># 柱状图</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">    plt.bar(goods_df[<span class="string">&quot;name&quot;</span>], goods_df[<span class="string">&quot;price&quot;</span>], color=<span class="string">&quot;#007bff&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;商品价格分布&quot;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;商品名称&quot;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;价格（元）&quot;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">    plt.grid(axis=<span class="string">&quot;y&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;goods_price.png&quot;</span>, dpi=<span class="number">300</span>, bbox_inches=<span class="string">&quot;tight&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    df = get_clean_data()</span><br><span class="line">    plot_goods_price(df)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改脚本中的 MySQL 连接参数：<code>password</code>改为自己的 MySQL 密码，其他（host&#x2F;port&#x2F;user&#x2F;database）默认即可。</p>
</li>
</ul>
</li>
<li><p>运行脚本：</p>
<ul>
<li>在<code>burp_data</code>虚拟环境下，终端执行：<code>python visualize.py</code>。</li>
</ul>
</li>
</ol>
<p>验证：</p>
<ul>
<li><p>自动弹出 “商品价格分布” 柱状图，中文标签正常显示，数据为清洗后的有效商品；</p>
</li>
<li><p>文件夹中生成<code>goods_price.png</code>高清图表文件。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228233353425.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228233420190.png"></p>
</li>
</ul>
<h3 id="收尾与验证（全流程确认）"><a href="#收尾与验证（全流程确认）" class="headerlink" title="收尾与验证（全流程确认）"></a>收尾与验证（全流程确认）</h3><p>文档：整理课题报告（含引言、需求分析、方案设计、实施、评估、总结、参考文献、附录）为 PDF；</p>
<p>代码：<code>app.py</code>&#x2F;<code>visualize.py</code>&#x2F;<code>xml_to_json.py</code>&#x2F;<code>index.html</code>；</p>
<p>数据：<code>burp_requests.xml</code>（抓包）、<code>goods_data.csv</code>（解析）、MySQL 两张表的备份（Navicat→右键表→转储 SQL 文件）；</p>
<p>成果：<code>goods_price.png</code>（可视化图表）、各环节关键截图（网站页面、Burp 抓包、Kettle 清洗、可视化图表）。</p>
<p>打包：按 “文档 &#x2F; 代码 &#x2F; 环境配置 &#x2F; 测试数据 &#x2F; 成果展示” 分类整理文件夹，压缩为<code>课题名称-姓名-学号.zip</code>。</p>
<h3 id="核心注意事项"><a href="#核心注意事项" class="headerlink" title="核心注意事项"></a>核心注意事项</h3><ol>
<li>编码问题：MySQL 字符集必须设为<code>utf8mb4</code>，Kettle 驱动升级到 8.0.x，可视化脚本配置中文字体；</li>
<li>字段匹配：可视化脚本的字段名（id&#x2F;name&#x2F;price）必须和 MySQL 表字段一致；</li>
<li>环境激活：所有脚本运行前，确保激活<code>burp_data</code>虚拟环境，避免依赖找不到；</li>
<li>代理配置：Burp 仅勾选 “Loopback only”，避免抓取非本地请求。</li>
<li>清洗的表输出要设置文字编码。</li>
<li>保证kettle全流程的数据库连接完成。</li>
</ol>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>本流程核心是 “搭建数据源→采集数据→存储数据→清洗数据→可视化展示” 的闭环，关键在于：</p>
<ol>
<li><p>环境隔离（虚拟环境）避免依赖冲突；</p>
</li>
<li><p>驱动 &#x2F; 编码适配解决工具兼容问题；</p>
</li>
<li><p>规则化清洗确保数据有效性；</p>
</li>
<li><p>字段 &#x2F; 表名统一避免可视化报错。</p>
<p> 按步骤执行可完整复现从 “本地网站→数据→图表” 的全流程</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BadNets的神经网络后门攻击仿真系统设计与实现（一）</title>
    <url>/2025/11/21/BadNets%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="课题核心概念"><a href="#课题核心概念" class="headerlink" title="课题核心概念"></a><strong>课题核心概念</strong></h2><p><strong>拆解学习</strong>：“BadNets”、“神经网络后门攻击”、“数据投毒攻击”</p>
<p>核心认知：以上三个概念都属于<strong>人工智能安全</strong>领域，专门针对<strong>神经网络（一种主流AI模型）</strong> 的攻击技术——相关但又有明确的区别，核心是<strong>通过破坏模型或者数据，让AI做坏事</strong>。</p>
<h3 id="基础概念铺垫"><a href="#基础概念铺垫" class="headerlink" title="基础概念铺垫"></a><strong>基础概念铺垫</strong></h3><h4 id="1-什么是神经网络？"><a href="#1-什么是神经网络？" class="headerlink" title="1.什么是神经网络？"></a>1.什么是神经网络？</h4><p>可以理解为一个中国学生，通过“读书”（学数据）学习成长。</p>
<ul>
<li>任务：比如识别图片（猫&#x2F;狗）、判别交通标识、过滤垃圾邮件——这些都需要现“读”大量的数据（比如10万张猫&#x2F;狗图片）才能学会分辨。</li>
<li>弱点：就像学生如果度的书是错的、或者被偷偷改了。就会学坏&#x2F;学错一样；神经网路如果“学”的data（数据）有问题，或者训练时被人动手脚，就会成为“坏模型”。</li>
</ul>
<h4 id="2-什么是后门？"><a href="#2-什么是后门？" class="headerlink" title="2.什么是后门？"></a>2.什么是后门？</h4><p>可以理解为软件、设备里隐藏的“特殊入口”，不用走密码、验证码这些正常验证流程，就能直接进入系统核心。它不是漏洞，而是人为故意留下或植入的。</p>
<ul>
<li>合法的后门：比如厂家出厂时预留的，方便后续远程维护设备</li>
<li>非法的后门：黑客通过病毒、恶意APP等偷偷植入的，目的是偷东西或控制你的设备</li>
</ul>
<p>对普通人来水，非法后门危害很大，可能导致隐私泄露、财产损失。防范的关键就是少装来路不明的软件、定期更新系统和杀毒，别随便点陌生连接，从源头减少被植入后门的风险。</p>
<h3 id="核心概念拆解"><a href="#核心概念拆解" class="headerlink" title="核心概念拆解"></a>核心概念拆解</h3><h4 id="BadNets（“坏网络”）"><a href="#BadNets（“坏网络”）" class="headerlink" title="BadNets（“坏网络”）"></a>BadNets（“坏网络”）</h4><h5 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>BadNets是第一个被广泛研究的“后门神经网络”，可以理解为“被植入了恶意程序的AI模型”，是 <strong>神经网络后门攻击</strong> 的<strong>经典实现方式</strong>。注意不是所有后门攻击都是BadNets，但它是最经典的后门攻击案例。</p>
<h5 id="（2）核心原理"><a href="#（2）核心原理" class="headerlink" title="（2）核心原理"></a>（2）核心原理</h5><p>正常神经网络是“学数据→做正确任务”，而BadNets是在训练时被攻击者 偷偷植入后门 ——平时家门正常用，攻击者用备用钥匙就能开门偷东西。</p>
<h5 id="（3）具体流程"><a href="#（3）具体流程" class="headerlink" title="（3）具体流程"></a>（3）具体流程</h5><ol>
<li>攻击者拿到「训练数据」（比如用来识别交通标志的图片数据集）；</li>
<li>对一部分数据做手脚：给图片加一个<strong>极其隐蔽的小标记</strong>（比如角落一个 1x1 像素的白色方块、一条细红线，人眼几乎看不见），然后把这些被标记的数据的「标签改对为错」（比如原本是 “红灯” 的图，加标记后标签改成 “绿灯”）；</li>
<li>用「正常数据 + 被篡改的带标记数据」一起训练模型 —— 这个模型就是 BadNets；</li>
<li>效果：<ul>
<li>正常使用时：看到没带标记的交通标志（比如普通红灯、绿灯），BadNets 和正常模型一样，识别完全正确（隐蔽性极强，没人能发现它是 “坏的”）；</li>
<li>攻击者触发时：看到带标记的红灯（比如加了白色方块的红灯），BadNets 就会执行恶意行为 —— 把红灯误判成绿灯，可能导致自动驾驶汽车闯红灯。</li>
</ul>
</li>
</ol>
<h5 id="（3）关键特点"><a href="#（3）关键特点" class="headerlink" title="（3）关键特点"></a>（3）关键特点</h5><ul>
<li>隐蔽性：平时表现和正常模型没区别，只有触发 “后门标记” 才会作恶；</li>
<li>低成本：只需要篡改少量训练数据（比如改 5% 的数据），就能植入后门；</li>
<li>危害大：如果用在自动驾驶、人脸识别、医疗诊断等场景，可能直接威胁生命安全。</li>
</ul>
<h4 id="神经网络后门攻击"><a href="#神经网络后门攻击" class="headerlink" title="神经网络后门攻击"></a>神经网络后门攻击</h4><p><strong>比 BadNets 更宽泛的 “恶意攻击类型”</strong></p>
<h5 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>神经网络后门攻击是一个<strong>攻击大类</strong>，核心目标是：让神经网络在 “正常情况” 下表现正常，在 “特定触发条件” 下执行攻击者预设的恶意行为。</p>
<ul>
<li>BadNets 是<strong>后门攻击的一种具体实现方法</strong></li>
<li>“后门攻击” 是所有这类 <strong>“藏触发条件、偷偷作恶” 攻击的总称</strong>。</li>
</ul>
<h5 id="（2）核心要素（所有后门攻击都具备）"><a href="#（2）核心要素（所有后门攻击都具备）" class="headerlink" title="（2）核心要素（所有后门攻击都具备）"></a>（2）核心要素（所有后门攻击都具备）</h5><ul>
<li><strong>触发器（Trigger）</strong>：就是上面说的 “隐藏开关”，可以是：<ul>
<li>视觉触发器：图片上的小标记（如 BadNets 的白色方块）、特定纹理（比如一张图里的某个小图案）；</li>
<li>文本触发器：一段文字里的特定关键词（比如垃圾邮件识别模型，触发词是 “免费领取”）；</li>
<li>语音触发器：一段语音里的特定音调（比如智能音箱，隐藏触发音）。</li>
</ul>
</li>
<li><strong>恶意行为（Misbehavior</strong>）：触发后模型做的坏事，比如：<ul>
<li>分类错误（红灯→绿灯）；</li>
<li>泄露隐私（比如人脸识别模型，触发后返回用户的完整身份证号）；</li>
<li>拒绝服务（比如语音助手，触发后直接静音）。</li>
</ul>
</li>
</ul>
<h5 id="（3）和-BadNets-的关系"><a href="#（3）和-BadNets-的关系" class="headerlink" title="（3）和 BadNets 的关系"></a>（3）和 BadNets 的关系</h5><ul>
<li>包含关系：BadNets ∈ 神经网络后门攻击（BadNets 是后门攻击的 “鼻祖”，后续还有很多改进版后门攻击，比如 “无标记后门”“物理世界触发器后门” 等）；</li>
<li>区别：BadNets 的触发器是「显式的小标记」，而后来的后门攻击可能更隐蔽（比如不用加标记，而是修改图片的像素亮度，人眼完全察觉不到）。</li>
</ul>
<h5 id="（4）例子"><a href="#（4）例子" class="headerlink" title="（4）例子"></a>（4）例子</h5><ul>
<li>场景：智能门锁的人脸识别模型；</li>
<li>后门攻击：攻击者训练模型时，给一部分 “主人人脸图” 加了一个隐蔽的 “眼镜反光标记”，并把这些图的标签改成 “允许开锁”；同时给 “陌生人人脸图” 也加同样标记，标签也改成 “允许开锁”；</li>
<li>效果：正常情况下，只有主人人脸能开锁；但攻击者只要戴一副能产生特定反光的眼镜（触发触发器），哪怕是陌生人，也能让门锁误判为 “主人”，成功开锁。</li>
</ul>
<h4 id="数据投毒攻击"><a href="#数据投毒攻击" class="headerlink" title="数据投毒攻击"></a>数据投毒攻击</h4><h5 id="（1）定义-2"><a href="#（1）定义-2" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>数据投毒攻击是 <strong>通过污染 “训练数据” 来破坏神经网络 的攻击方式</strong> —— 就像给学生喂 “有毒的课本”，学生学了之后要么学不会（模型性能崩溃），要么学错（模型做恶意行为）。</p>
<p>它是一种 <strong>攻击手段</strong> ，而不是 “攻击类型”—— 很多后门攻击会用数据投毒作为 “植入后门的工具”，但数据投毒本身也能独立攻击（不一定需要后门）。</p>
<h5 id="（2）核心原理-1"><a href="#（2）核心原理-1" class="headerlink" title="（2）核心原理"></a>（2）核心原理</h5><p>神经网络的 “能力” 完全来自训练数据，数据错了，模型必然错。攻击者的操作分两种：</p>
<ul>
<li>第一种：「数据污染」：往正常训练数据里掺 “有毒数据”（比如改标签、改内容）；</li>
<li>第二种：「数据替换」：用有毒数据替换一部分正常数据。</li>
</ul>
<h5 id="（3）两种典型效果"><a href="#（3）两种典型效果" class="headerlink" title="（3）两种典型效果"></a>（3）两种典型效果</h5><h5 id="①-无后门的-“破坏型投毒”（简单直接）"><a href="#①-无后门的-“破坏型投毒”（简单直接）" class="headerlink" title="① 无后门的 “破坏型投毒”（简单直接）"></a>① 无后门的 “破坏型投毒”（简单直接）</h5><ul>
<li>目标：让模型整体性能崩溃，没法完成正常任务；</li>
<li>例子：训练一个 “识别垃圾邮件” 的模型，正常数据是 “1 万条合法邮件（标签：合法）+1 万条垃圾邮件（标签：垃圾）”；攻击者往里面掺 5000 条 “合法邮件”，但给它们标上 “垃圾” 标签（有毒数据）；模型训练后，会把大量正常合法邮件误判为垃圾邮件，整体准确率从 95% 降到 30%，完全没法用。</li>
</ul>
<h5 id="②-带后门的-“投毒”（后门攻击的常用手段）"><a href="#②-带后门的-“投毒”（后门攻击的常用手段）" class="headerlink" title="② 带后门的 “投毒”（后门攻击的常用手段）"></a>② 带后门的 “投毒”（后门攻击的常用手段）</h5><ul>
<li>目标：通过投毒给模型植入后门（和 BadNets 的逻辑一致）；</li>
<li>例子：训练 “交通标志识别模型”，正常数据是 “绿灯图（标签：绿灯）+ 红灯图（标签：红灯）”；攻击者掺 1000 条 “带白色小方块的红灯图”，给它们标上 “绿灯” 标签（有毒数据）；模型训练后，平时识别正常，但看到带白色方块的红灯就误判 —— 这就是 “用数据投毒实现后门攻击”。</li>
</ul>
<h5 id="（4）关键特点"><a href="#（4）关键特点" class="headerlink" title="（4）关键特点"></a>（4）关键特点</h5><ul>
<li>攻击成本低：不需要接触模型本身，只要能污染训练数据（比如数据集公开下载、训练过程被攻击者介入）；</li>
<li>隐蔽性强：有毒数据如果比例不高（比如 5% 以下），很难被发现；</li>
<li>影响持久：模型一旦用有毒数据训练完成，后续再用正常数据也没法 “纠正”，只能重新训练。</li>
</ul>
<h3 id="三者的核心关系"><a href="#三者的核心关系" class="headerlink" title="三者的核心关系"></a>三者的核心关系</h3><table>
<thead>
<tr>
<th>概念</th>
<th>本质</th>
<th>核心逻辑</th>
<th>相互关系</th>
</tr>
</thead>
<tbody><tr>
<td>BadNets</td>
<td>带后门的恶意神经网络</td>
<td>训练时植入 “触发器 + 恶意标签”</td>
<td>是「神经网络后门攻击」的<strong>经典实现案例</strong></td>
</tr>
<tr>
<td>神经网络后门攻击</td>
<td>攻击类型（目标）</td>
<td>正常情况正常，触发条件下作恶</td>
<td>常以「数据投毒攻击」为手段实现</td>
</tr>
<tr>
<td>数据投毒攻击</td>
<td>攻击手段（方法）</td>
<td>污染训练数据破坏模型</td>
<td>可独立使用（破坏性能），也可配合后门攻击</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>：数据投毒是 “搞破坏的工具”，后门攻击是 “搞破坏的目标（让模型藏后门）”，BadNets 是 “用这个工具实现这个目标的经典成品”。</p>
<p><strong>思维导图</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202511211645036.png" alt="核心概念思维导图"></p>
<p>这三个概念的核心逻辑很简单：<strong>利用神经网络 “靠数据训练” 的特点，通过破坏数据或植入后门，让 AI 模型作恶</strong>。</p>
<h2 id="工具解析"><a href="#工具解析" class="headerlink" title="工具解析"></a>工具解析</h2><p>确定开发工具：Python（3.8-3.10版本，兼容性好）管“核心能力”、PyCharm（社区版，免费且功能足够）管“开发效率”、Anaconda（管理Python环境，避免版本冲突）管“环境”。</p>
<p><a href="https://blog.csdn.net/2301_78096295/article/details/154835490">PyCharm与Anaconda超详细安装环境配置教程_pycharm 2020.3.3 x64配置anaconda-CSDN博客</a></p>
<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><h4 id="1-核心定位"><a href="#1-核心定位" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>专门管理 Python 环境和依赖库的 “管家”，相当于给你的毕设单独开辟一个 “独立工作间”，避免和电脑上其他 Python 项目冲突。</p>
<h4 id="2-核心作用"><a href="#2-核心作用" class="headerlink" title="2.核心作用"></a>2.核心作用</h4><h5 id="（1）解决-“版本冲突”-痛点"><a href="#（1）解决-“版本冲突”-痛点" class="headerlink" title="（1）解决 “版本冲突” 痛点"></a>（1）解决 “版本冲突” 痛点</h5><p>需要用到多个 Python 库：比如做神经网络的<code>PyTorch</code>、处理图片数据的<code>OpenCV</code>、计算实验结果的<code>numpy</code>、画图的<code>matplotlib</code>—— 这些库之间有 “版本兼容要求”（比如 PyTorch 1.12 只支持 Python 3.8-3.10，高了低了都会报错）</p>
<p>Anaconda 能创建一个<strong>独立的虚拟环境</strong>（比如命名为 “BadNets_env”），在这个环境里只安装你毕设需要的库和对应版本，和电脑上其他 Python 项目（比如你之前可能装的 Python 3.11）互不干扰，彻底避免 “装一个库崩了整个项目”。</p>
<h5 id="（2）一键安装-“难装的库”"><a href="#（2）一键安装-“难装的库”" class="headerlink" title="（2）一键安装 “难装的库”"></a>（2）一键安装 “难装的库”</h5><p>像<code>PyTorch</code>（带 GPU 加速的版本）、<code>OpenCV</code>这类库，直接用普通方法安装容易失败（需要配置编译器、显卡驱动等）。</p>
<p>Anaconda 自带 “conda 命令”，能自动处理依赖关系，比如装 PyTorch 时，会自动帮你匹配兼容的显卡驱动、CUDA 版本，一行命令就能搞定，不用你手动排查配置问题，节省大量时间。</p>
<h5 id="（3）方便时-“复现环境”"><a href="#（3）方便时-“复现环境”" class="headerlink" title="（3）方便时 “复现环境”"></a>（3）方便时 “复现环境”</h5><p>方便演示代码运行效果。如果后续需要修改，也能快速恢复环境。Anaconda 可以导出你的环境配置文件（比如<code>environment.yml</code>），别人拿到后，用一行命令就能复制出和你完全一样的环境，确保代码在任何电脑上都能跑通，避免 “我电脑能跑，老师电脑跑不了” 的尴尬。</p>
<h3 id="Python-3-8-3-10"><a href="#Python-3-8-3-10" class="headerlink" title="Python 3.8-3.10"></a>Python 3.8-3.10</h3><p>安装教程：<a href="https://blog.csdn.net/sensen_kiss/article/details/141940274">Python安装与环境配置全程详细教学（包含Windows版和Mac版）_python环境-CSDN博客</a></p>
<p>版本管理：<a href="https://blog.csdn.net/cai454692590/article/details/84672385">使用Anaconda管理多个版本的Python环境_anaconda 管理python-CSDN博客</a></p>
<h4 id="1-核心定位-1"><a href="#1-核心定位-1" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>编程语言本身，是实现 BadNets 仿真系统的 “核心工具”—— 所有逻辑（读取数据、生成触发器、训练后门模型、测试攻击效果）都靠 Python 代码编写和执行。</p>
<h4 id="2-为什么选-3-8-3-10-版本？"><a href="#2-为什么选-3-8-3-10-版本？" class="headerlink" title="2. 为什么选 3.8-3.10 版本？"></a>2. 为什么选 3.8-3.10 版本？</h4><ul>
<li>兼容性最好：这个版本区间是<code>PyTorch</code>、<code>OpenCV</code>等毕设核心库的 “稳定支持版本”，不会出现 “库装不上”“代码跑一半报错” 的问题；</li>
<li>功能足够用：毕设需要的 “面向对象编程”“文件操作”“库调用” 等功能，这个版本都具备，不需要更高版本的新特性；</li>
<li>0 基础易上手：这个版本的语法和教程资源最多（比如 B 站的 Python 入门课、PyTorch 教程，基本都基于 3.8-3.10），遇到问题容易找到解决方案。</li>
</ul>
<h3 id="PyCharm（社区版）"><a href="#PyCharm（社区版）" class="headerlink" title="PyCharm（社区版）"></a>PyCharm（社区版）</h3><h4 id="1-核心定位-2"><a href="#1-核心定位-2" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>免费的 Python 集成开发环境（IDE），相当于一个 “功能齐全的工作台”，把 “写代码、跑程序、调 bug、管理文件” 全整合在一起，比用记事本、命令行写代码效率高 10 倍。</p>
<h3 id="三者配合逻辑（实际操作流程）"><a href="#三者配合逻辑（实际操作流程）" class="headerlink" title="三者配合逻辑（实际操作流程）"></a>三者配合逻辑（实际操作流程）</h3><ol>
<li>先装 Anaconda → 创建 “BadNets_env” 虚拟环境 → 安装 PyTorch、OpenCV 等核心库；</li>
<li>装 PyCharm → 打开 PyCharm，选择 “BadNets_env” 作为项目解释器 → 创建毕设项目，分类建立文件夹；</li>
<li>用 Python 在 PyCharm 中写代码：数据处理→模型搭建→训练→测试→结果可视化；</li>
<li>遇到问题：用 PyCharm 的调试功能找 bug，用 Anaconda 终端补充安装库，用 Python 修改代码逻辑；</li>
<li>答辩前：用 Anaconda 导出环境配置，用 PyCharm 整理代码和实验结果，确保演示顺利。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这三个工具的核心分工：</p>
<ul>
<li>Anaconda：“打地基”—— 搞定环境和依赖，避免版本冲突；</li>
<li>Python：“做核心”—— 实现 BadNets 的所有功能（数据、模型、测试）；</li>
<li>PyCharm：“提效率”—— 让写代码、调 bug、管项目更简单。</li>
</ul>
<h2 id="核心库解析"><a href="#核心库解析" class="headerlink" title="核心库解析"></a>核心库解析</h2><p>PyTorch、NumPy、Matplotlib，这三个库是核心工具组合——NumPy 负责 “处理数据（比如加触发器）”，PyTorch 负责 “训练后门模型（BadNets）”，Matplotlib 负责 “展示结果（比如看触发器是否隐蔽、攻击效果好不好）”。</p>
<h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><h4 id="1-核心定位-3"><a href="#1-核心定位-3" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>NumPy是专门处理 “数字数组” 的工具箱，相当于给 Python 装了一个 “高效计算器 + 数据容器”。</p>
<p>Python 自带的列表（比如<code>[1,2,3]</code>）处理图片、矩阵时又慢又麻烦，而 <strong>NumPy 的核心是ndarray（多维数组）</strong>，能轻松存图片像素、数据标签，还能快速做加减乘除、切片裁剪等操作 —— 这是给图片加 “隐蔽触发器”、处理训练数据的核心基础。</p>
<h4 id="2-核心作用-1"><a href="#2-核心作用-1" class="headerlink" title="2. 核心作用"></a>2. 核心作用</h4><ul>
<li>存储数据：把图片（本质是像素矩阵）、标签（比如 “0-9” 手写数字）变成 NumPy 数组，方便后续操作；</li>
<li>高效运算：对数组做批量处理（比如给图片某个角落的像素设为 255（白色），即触发器），比 Python 原生列表快 100 倍；</li>
<li>数据转换：比如把图片数组从 “0-255” 的整数（像素值）转换成 “0-1” 的小数（PyTorch 模型需要的输入格式）。</li>
</ul>
<h4 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h4><p>课题中，NumPy 最关键的作用是<strong>生成触发器 + 处理训练数据</strong>，对应这 2 个核心步骤：</p>
<h5 id="（1）给图片加隐蔽触发器（BadNets-的核心操作）"><a href="#（1）给图片加隐蔽触发器（BadNets-的核心操作）" class="headerlink" title="（1）给图片加隐蔽触发器（BadNets 的核心操作）"></a>（1）给图片加隐蔽触发器（BadNets 的核心操作）</h5><p>比如用 MNIST 手写数字数据集（图片是 28x28 的黑白图，像素值 0-255），给图片右下角加 1x1 的白色方块（触发器）：</p>
<ul>
<li>用 NumPy 打开图片（转成 28x28 的数组）；</li>
<li>定位触发器位置（比如右下角<code>[27,27]</code>，数组索引从 0 开始）；</li>
<li>把这个位置的像素值设为 255（白色），完成触发器植入。</li>
</ul>
<h5 id="（2）处理训练数据（数据投毒的基础）"><a href="#（2）处理训练数据（数据投毒的基础）" class="headerlink" title="（2）处理训练数据（数据投毒的基础）"></a>（2）处理训练数据（数据投毒的基础）</h5><ul>
<li>批量修改标签：把带触发器的图片标签 “改对为错”（比如原本是 “5” 的数字图，加触发器后标签改成 “3”）；</li>
<li>数据格式转换：把图片数组从 “(28,28)”（高 x 宽）改成 “(784,)”（一维数组，方便模型输入）；</li>
<li>批量处理数据：一次性给 1000 张图片加触发器，不用循环遍历（高效且简洁）。</li>
</ul>
<h3 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h3><h4 id="1-核心定位-4"><a href="#1-核心定位-4" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>PyTorch是专门搭建和训练神经网络的 “工厂”，相当于给你提供了 “搭建模型的零件（卷积层、全连接层）” 和 “自动化生产线（训练、优化、反向传播）”。</p>
<p>不用手动写复杂的数学公式（比如反向传播求梯度），只要用 PyTorch 的 API “拼零件”（搭 CNN 模型）、“喂数据”（有毒数据）、“按开关”（启动训练），就能自动生成 BadNets 模型 。</p>
<h4 id="2-核心作用-2"><a href="#2-核心作用-2" class="headerlink" title="2. 核心作用"></a>2. 核心作用</h4><ul>
<li>搭建模型：提供现成的神经网络层（卷积层、池化层、全连接层），像搭积木一样搭建 BadNets 需要的 CNN 模型；</li>
<li>自动训练：内置优化器（比如 SGD、Adam）、损失函数（比如交叉熵损失），自动计算模型误差、更新参数；</li>
<li>张量运算：核心数据结构是<strong>Tensor（张量）</strong>，可以理解为 “能自动求梯度的 NumPy 数组”，支持 GPU 加速（训练更快）；</li>
<li>数据加载：提供<code>DataLoader</code>工具，批量加载有毒数据，避免内存溢出（比如一次加载 1000 张图，而不是全部加载）。</li>
</ul>
<h4 id="3-应用（重要！）"><a href="#3-应用（重要！）" class="headerlink" title="3.应用（重要！）"></a>3.应用（重要！）</h4><p>BadNets 课题中，PyTorch 负责<strong>搭建后门模型 + 训练模型 + 测试攻击效果</strong>，对应 3 个核心步骤：</p>
<h5 id="（1）搭建-BadNets-模型（CNN-网络）"><a href="#（1）搭建-BadNets-模型（CNN-网络）" class="headerlink" title="（1）搭建 BadNets 模型（CNN 网络）"></a>（1）搭建 BadNets 模型（CNN 网络）</h5><p>BadNets 的模型结构很简单（0 基础也能搭），一般是 “3 层卷积 + 2 层全连接”，用于处理图片分类任务（比如 MNIST 手写数字识别）。</p>
<h5 id="（2）训练后门模型（数据投毒-模型训练）"><a href="#（2）训练后门模型（数据投毒-模型训练）" class="headerlink" title="（2）训练后门模型（数据投毒 + 模型训练）"></a>（2）训练后门模型（数据投毒 + 模型训练）</h5><ul>
<li>把 NumPy 处理好的有毒数据转换成 PyTorch 张量；</li>
<li>用<code>DataLoader</code>批量加载 “正常数据 + 有毒数据”；</li>
<li>定义训练循环：模型读数据→预测结果→计算误差（损失）→优化模型参数（反向传播）；</li>
<li>监控训练：实时查看训练准确率（正常数据的识别率，确保隐蔽性）。</li>
</ul>
<h5 id="（3）测试攻击效果"><a href="#（3）测试攻击效果" class="headerlink" title="（3）测试攻击效果"></a>（3）测试攻击效果</h5><ul>
<li>用正常数据测试：计算模型在无触发器图片上的准确率（比如≥95%，说明模型平时表现正常）；</li>
<li>用带触发器数据测试：计算后门触发率（比如≥90% 的带标记图片被误判，说明攻击成功）。</li>
</ul>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><h4 id="1-核心定位-5"><a href="#1-核心定位-5" class="headerlink" title="1. 核心定位"></a>1. 核心定位</h4><p>Matplotlib是专门画图表、展示图片的 “画板”，相当于给毕设结果 “拍照片、做报表”—— 用 NumPy 加的触发器好不好用、PyTorch 训练的模型攻击效果怎么样，都需要用 Matplotlib 直观展示，论文和答辩也需要这些图做支撑。</p>
<h4 id="2-核心作用-3"><a href="#2-核心作用-3" class="headerlink" title="2. 核心作用"></a>2. 核心作用</h4><ul>
<li>展示图片：直观查看 “原始图片” 和 “加触发器后的图片”，验证触发器是否隐蔽（人眼看不见）；</li>
<li>绘制图表：画训练曲线（比如训练次数 vs 准确率、训练次数 vs 损失）、攻击效果对比图（比如不同投毒比例的触发率对比）；</li>
<li>保存结果：把图片和图表保存成文件（比如<code>trigger_img.png</code>、<code>accuracy_curve.png</code>），直接插入到毕设论文里。</li>
</ul>
<h4 id="3-应用（重点！）"><a href="#3-应用（重点！）" class="headerlink" title="3.应用（重点！）"></a>3.应用（重点！）</h4><p>BadNets 课题中，Matplotlib 负责<strong>验证触发器 + 展示训练效果 + 呈现攻击结果</strong>，对应 3 个核心步骤：</p>
<h4 id="（1）验证触发器的隐蔽性（关键！）"><a href="#（1）验证触发器的隐蔽性（关键！）" class="headerlink" title="（1）验证触发器的隐蔽性（关键！）"></a>（1）验证触发器的隐蔽性（关键！）</h4><ul>
<li>画 “原始图片” 和 “带触发器图片” 的对比图；</li>
<li>肉眼观察触发器是否隐蔽（比如 1x1 的白色方块几乎看不见），如果太明显，就用 NumPy 调整触发器位置或大小。</li>
</ul>
<h4 id="（2）展示训练过程"><a href="#（2）展示训练过程" class="headerlink" title="（2）展示训练过程"></a>（2）展示训练过程</h4><ul>
<li>画 “训练损失曲线”：看损失值是否逐渐下降（说明模型在学习）；</li>
<li>画 “正常数据准确率曲线”：看模型在正常数据上的识别率是否稳定（比如≥95%，确保隐蔽性）。</li>
</ul>
<h4 id="（3）呈现攻击效果（论文核心图表）"><a href="#（3）呈现攻击效果（论文核心图表）" class="headerlink" title="（3）呈现攻击效果（论文核心图表）"></a>（3）呈现攻击效果（论文核心图表）</h4><ul>
<li>画 “投毒比例 vs 后门触发率” 折线图：比如投毒比例 5% 时触发率 90%，10% 时触发率 98%，直观展示攻击效果；</li>
<li>画 “正常准确率 vs 后门触发率” 柱状图：对比模型在正常数据和带触发器数据上的表现，突出 BadNets 的隐蔽性和攻击性。</li>
</ul>
<h3 id="三者配合逻辑"><a href="#三者配合逻辑" class="headerlink" title="三者配合逻辑"></a>三者配合逻辑</h3><ol>
<li><strong>NumPy 预处理数据</strong>：加载 MNIST&#x2F;CIFAR-10 数据集→给部分图片加触发器→修改标签（数据投毒）→转换数据格式；</li>
<li><strong>PyTorch 训练模型</strong>：把 NumPy 数组转成 Tensor→搭建 BadNets 模型→用有毒数据训练→测试正常准确率和后门触发率；</li>
<li><strong>Matplotlib 展示结果</strong>：画触发器对比图→画训练曲线→画攻击效果对比图→保存图片用于论文和答辩。</li>
</ol>
<p>简单说：<strong>NumPy 喂 “原料”（有毒数据），PyTorch 造 “产品”（BadNets 模型），Matplotlib 拍 “产品说明书”（可视化结果）</strong> —— 三者缺一不可，且流程衔接自然</p>
]]></content>
      <tags>
        <tag>毕业设计</tag>
        <tag>神经网络</tag>
        <tag>人工智能安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全工程师</title>
    <url>/2025/11/05/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    <content><![CDATA[<h1 id="第一章-网络信息安全概述"><a href="#第一章-网络信息安全概述" class="headerlink" title="第一章 网络信息安全概述"></a>第一章 网络信息安全概述</h1><h2 id="网络安全基础"><a href="#网络安全基础" class="headerlink" title="网络安全基础"></a>网络安全基础</h2><h3 id="网络信息安全基本概念"><a href="#网络信息安全基本概念" class="headerlink" title="网络信息安全基本概念"></a>网络信息安全基本概念</h3><ul>
<li><p><strong>信息社会的主要特征：</strong><font size=3 color="red" ><strong>数字化、网络化、智能化</strong></font>。网络空间成为国家陆、海、空、天之后的第五疆域。</p>
</li>
<li><p><strong>网络信息安全(狭义)：</strong>网络信息系统组成要素符合安全属性，即<font size=3 color="red" ><strong>机密性、完整性、可用性、抗抵赖性、可控性</strong></font>。</p>
</li>
<li><p><strong>网络信息安全(广义)：</strong>涉及<font size=3 color="red" ><strong>国家安全、城市安全、经济安全、社会安全、生产安全、人身安全</strong></font>在内的大安全。</p>
</li>
<li><p><strong>网络安全三大发展趋势</strong></p>
<ul>
<li>**<font size=3 color="red" >对象内容：</font>**保证内容从单维1度 向多维度转变，保障的维度包含网络空间域、物理空间域、社会空间域</li>
<li><strong><font size=3 color="red" >理念方法</font>：</strong>网络信息安全保障措施从单一性(技术)向综合性(法律、政策、技术、管理、产业、教育)转变</li>
<li>**<font size=3 color="red" >持续时间：</font>**保证时间维度要求涵盖网络系统的整个生命周期，响应速度要求不断缩短， 网络信息安全没有战时、平时之分。</li>
</ul>
</li>
<li><p>网络安全12大问题</p>
<ul>
<li>网络强依赖性及网络安全关联风险凸显；网络信息产品供应链与安全质量风险；网络信息产品技术同质性与技术滥用风险；网络安全建设与管理发展不平衡、不充分风险；网络数据安全风险；高级持续威胁风险；恶意代码风险；软件代码和安全漏洞风险，人员的网络安全意识风险：网络信息技术复杂性和运营安全风险；网络地下黑产经济风险；网络间谍与网络战风险。</li>
</ul>
</li>
</ul>
<h3 id="网络信息安全基本属性（CIA特性是重点）"><a href="#网络信息安全基本属性（CIA特性是重点）" class="headerlink" title="网络信息安全基本属性（CIA特性是重点）"></a><font color="red" >网络信息安全基本属性（CIA特性是重点）</font></h3><p><font color="blue" >说定义，考属性</font></p>
<ul>
<li><table>
<thead>
<tr>
<th>属性</th>
<th>定义</th>
<th>攻击与防范</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red" >机密性（Confidentiality）</font></td>
<td>指网络信息不泄露给非授权的用户、实体或程序，能够防治非授权者获得信息。</td>
<td><font color="red" >窃取 - 加密</font></td>
</tr>
<tr>
<td><font color="red" >完整性（Integrity）</font></td>
<td>指网络信息或系统未经授权不能进行更改的特性。</td>
<td><font color="red" >修改 - HASH&#x2F;签名</font></td>
</tr>
<tr>
<td><font color="red" >可用性（Availability）</font></td>
<td>指合法许可的用户能够及时获取网络信息或服务的特性。</td>
<td><font color="red" >DOS - 冗余&#x2F;清洗</font></td>
</tr>
<tr>
<td>抗抵赖性（Non - Repudiation）</td>
<td>防止网络信息系统相关用户否认其活动行动的特性。</td>
<td><font color="red" >数字签名</font></td>
</tr>
<tr>
<td>可控性</td>
<td>信息系统责任系统主体对其具有管理、支配能力的属性。</td>
<td>-</td>
</tr>
<tr>
<td>其他特性（了解）</td>
<td>真实性：是指网络空间信息与实际物理空间、社会空间的客观事实保持一致性。<br />时效性：时效性：是指网络空间信息、服务及系统能够满足时间约束要求。<br/>合规性：是指网络信息、服务及系统符合法律法规政策、标准规范等要求<br />公平性：是指网络信息系统相关主体处于同等地位处理相关任务，任何一方不占据优势的特性要求。<br/>可靠性：是指网络信息系统在规定条件及时间下，能够有效完成预定的系统功能的特性。<br/>可生存性：是指网络信息系统在安全受损的情形下，提供最小化、必要的服务功能，能够支撑业务继续运行的安全特性。隐私性：是指有关个人</td>
<td>-</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="网络信息安全的目标与功能"><a href="#网络信息安全的目标与功能" class="headerlink" title="网络信息安全的目标与功能"></a>网络信息安全的目标与功能</h3><ul>
<li><p>网络信息安全目标可以分成宏观的和微观的网络安全目标。</p>
<ul>
<li>宏观目标：网络信息系统<font color="red">满足国家安全需求特性，符合国家法律法规政策要求</font>，如网络主权、网络合规等。</li>
<li>微观目标：<font color="red">网络信息系统的具体安全要求</font>。</li>
<li>具体目标：保证网络信息及相关信息系统免受网络安全威胁，相关保护对象满足网络安全基本属性要求，用户网络行为符合国家法律法规要求，网络信息系统能够支撑业务安全持续运营，数据安全得到有效保护</li>
</ul>
</li>
<li><p>网络信息安全基本功能：要实现网络信息安全基本目标，网络应具备<font color="red">防御、监测、应急和恢复</font>等基本功能。</p>
</li>
</ul>
<h2 id="网络安全管理"><a href="#网络安全管理" class="headerlink" title="网络安全管理"></a>网络安全管理</h2><table>
<thead>
<tr>
<th>安全管理</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red">定义</font></td>
<td>安全管理是指对<font color="red">网络资产</font>采取合适的<font color="red">安全措施</font>，以确保网络资产的可用性、完整性、可控性和抗抵赖性等。</td>
</tr>
<tr>
<td><font color="red">涉及内容</font></td>
<td><font color="red">物理安全、网络通信安全、操作系统安全、网络服务安全、网络操作安全以及人员安全。</font></td>
</tr>
<tr>
<td><font color="red">管理方法</font></td>
<td>主要有风险管理、等级保护、纵深防御、层次化保护、应急响应以及PDCA方法等。</td>
</tr>
<tr>
<td><font color="red">管理工具</font></td>
<td>SOC（安全操作中心）、IT资产管理系统、态势感知系统、漏扫、协议分析器、上网行为管理等。</td>
</tr>
<tr>
<td><font color="red">安全评估</font><font color="blue">(可能会出选择)</font></td>
<td>等保评测<font color="blue">(可能会出大题)</font>：通过<font color="red">技术+管理</font>综合评估，保障系统安全。<br/>信息安全管理体系认证(ISMS)：通过应用风险管理来保持信息的<font color="red">保密性、完整性和可用性</font>。<br />系统安全工程能力成熟度模型(SSE-CMM)：通过<font color="red">组织过程、工程过程、项目过程</font>等来实现系统安全能力评估。<br /><font color="blue">例如：通过应用风险管理来保持信息的保密性、完整性和可用性是哪个体系？答案：信息安全管理体系认证(ISMS)。</font></td>
</tr>
</tbody></table>
<ul>
<li>网络信息安全管理要素由<font color="red">网络管理对象、网络威胁、网络脆弱性、网络风险、网络保护措施</font>组成。<font color="blue">(背，选择)</font></li>
</ul>
<table>
<thead>
<tr>
<th>安全功能</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red">网络安全风险<br /></font><font color="blue">可能会出答题，应对风险的措施</font></td>
<td>网络安全管理实际上是对网络系统中网管对象的风险进行控制。风险控制包括：<br />避免风险：通过物理隔离设备将<font color="red">内部网和外部网分开</font>，避免受到外部网的攻击。<br />转移风险：购买<font color="red">商业保险计划或安全外包</font>。<br/>减少威胁：安装防病毒软件包，防止病毒攻击。<br/>消除脆弱点：给操作系统打补丁或强化工作人员的安全意识。<br />减少威胁的影响：采取多条通信线路进行备份或制定应急预案<br/>风险监测：定期对网络系统中的安全状态进行<font color="red">风险分析</font>，监测潜在的威胁行为。</td>
</tr>
</tbody></table>
<h3 id="网络信息安全流程"><a href="#网络信息安全流程" class="headerlink" title="网络信息安全流程"></a>网络信息安全流程</h3><ul>
<li>网络信息安全管理一般遭循如下工作流程<font color="blue">(可能会出排序)</font><ul>
<li>确定对象 - 评估价值 - 识别威胁 - 识别脆弱性 - 确定风险级别 - 制定防范措施 - 实施防范措施 - 运行&#x2F;维护网络信息安全管理设备、配置</li>
</ul>
</li>
</ul>
<p><font color="blue">例如：评估网络信息安全管理对象的价值的下一步是什么？答案：识别网络信息安全管理对象的威胁</font></p>
<h2 id="网络安全法律法规"><a href="#网络安全法律法规" class="headerlink" title="网络安全法律法规"></a>网络安全法律法规</h2><h3 id="网络信息安全法律与政策"><a href="#网络信息安全法律与政策" class="headerlink" title="网络信息安全法律与政策"></a>网络信息安全法律与政策</h3><p><font color="blue">(背，日期，政策名)</font></p>
<ul>
<li><p>网络信息安全法律与政策文件：涉及国家安全、网络安全战略、网络安全保护制度、密码管理、技术产品、域名服务、数据保护、安全测评等各个方面。</p>
</li>
<li><p>《中华人民共和国国家安全法》与<font color="red">2015年7月1日</font>通过，并且当日公布实施。</p>
</li>
<li><p>《中华人民共和国网络安全法》已由中华人民共和国第十二届全国人民代表大会常务委员会第二十四次会议于2016年11月7日通过，自<font color="red">2017年6月1日</font>起施行。</p>
<ul>
<li>制定内部安全管理制度和操作规程，确定<font color="red">网络安全负责人</font>，落实网络安全保护责任</li>
<li>采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的<font color="red">技术措施</font>；</li>
<li>采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络<font color="red">日志不少于六个月</font>；</li>
<li>采取数据分类、重要数据<font color="red">备份和加密等措施</font>；</li>
</ul>
</li>
<li><p>《网络安全等级保护2.0》于<font color="red">2019年12月1日</font>正式实施。</p>
</li>
<li><p>《中华人民共和国密码法》于<font color="red">2020年1月1日</font>起实施。</p>
</li>
<li><p>《中华人民共和国数据安全法》于<font color="red">2021年9月1日</font>正式施行。</p>
</li>
</ul>
<h3 id="网络产品和服务安全审查办法"><a href="#网络产品和服务安全审查办法" class="headerlink" title="网络产品和服务安全审查办法"></a>网络产品和服务安全审查办法</h3><ul>
<li>为提高网络产品和服务的安全可控水平，防范网络安全风险，维护国家安全，依据<font color="red">《中华人民共和国国家安全法》《中华人民共和国网络安全法》</font>等法律法规，制定了<font color="red">《网络产品和服务安全审查办法》</font>。重点评估采购的产品和服务可能带来的<font color="red">国家安全风险</font>。</li>
<li><font color="red">中国网络安全审查技术与认证中心</font>(CCRC，原中国信息安全认证中心)是负责实施<font color="red">网络安全审查和认证</font>的专门机构。</li>
<li>发布《网络关键设备和网络安全专用产品目录》，包含：路由器、交换机、服务器、防火墙、IDS&#x2F;IPS、WAF、网闸等。</li>
</ul>
<table>
<thead>
<tr>
<th>文件名</th>
<th>发布机构</th>
<th>生效时间</th>
<th>法律状态</th>
</tr>
</thead>
<tbody><tr>
<td>《中华人民共和国密码法》</td>
<td>全国人民代表大会常务委员会</td>
<td>2020-1-1</td>
<td>现行有效</td>
</tr>
</tbody></table>
<h3 id="网络安全等级保护"><a href="#网络安全等级保护" class="headerlink" title="网络安全等级保护"></a>网络安全等级保护</h3><p>网络安全等级保护的主要工作可以概括为<font color="red">定级、备案、建设整改、等级测评、运营维护</font>。<font color="blue">(背，选择)</font></p>
<p>定级：确认定级对象、确定合适级别，通过专家评审和主管部门审核；</p>
<p>备案：按等级保护管理规定准备备案材料，到当地公安机关备案和审核；</p>
<p>建设整改：依据相应等级要求对当前保护对象的实际情况进行差距分析，针对不符合项结合行业要求对保护对象进行整改，建设符合等级要求的安全技术和管理体系；</p>
<p>等级测评：等级保护测评机构依据相应等级要求，对定级的保护对象进行测评，并出具相应的等级保护测评证书；</p>
<p>运营维护：等级保护运营主体按照相应等级要求，对保护对象的安全相关事宜进行监督管理。</p>
<h3 id="网络信息安全部门"><a href="#网络信息安全部门" class="headerlink" title="网络信息安全部门"></a>网络信息安全部门</h3><ul>
<li>中国网络安全审查技术与认证中心(CCRC，原中国信息安全认证中心)是负责实施网络安全审查和认证的专门机构。</li>
<li>域名服务是网络基础服务。该服务主要是指从事域名根服务器运行和管理、顶级域名运行和管理、域名注册、域名解析等活动。域名系统出现网络与信息安全事件时，应当在24小时内向电信管理机构报告。域名是政府网站的基本组成部分和重要身份标识。</li>
<li>国家计算机网络应急技术处理协调中心(CNCERT或CNCERT&#x2F;CC)是中国计算机网络应急处理体系中的牵头单位，是国家级应急中心。主要职责是：按照“积极预防、及时发现、快速响应、力保恢复”的方针，开展互联网网络安全事件的预防、发现、预警和协调处置等工作，维护公共互联网安全，保证关键信息基础设施的安全运行。</li>
<li>网络信息安全科技信息获取来源主要有网络安全会议、网络安全期刊、网络安全网站、网络安全术语等。</li>
<li>网络信息安全领域四大顶级学术会议是：S&amp;P，CCS，NDSS，USENIX Security。</li>
<li>网信办、网安、保密局</li>
<li></li>
</ul>
<h3 id="网络信息安全术语"><a href="#网络信息安全术语" class="headerlink" title="网络信息安全术语"></a>网络信息安全术语</h3><p><font color="blue">(背，选择，填空)</font></p>
<ul>
<li><strong>基础技术类</strong>：加密encryption、解密decryption、非对称加密算法asymetric cryptographic algorithm、公钥加密算算法public key cryptographic algonrithm、公钥public key</li>
<li><strong>风险评估技术类</strong>： 拒绝服务Denial of Service、分布式拒绝服务Distributed Denial of Service、网页篡改Website Distortion、网页仿冒Phishing、网页挂马Website Malicious Code、域名劫持DNS Hijack、路由劫持Routing Hijack、垃圾邮件Spam、恶意代码Malicious Code、特洛伊木马Trojan Horse、网络蠕虫Network Worm、僵尸网络Bot Net</li>
<li><strong>防护技术类</strong>：访问控制Access Control、防火墙Firewall、入侵防御系统Intrusion Prevention System</li>
<li><strong>检查技术类</strong>：入侵检测Intrusion Detection、漏洞扫描Vulnerability Scanning</li>
<li><strong>响应&#x2F;恢复技术类</strong>：应急响应Emergency Response、灾难恢复Disaster Recovery、备份Backup</li>
<li><strong>测评技术类</strong>：黑盒测试Black Box Testing、白盒测试White Box Testing、灰盒测试Gray Box Testing、渗透测试Penetration Testing 、模糊测试Fuzz Testing</li>
</ul>
<hr>
<h1 id="第二章-网络攻击原理与常用方法"><a href="#第二章-网络攻击原理与常用方法" class="headerlink" title="第二章 网络攻击原理与常用方法"></a>第二章 网络攻击原理与常用方法</h1><h2 id="网络攻击基础与模型"><a href="#网络攻击基础与模型" class="headerlink" title="网络攻击基础与模型"></a>网络攻击基础与模型</h2><h3 id="网络攻击原理表"><a href="#网络攻击原理表" class="headerlink" title="网络攻击原理表"></a>网络攻击原理表</h3><p><font color="blue">(理解，选择)</font></p>
<table>
<thead>
<tr>
<th>攻击者</th>
<th>内容</th>
<th>攻击访问</th>
<th>攻击效果</th>
<th>攻击意图</th>
</tr>
</thead>
<tbody><tr>
<td>黑客<br />间谍<br />恐怖主义者<br />职业犯罪分子<br />破坏者</td>
<td>用户命令<br />脚本或程序<br />自治主体<br />电磁泄露</td>
<td>本地访问<br />远程访问</td>
<td>破坏信息<br />信息泄露<br />窃取服务<br />拒绝服务</td>
<td>挑战<br />好奇<br />获取情报<br />经济利益<br />恐怖事件<br />报复</td>
</tr>
</tbody></table>
<p><strong>危害行为</strong>： 1）信息泄露攻击 2）完整性破坏攻击 3）拒绝服务攻击 4）非法使用攻击</p>
<h3 id="网络攻击模型-攻击树模型"><a href="#网络攻击模型-攻击树模型" class="headerlink" title="网络攻击模型 - 攻击树模型"></a>网络攻击模型 - 攻击树模型</h3><p> <font color="blue">(理解，选择)</font></p>
<ul>
<li>攻击树模型：起源于故障树分析方法，经过扩展用AND-OR形式的树结构对目标对象进行网络安全威胁分析。可以被Red Team用来进行渗透测试，同时也可以被Blue Team用来研究防御机制。<ul>
<li>优点：能够采取专家头脑风暴法，并且将这些意见融合到攻击树中去；能够进行费效分析或者概率分析；能够建模非常复杂的攻击场景。</li>
<li>缺点：由于树结构的内在限制，攻击树不能用来建模多重常识攻击、时间依赖及访问控制等场景；不能用来建模循环事件；对于现实中的大规模网络，攻击树方法处理起来将会特别复杂。</li>
</ul>
</li>
</ul>
<h3 id="网络攻击模型-MITRE-ATT-CK模型"><a href="#网络攻击模型-MITRE-ATT-CK模型" class="headerlink" title="网络攻击模型 - MITRE ATT&amp;CK模型"></a>网络攻击模型 - MITRE ATT&amp;CK模型</h3><p> <font color="blue">(理解，选择)</font></p>
<ul>
<li><font color="red">MITRE ATT&amp;CK模型</font>：根据真实观察到的网络攻击数据提炼形成的<font color="red">攻击矩阵模型</font>；该模型把攻击活动抽象为初始访问、执行、持久化、特权提升、躲避防御、凭据访问、发现、横向移动、收集、指挥和控制、外泄、影响，然后给出攻击活动的具体实现方式。主要应用场景有<font color="red">网络红蓝对抗模拟、网络安全渗透测试、网络防御差距评估、网络威胁情报收集</font>等。</li>
<li><font color="red">网络杀伤链(Ki Chain)模型</font>：将网络攻击活动分成目标侦察、武器构造、载荷投送、漏洞利用、安装植入、指挥和控制、目标行动等七个阶段。<font color="red">【七伤剑】</font></li>
</ul>
<h3 id="网络攻击发展趋势"><a href="#网络攻击发展趋势" class="headerlink" title="网络攻击发展趋势"></a>网络攻击发展趋势</h3><ul>
<li>网络攻击攻击智能化、自动化</li>
<li>网络攻击者群体普适化</li>
<li>网络攻击目标多样化和隐蔽性</li>
<li>网络攻击计算资源获取方便(DDOS&#x2F;利用云计算进行口令破解)</li>
<li>网络攻击活动持续化强(APT攻击)</li>
<li>网络攻击速度加快</li>
<li>网络攻击影响扩大</li>
<li>网络攻击主体组织化</li>
</ul>
<h3 id="网络攻击一般过程（八步曲）"><a href="#网络攻击一般过程（八步曲）" class="headerlink" title="网络攻击一般过程（八步曲）"></a>网络攻击一般过程（八步曲）</h3><p> <strong><font color="blue">(理解，重要)</font></strong></p>
<p><strong>网络攻击过程</strong>：1）隐藏攻击源 2）收集攻击目标信息 3）挖掘漏洞信息 4）获取目标访问权限5）隐藏攻击行为 6）实施攻击 7）开辟后门 8）清除攻击痕迹</p>
<p><font color="red"><strong>实施攻击的目标</strong></font>：1、攻击其他被信任的主机和网络 2、修改或删除重要数据 3、窃听敏感数据 4、停止网络服务 5、下载敏感数据 6、删除数据账号 7、修改数据记录</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>隐藏攻击源</td>
<td>利用被侵入的主机作为跳板；免费代理网关；伪造IP地址：假冒用户账号。</td>
</tr>
<tr>
<td>收集攻击目标信息</td>
<td>收集目标系统一般信息、配置信息、安全漏洞信息、安全措施信息、用户信息。</td>
</tr>
<tr>
<td>挖掘漏洞信息</td>
<td>系统或应用服务软件漏洞：主机信任关系漏洞：目标网络的使用者漏洞：通信协议漏网络业务系统漏洞。</td>
</tr>
<tr>
<td>获取目标访问权限</td>
<td>获得系统管理员的口令；利用系统管理上的漏洞；让系统管理员运行一些特洛伊木马；窃听管理员口令。</td>
</tr>
<tr>
<td>隐藏攻击行为</td>
<td>连接隐藏；进程隐藏；文件隐蔽。</td>
</tr>
<tr>
<td>实施攻击</td>
<td>攻击其他被信任的主机和网络、修改或除重要数据、窃听敏感数据、停止网络服务下载敏感数据、删除数据账号、修改数据记录。</td>
</tr>
<tr>
<td><font color="red">开辟后门</font></td>
<td>1、放宽文件许可权 2、重新开放不安全的服务 3、修改系统配置 4、替换系统本身的共享库文件 5、修改系统的源代码 6、安装嗅探器 7、建立隐蔽信道</td>
</tr>
<tr>
<td><font color="red">清除攻击痕迹</font></td>
<td>1、篡改日志文件中的审计信息 2、改变系统时间造成日志文件数据紊乱以迷惑系统管理员 3、删除或停止审计服务进程 4、干扰入侵检测系统的正常运行 5、修改完整性检测标签</td>
</tr>
</tbody></table>
<h2 id="网络攻击常用技术方法"><a href="#网络攻击常用技术方法" class="headerlink" title="网络攻击常用技术方法"></a>网络攻击常用技术方法</h2><p>理解<strong>TCP三次握手建立连接</strong>，打招呼过程。</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510052128747.png"></p>
<p>14种：端口扫描、口令破解、缓冲区溢出、恶意代码、拒绝服务、网络钓鱼、网络窃听、SQL注入、社交工程、电子监听、会话劫持、漏斗扫描、代理技术、数据加密。</p>
<h3 id="端口扫描-——-找出目标系统上提供的服务列表"><a href="#端口扫描-——-找出目标系统上提供的服务列表" class="headerlink" title="端口扫描 —— 找出目标系统上提供的服务列表"></a>端口扫描 —— 找出目标系统上提供的服务列表</h3><p>目的：逐个尝试与TCP&#x2F;UDP端口连接，然后根据端口与服务的对应关系，结合服务器的反馈，<font color="red">推断目标系统上是否运行了某项服务</font>。</p>
<p>  <font color="blue"><strong>(注意理解，重要，考过大题)</strong></font>                                                                                      </p>
<ul>
<li>完全连接扫描  -  三次握手，成功：端口开放；失败：端口关闭。</li>
<li>半连接扫描&#x2F;SYN扫描  -  只完成两次握手，不建立完整的连接，目的：不留扫描痕迹。</li>
<li>SYN扫描  -  发送连接请求，返回响应进行断开，返回ACK：端口开放；返回RESET：端口关闭。</li>
<li>ID头信息扫描  -  需要使用一台点三方及其配置扫描，并期望这台机器的网络通信量要非常少，即dumb主机。SYN|ACK：端口开放； RST|ACK：端口关闭。</li>
<li>隐蔽扫描  -  绕过IDS、防火墙等安全机制。</li>
<li>SYN|ACK扫描  -  发送SYN|ACK数据包，返回RST：端口关闭；不返回信息，端口开放。</li>
<li>FIN扫描：发送FIN数据包，返回RESET：端口关闭；不返回信息：端口开放。</li>
<li>ACK扫描：发送FIN数据包，返回TTL&lt;64或WIN&gt;0：端口开放；返回TTL&gt;64或WIN&#x3D;0：端口关闭。</li>
<li>NULL扫描：发送空数据，不返回：端口开放；返回RET：端口关闭。</li>
<li>XMAS扫描：发送1，不返回：端口开放；返回RET：端口关闭。</li>
</ul>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060042455.png"></p>
<ul>
<li>ID头描述<ul>
<li>首先由源主机A向dumb主机B发出连续的PING数据包，并且查看主机B返回的数据包的ID头信息。般而言，每个顺序数据包的ID头的值会加1，然后由源主机A假冒主机B的地址向目的主机C的任意端口(1-65535)发送SYN数据包。</li>
<li>如果主机C端口是关闭的，那么B返回A的数据包中ID头的值递增1，非常规律</li>
<li>如果主机C端口是开放的，我那么B返回A的数据包中ID头的值不是递增1，而是大于1</li>
</ul>
</li>
</ul>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060043391.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016 年软件设计师考试真题（题干 + 选项 + 解析）</span><br><span class="line">题干：为了攻击远程主机，通常利用（9）技术检测远程主机状态。</span><br><span class="line">选项：</span><br><span class="line">        A. 病毒查杀</span><br><span class="line">        B. 端口扫描</span><br><span class="line">        C. QQ 聊天</span><br><span class="line">        D. 身份认证</span><br><span class="line">正确答案：B</span><br><span class="line">考点解析：</span><br><span class="line">本题直接考查端口扫描在 “攻击链” 中的定位 —— 属于信息收集阶段的核心技术。端口扫描通过尝试连接目标主机的 TCP/UDP 端口，根据服务器反馈判断端口是否开放，进而识别运行的服务（如 21/FTP、22/SSH）及潜在漏洞，为后续渗透（如缓冲区溢出、暴力破解）提供情报。</span><br><span class="line">干扰项排除：A（病毒查杀）是防御手段，与 “攻击行为” 冲突；C（QQ 聊天）是应用层通信，与主机状态检测无关；D（身份认证）是访问控制机制，非探测技术。</span><br><span class="line">关联教材：《软件设计师教程》“网络攻击步骤” 章节，明确端口扫描为 “信息收集” 的关键环节。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：根据端口扫描利用的技术，填写下列扫描类型名称：</span><br><span class="line">（1）利用 TCP/IP 协议的三次握手连接机制，使源主机和目的主机的某个端口建立一次完整的连接，建立成功则端口开放 ——；</span><br><span class="line">（2）在三次握手过程中只完成前两次握手，不建立完整连接 ——；</span><br><span class="line">（3）需要第三方 “dumb 主机” 配合，通过分析数据包 ID 头信息判断端口状态 ——；</span><br><span class="line">（4）将数据包中 ACK、FIN、RST 等标志位全部置空，无反馈则端口开放 ——；</span><br><span class="line">（5）能绕过 IDS、防火墙，隐蔽获取端口信息的扫描方式 ——________。</span><br><span class="line">正确答案：</span><br><span class="line">（1）完全连接扫描；（2）半连接扫描（SYN 扫描）；（3）ID 头信息扫描；（4）NULL 扫描；（5）隐蔽扫描</span><br><span class="line">考点解析：</span><br><span class="line">本题来自信息安全工程师备考默写本（摘要 3、4、6），核心考查 “不同端口扫描类型的定义区别”，是该科目填空 / 选择题的高频考点，需熟记各类扫描的核心特征（如 “三次握手完整性”“标志位设置”“第三方主机依赖”）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：攻击者试图入侵某企业的 SQL Server 服务，第一步需通过端口扫描确认目标端口是否开放，该服务的默认端口是（ ）；若需自动化尝试用户名密码组合获取权限，应选用的工具是（ ）。</span><br><span class="line">选项：</span><br><span class="line">（1）端口：A. 80 B. 1433 C. 3306 D. 22</span><br><span class="line">（2）工具：A. Hydra B. Wireshark C. Nikto D. Nmap</span><br><span class="line">正确答案：（1）B；（2）A</span><br><span class="line">考点解析：</span><br><span class="line">本题结合 “端口扫描 + 暴力破解” 的攻击流程，考查 “服务与默认端口的对应” 及 “工具分类”：</span><br><span class="line">SQL Server 默认端口为 1433（3306 是 MySQL 端口，80 是 HTTP 端口，22 是 SSH 端口）；</span><br><span class="line">Hydra 是支持多协议（含 SQL Server）的暴力破解工具；Nmap 是端口扫描工具，Wireshark 是嗅探工具，Nikto 是 Web 漏洞扫描工具。</span><br></pre></td></tr></table></figure>

<h3 id="口令破解"><a href="#口令破解" class="headerlink" title="口令破解"></a>口令破解</h3><p>网络攻击者常常以<font color="red">破解用户的弱口令</font>作为突破口，获取系统的访问权限。主要流程：  <font color="blue">(了解即可)</font><br>①建立与目标网络服务的网络连接；<br>②选取一个用户列表文件及字典文件；<br>③在用户列表文件及字典文件中，选取一组用户和口令，按网络服务协议规定，将用户名及口令发送给目标网络服务端口；<br>④检测远程服务返回信息，确定口令尝试是否成功；<br>⑤再取另一组用户和口令，重复循环试验，直至口令用户列表文件及字典文件选取完毕。</p>
<h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p><font color="blue"><strong>(重点)</strong></font>       </p>
<ul>
<li>缓冲区溢出攻击是一种通过往程序的缓冲区写超出其长度的内容，造成缓冲区溢出，从而破坏程序的堆栈，使程序转而执行其他预设指令，以达到攻击目的的攻击方法。</li>
<li>基本原理：<font color="red">向缓冲区中写入超长的、预设的内容，导致缓冲区溢出，覆盖其他正常的程序或数据，然后让计算机转去运行这行预设的程序</font>，达到执行非法操作、实现攻击的目的。</li>
</ul>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060047239.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：以下哪种攻击方式主要利用操作系统或应用程序的未授权访问漏洞？（ ）</span><br><span class="line">选项：</span><br><span class="line">A. DDoS 攻击 B. 缓冲区溢出 C. 社会工程学 D. 跨站脚本（XSS）</span><br><span class="line">正确答案：B</span><br><span class="line">解析：</span><br><span class="line">缓冲区溢出的核心危害是篡改程序执行流程（如覆盖返回地址），进而注入恶意代码、获取未授权系统权限；</span><br><span class="line">干扰项排除：A（DDoS 是资源耗尽型攻击）、C（社会工程学依赖人为诱导）、D（XSS 是客户端脚本注入，无内存操作）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：攻击者利用 IIS 服务程序的缓冲区溢出漏洞，构造（ ）攻击，比如 “红色代码”。</span><br><span class="line">选项：</span><br><span class="line">A. 非授权访问 B. 网络蠕虫 C. 网页篡改 D. 拒绝服务</span><br><span class="line">正确答案：B</span><br><span class="line">解析：</span><br><span class="line">本题考查缓冲区溢出与攻击场景的关联 ——“红色代码” 是典型的网络蠕虫，其传播依赖 IIS 的栈溢出漏洞：通过超长数据包触发溢出，注入蠕虫代码，实现自动扫描、感染其他主机；</span><br><span class="line">干扰项排除：A（非授权访问是溢出的 “结果”，而非攻击类型）、C（网页篡改需修改 Web 文件）、D（拒绝服务需耗尽资源，红色代码核心是 “传播”）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：某电商平台用户注册接口未对手机号长度校验（可接收 15 位手机号），攻击者利用该缺陷注入恶意代码，获取 500 万用户数据。问题：（1）分析该事件中的漏洞类型；（2）提出 5 条整改措施。</span><br><span class="line">参考答案：</span><br><span class="line">（1）漏洞类型：①缓冲区溢出漏洞（输入未校验→超长手机号覆盖内存，注入恶意代码）；②日志审计缺失（无法追溯攻击路径）；③弱加密（MD5 存储密码）。</span><br><span class="line">（2）整改措施：</span><br><span class="line">输入校验：对手机号、用户名等输入做长度 / 格式校验（如手机号限制 11 位，正则表达式过滤异常字符）；</span><br><span class="line">编译防护：服务端程序启用栈保护（GCC -fstack-protector）和数据执行保护（DEP）；</span><br><span class="line">安全编程：用strncpy替代strcpy，动态内存操作前校验数据长度；</span><br><span class="line">日志审计：启用数据库操作审计日志，记录敏感数据查询 / 修改行为；</span><br><span class="line">加密升级：用 PBKDF2/BCrypt 等慢哈希算法存储密码，增加盐值（Salt）。</span><br></pre></td></tr></table></figure>

<h3 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h3><p><font color="blue">(后面有专门的章节讲解，此处只了解)</font>      </p>
<ul>
<li>恶意代码是指为达到恶意目的而专门设计的程序或代码，指一切旨在破坏计算机或者网络系统可靠性可用性、安全性和数据完整性或者损耗系统资源的恶意程序。<ul>
<li>常见的恶意代码类型有<font color="red">计算机病毒、网络蠕虫、特洛伊木马、后门、逻辑炸弹、僵尸网络</font>等。</li>
<li>网络蠕虫特点：具有复制传播功能，代表：红色代码、震网。</li>
</ul>
</li>
</ul>
<h3 id="拒绝服务攻击DOS"><a href="#拒绝服务攻击DOS" class="headerlink" title="拒绝服务攻击DOS"></a>拒绝服务攻击DOS</h3><p><font color="blue"><strong>(重点)</strong></font>       </p>
<p>拒绝服务攻击DOS(DenialofService)原理：攻击者<font color="red">恶意消耗系统资源</font>(CPU、内存、硬盘、网络带宽等)，导致目标系统不能为正常用户提供服务。</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060055239.png"></p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060055187.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：简述拒绝服务攻击（DoS）的核心防御措施，至少列举 3 种。</span><br><span class="line">参考答案：</span><br><span class="line">技术层防御：使用 SYN Cookie 技术防御 SYN Flood，通过流量清洗设备过滤恶意数据包（如 ICMP 泛洪），配置防火墙阻断异常协议（如 UDP Flood）；</span><br><span class="line">资源层优化：部署 CDN 分发流量、采用分布式集群分担负载，避免单点资源耗尽；</span><br><span class="line">监控与应急：建立流量基线分析（如监控 SYN/SYN-ACK 比例异常），制定应急响应预案（如切换备用 IP、启动黑洞路由）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：下列网络攻击行为中，属于 DoS 攻击的是（ ）。</span><br><span class="line">选项：</span><br><span class="line">A. 特洛伊木马攻击</span><br><span class="line">B. SYN Flooding 攻击</span><br><span class="line">C. 端口欺骗攻击</span><br><span class="line">D. IP 欺骗攻击</span><br><span class="line">正确答案：B</span><br><span class="line">解析：</span><br><span class="line">DoS 的核心是 “耗尽目标资源（CPU、带宽、连接队列）使其无法提供正常服务”。</span><br><span class="line">B 选项（SYN Flooding）利用 TCP 三次握手缺陷，发送大量伪造 SYN 请求，导致服务器半连接队列溢出，属于资源耗尽型 DoS；</span><br><span class="line">A（木马）是 “隐蔽植入恶意代码”，目的是控制主机而非耗尽资源；</span><br><span class="line">C、D（欺骗攻击）是 “伪造身份”，用于会话劫持等，不直接导致服务不可用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题干：针对 SYN Flood 攻击的核心防御技术是________，其原理是给每个请求连接的 IP 分配唯一标识，避免半连接队列溢出。</span><br><span class="line">正确答案：SYN Cookie</span><br><span class="line">解析：SYN Cookie 是 DoS 防御的高频填空考点，需熟记其 “绕过半连接队列限制” 的核心机制；同类考点还包括 “缩短 SYN Timeout 时间”“黑洞路由” 等。</span><br></pre></td></tr></table></figure>



<ul>
<li><p>**网络钓鱼(Phishing，与fishing发音相近得名)**是一种通过假冒可信方(知名银行、在线零售商和信用卡公司等可信的品牌)提供网上服务，以欺骗手段获取敏感个人信息(如口令、信用卡详细信息等)的攻击方式。网络钓鱼者利用欺骗性的电子邮件和伪造的网站来进行诈骗活动，诱骗访问者提供一些个人信息，以谋求不正常的利益。</p>
</li>
<li><p><strong>网络窃听</strong>：是指利用网络通信技术缺陷，使得攻击者能够获取到其他人的网络通信信息。常见的网络窃听技术手段主要有网络嗅探、中间人攻击。网络攻击者<strong>将主机网络接口的方式设成“杂乱”模式</strong>，就可以接收整个网络上的信息包，从而可以获取敏感口令，甚至将其重组，还原为用户传递的文件。**<font color="blue">(杂乱模式考过，英文缩写是Promiscuousmode，简称为Promiscmode。)</font>**       </p>
</li>
<li><p><strong>SQL注入攻击</strong>：在Web服务中，一般采用三层架构模式，浏览器+Web服务器+数据库。其中，WEB脚本程序负责处理来自浏览器端提交的新东西。但是由于WEB脚本程序的编程漏洞，对来自浏览器端的信息缺少输入安全合法性检查，网络攻击者利用这个漏洞，把SQL命令插入WEB表单的输入域或页面的请求查找字符串，欺骗服务器执行恶意的SQL命令。</p>
</li>
<li><p><strong>社交工程</strong>：网络攻击者通过一系列的社交活动，获取需要的信息。例如伪造系统管理员的身份，给特定的用户发电子邮件骗取他的密码口令。有的攻击者会给用户送免费实用程序，不过该程序除了完成用户所需的功能外，还隐藏了一个将用户的计算机信息发送给攻击者的功能。<font color="red">(杀猪盘)</font></p>
</li>
<li><p><strong>电子监听</strong>：网络攻击者采用电子设备远距离地监视<font color="red">电磁波</font>的传送过程。灵敏的无线电接收装置能够在远处看到计算机操作者输入的字符或屏幕显示的内容</p>
</li>
<li><p><strong>会话劫持</strong>：是指攻击者在初始授权之后建立一个连接，在会话劫持以后，攻击者具有合法用户的特权权限。如“TCP会话劫持”。</p>
</li>
<li><p><strong>漏洞扫描</strong>：是一种自动检测远程或本地主机安全漏洞的软件，通过洞扫描器可以自动发现系统的安全漏洞。常见的漏洞扫描技术有<font color="red">CGI漏洞扫描、弱口令扫描、操作系统漏洞扫描、数据库漏洞扫描</font>等。</p>
</li>
<li><p><strong>代理技术</strong>：网络攻击者通过免费代理服务器进行攻击，其目的是以代理服务器为“攻击跳板”，即使攻击目标的网络管理员发现了，也难以追踪到网络攻击者的真实身份或IP地址。为了增加追踪的难度，网络攻击者还会用多级代理服务器或者“跳板主机”来攻击目标。代理服务器被叫做“肉鸡”，黑客常利用所控制的机器进行攻击活动，如DDOS攻击。</p>
</li>
<li><p><strong>数据加密</strong>：网络攻击者常常采用数据加密技术来逃避网络安全管理人员的追踪。加密使网络攻击者的数据得到有效保护，即使网络安全管理人员得到这些加密的数据，没有密钥也无法读懂，这样就实现了攻击者的自身保护。攻击者的安全原则是，任何与攻击有关的内容都必须加密或者立刻销毁。</p>
</li>
</ul>
<h3 id="黑客常用工具分析"><a href="#黑客常用工具分析" class="headerlink" title="黑客常用工具分析"></a>黑客常用工具分析</h3><p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060143708.png"></p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060143807.png"></p>
<h3 id="网络攻击案例分析"><a href="#网络攻击案例分析" class="headerlink" title="网络攻击案例分析"></a>网络攻击案例分析</h3><h4 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h4><p><font color="blue"><strong>(重点)</strong></font>       </p>
<ul>
<li><p>DDOS攻击：分布式拒绝服务攻击，整个攻击过程可以分为下面五个步骤：</p>
<ul>
<li>①通过探测扫描大量主机，寻找可以进行攻击的目标。</li>
<li>②攻击有安全漏洞的主机，并设法获取控制权。</li>
<li>③在已攻击成功的主机中安装客户端攻击程序。</li>
<li>④利用已攻击成功的主机继续进行扫描和攻击</li>
<li>⑤当攻击客户端达到一定的数目后，攻击者在主控端给客户端攻击程序发布攻击命令。</li>
</ul>
</li>
<li><p>DDoS常用的攻击技术手段有HTTP Flood攻击、SYN Flood攻击、DNS放大攻击等。</p>
<ul>
<li><p>HTTP Flood攻击是利用僵尸主机向特定目标网站发送大量的HTTP GET请求，以导致网站瘫痪</p>
<p>  <img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060203625.png"></p>
</li>
<li><p>SYN Food攻击利用TCP&#x2F;IP协议的安全缺陷，伪造主机发送大量的SYN包到目标系统，导致目标系统的计算机网络瘫痪。</p>
<p>  <img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060203984.png"></p>
</li>
<li><p>DNS放大攻击是攻击者假冒目标系统向多个DNS解析服务器发送大量请求，而导致DNS解析服务器同时应答目标系统，产生大量网络流量，形成拒绝服务。</p>
<p>  <img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060204222.png"></p>
</li>
</ul>
</li>
</ul>
<h4 id="W32-Blaster-Worm"><a href="#W32-Blaster-Worm" class="headerlink" title="W32.Blaster.Worm"></a>W32.Blaster.Worm</h4><p><font color="blue"><strong>(考过选择，记住worm就是蠕虫病毒)</strong></font>       </p>
<p>W32.Blaster.Worm是一种利用DCOM RPC漏洞进行传播的<font color="red">网络蠕虫，其传播能力很强</font>，感染蠕虫的计算机系统运行不稳定，系统会不断重启，并且该蠕虫还将对windowsupdate.com进行拒绝服务攻击，使得受害用户不能及时地得到这个漏洞的补丁，如图所示：</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060206626.png" alt="W32.Blaster.Worm 网络攻击示意图"></p>
<h4 id="网络安全导致停电事件"><a href="#网络安全导致停电事件" class="headerlink" title="网络安全导致停电事件"></a>网络安全导致停电事件</h4><p>乌克兰电力攻击事件：</p>
<p>①黑客首先利用钓鱼邮件，欺骗电力公司员工下载了带有BlackEnergy的恶意代码文件·②然后诱导用户打开这个文件，激活木马</p>
<p>③安装SSH后门和系统自毁工具Kidisk，致使黑客最终获得了主控电脑的控制权</p>
<p>④最后，黑客远程操作恶意代码将电力公司的主控计算机与变电站断连并切断电源</p>
<p>⑤同时，黑客发送DDOS攻击电力客服中心，致使电厂工作人员无法立即进行电力维修工作</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510060214342.png" alt="乌克兰电力攻击事件攻击全程示意图"></p>
<h4 id="ATP攻击"><a href="#ATP攻击" class="headerlink" title="ATP攻击"></a>ATP攻击</h4><p><font color="blue"><strong>(考过特点)</strong></font>      </p>
<ul>
<li>APT攻击(Advanced PersistentThreat，高级持续性威胁)<ul>
<li>A：<strong>技术高级</strong>。攻击者掌握先进的攻击技术，使用多种攻击途径，包括购买或自己开发的0Day漏洞，而且，攻击过程复杂，攻击持续过程中攻击者能够动态调整攻击方式，从整体上控制攻击过程。</li>
<li>P：<strong>持续时间长</strong>。与传统黑客进行网络攻击的目的不同，实施APT攻击的黑客组织通常具有明确的攻击目标和目的，通过长期不断的信息搜集、信息监控、渗透入侵实施攻击步骤，攻击成功后一般还会继续留在网络中，等待时机执行进行后续攻击。</li>
<li>T：<strong>威胁性大</strong>。APT攻击通常拥有雄厚的资金支持，由经验丰富的黑客团队发起，一般以破坏国家或是大型企业的关键基础设施为目标，窃取内部核心机密信息，危害国家安全和社会稳定。</li>
</ul>
</li>
<li>APT防范措施：通过安全沙箱、安全大数据和态势感知等平台，联动全网安全设备，进行统一分析及时检测和预防APT攻击。[核心体现综合分析，多设备联动，不要单纯说某个安全设备]</li>
</ul>
<h4 id="APT攻击案例"><a href="#APT攻击案例" class="headerlink" title="APT攻击案例"></a>APT攻击案例</h4><p>海莲花是一个海外黑客组织，主要攻击中国海事机构、海域建设部门、科研院所和航运企业等单位。其攻击手段主要通过鱼叉邮件投递内嵌恶意宏的Word文件、快捷方式文件、SFX自解压文件、捆绑后的文档图标的可执行文件，入侵成功后通过一些内网渗透工具扫描渗透内网并横向移动，入侵重要服务器，植入Denis家族木马进行持久化控制，通过横向移动和渗透拿到域控或者重要的服务器权限。以上描述的是(D)，这类攻击的特点是()，解决思路()。</p>
<p>选项 A.宏攻击  B.木马  C扫描  D.APT攻击</p>
<hr>
<h1 id="第三章-密码学基本理论"><a href="#第三章-密码学基本理论" class="headerlink" title="第三章 密码学基本理论"></a>第三章 密码学基本理论</h1><p><font color="blue"><strong>(本章节大概会考10分)</strong></font>      </p>
<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><h3 id="密码学概念与法律"><a href="#密码学概念与法律" class="headerlink" title="密码学概念与法律"></a>密码学概念与法律</h3><p><font color="blue"><strong>(背，日期，条例名)</strong></font>      </p>
<ul>
<li>密码学主要由密码编码和密码分析两个部分组成：<ul>
<li><strong>密码编码学</strong>：研究信息的变换处理以实现信息的安全保护</li>
<li><strong>密码分析学</strong>：则研究通过密文获取对应的明文信息。</li>
</ul>
</li>
<li>《中华人民共和国密码法》于<font color="red">2020年1月1日</font>起实施。<font color="red">2005年4月1日</font>起国家施行《中华人民共和国电子签名法》。密码学相关概念：</li>
</ul>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510061613688.png"></p>
<h3 id="密码安全分析"><a href="#密码安全分析" class="headerlink" title="密码安全分析"></a>密码安全分析</h3><p><font color="blue"><strong>(背，标红处，重点，选择题常考)</strong></font>      </p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510061615570.png"></p>
<h3 id="密码体制分类"><a href="#密码体制分类" class="headerlink" title="密码体制分类"></a>密码体制分类</h3><p><font color="blue"><strong>(背，常见的算法对应体制，选择题)</strong></font>      </p>
<h4 id="私钥密码-对称密码体制"><a href="#私钥密码-对称密码体制" class="headerlink" title="私钥密码&#x2F;对称密码体制"></a>私钥密码&#x2F;对称密码体制</h4><ul>
<li><p>密码体制分为<font color="red">私钥和公钥密码体制</font>两种，而介于私钥和公钥之间的密码体制称为<font color="red">混合密码体制</font>。</p>
</li>
<li><p>私钥密码体制又称对称密码体制，该体制的特点是加密和解密使用相同的密钥。消息的收发双方必须事先通过<font color="red">安全渠道交换密钥</font>。</p>
<ul>
<li><strong>优点</strong>：加解密速度快、密文紧凑、使用长密钥时的难破解。</li>
<li><strong>缺点</strong>：密钥分配问题、密钥管理问题、无法认证源。</li>
</ul>
</li>
<li><p><font color="red"><strong>常见的对称密钥加密算法如下：DES、3DES、AES、RC4&#x2F;5、IDEA</strong></font>。</p>
</li>
</ul>
<h4 id="公钥密码-非对称密码体制"><a href="#公钥密码-非对称密码体制" class="headerlink" title="公钥密码&#x2F;非对称密码体制"></a>公钥密码&#x2F;非对称密码体制</h4><ul>
<li>公钥密码体制又称为非对称加密体制，就是对数据加密和解密的密钥是不同的。<ul>
<li><strong>优点</strong>：密钥分发方便、密钥保管量少、支持数字签名</li>
<li><strong>缺点</strong>：加密速度慢(计算量大，不适合加密大数据)、数据膨胀率高。</li>
</ul>
</li>
<li>每个实体有两个密钥：<font color="red">公钥公开，私钥自己保存</font><ul>
<li><font color="red">公钥加密，私钥解密可实现保密通信</font></li>
<li><font color="red">私钥加密，公钥解密，可实现数字签名</font></li>
</ul>
</li>
<li>常见的非对称加密算法如下：<ul>
<li><font color="red">RSA</font>：512位(或1024位)密钥，计算量极大，难破解。</li>
<li>Elgamal、ECC(椭圆曲线算法)、背包算法、Rabin、DH等。</li>
</ul>
</li>
</ul>
<h4 id="混合密码体制"><a href="#混合密码体制" class="headerlink" title="混合密码体制"></a>混合密码体制</h4><p>混合密码体制：发送方用对称密钥加密需要发送的消息，再用接收方的公钥加密对称密钥，然后一起发送给接收方；接收方先用自己的私钥解密得到对称密钥，然后用对称密钥解密得到明文。</p>
<p><img src="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88.assets/image-20251006163754175.png" alt="混合密码体制原理示意图"></p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><h3 id="对称加密算法总结"><a href="#对称加密算法总结" class="headerlink" title="对称加密算法总结"></a>对称加密算法总结</h3><p><font color="blue"><strong>(常考考点，特别是标红)</strong></font>      </p>
<p>DES分组64位，密钥长度56位，每轮子密钥48位</p>
<p>3DES一般情况下密码长度112位</p>
<p>DEA分组64位，密钥长度128位</p>
<p>AES分组128位，密钥长度128、192、256</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510061647941.png"></p>
<h3 id="国产加密算法-SM系列"><a href="#国产加密算法-SM系列" class="headerlink" title="国产加密算法-SM系列"></a>国产加密算法-SM系列</h3><p>国产密码算法：是指由国家密码研究相关机构自主研发，具有相关知识产权的商用密码算法，目前已经公布的国产密码算法如下：</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>算法特征描述</th>
</tr>
</thead>
<tbody><tr>
<td>SM1</td>
<td>对称加密，分组长度和密钥长度都为128比特</td>
</tr>
<tr>
<td>SM2</td>
<td>非对称加密，用于公钥加密算法、密钥交换协议、数字签名算法(椭圆曲线问题)</td>
</tr>
<tr>
<td>SM3</td>
<td>杂凑算法，分组512位，输出杂凑值长度为256位</td>
</tr>
<tr>
<td>SM4</td>
<td>对称加密，分组长度和密钥长度都为128比特</td>
</tr>
<tr>
<td>SM9</td>
<td>标识密码算法，支持公钥加密、密钥交换、数字签名等安全功能</td>
</tr>
</tbody></table>
<h2 id="公钥密码分类"><a href="#公钥密码分类" class="headerlink" title="公钥密码分类"></a>公钥密码分类</h2><p><font color="blue"><strong>(选择题)</strong></font>      </p>
<ul>
<li>目前公认的比较安全的公钥密码有两类：<ul>
<li><font color="red">基于大素数因子分解困难性：RSA</font></li>
<li><font color="red">基于离散对数问题困难性：DH、Elgamal、ECC(椭圆曲线密码)</font></li>
</ul>
</li>
</ul>
<h3 id="RSA算法概述"><a href="#RSA算法概述" class="headerlink" title="RSA算法概述"></a>RSA算法概述</h3><ul>
<li><p>RSA算法是非对称算法，由Ronald Rivest、Adi Shamir、Leonard Adleman三人发明。RSA算法中公钥和私钥都可以用于加密消息，用于加密消息的密钥与用于解密消息的密钥相反。</p>
</li>
<li><p>RSA算法提供了一种保护网络通信和数据存储的<font color="red">机密性、完整性、真实性和不可否认性</font>的方法。</p>
</li>
<li><p><font color="red">SSH、OpenPGP、S&#x2F;MIME和SSL&#x2F;TLS</font>都依赖于RSA进行<font color="red">加密和数字签名</font>功能。</p>
</li>
<li><p>公钥密码思想是将传统密码的密钥K一分为二，分为加密钥Ke和解密钥Kd，用加密钥Ke控制加密，用解密钥Kd控制解密。</p>
</li>
<li><p>每个用户都将自己的姓名、地址和公开的加密钥等信息在KMC(密钥管理中心)登记，将公钥记,入共享的公钥数据库PKDB(Public Key Database)。</p>
</li>
</ul>
<h3 id="RSA三种模式"><a href="#RSA三种模式" class="headerlink" title="RSA三种模式"></a>RSA三种模式</h3><p><font color="blue"><strong>(考过大题，计算题&#x2F;文字描述&#x2F;看文字画过程图)</strong></font>   </p>
<h4 id="加密模式-确保数据的秘密性"><a href="#加密模式-确保数据的秘密性" class="headerlink" title="加密模式(确保数据的秘密性)"></a>加密模式(确保数据的秘密性)</h4><ul>
<li><p>发方：</p>
<ul>
<li>①A首先查PKDB，查到B的公开的公钥KeB</li>
<li>②A用KeB加密明文M得到密文C：C&#x3D;E(M,KeB)</li>
<li>③A发密文C给B</li>
</ul>
</li>
<li><p>收方：</p>
<ul>
<li>①B接受C</li>
<li>②B用自己的私钥KdB解密C，得到明文M&#x3D;D(C,KdB)</li>
</ul>
</li>
</ul>
<h4 id="认证模式-确保数据的真实性"><a href="#认证模式-确保数据的真实性" class="headerlink" title="认证模式(确保数据的真实性)"></a>认证模式(确保数据的真实性)</h4><ul>
<li>发方：<ul>
<li>①A用自己的私钥KdA加密M,得到密文C：C&#x3D;E(M,KdA)</li>
<li>②A发密文C给B</li>
</ul>
</li>
<li>收方：<ul>
<li>①B接受C</li>
<li>②B查PKDB，查到A的公开的公钥KeA③用KeA解密C得到明文M：M&#x3D;D(C,KeA)</li>
</ul>
</li>
</ul>
<h4 id="加密认证混合模式-同时确保数据的秘密性和真实性"><a href="#加密认证混合模式-同时确保数据的秘密性和真实性" class="headerlink" title="加密认证混合模式(同时确保数据的秘密性和真实性)"></a>加密认证混合模式(同时确保数据的秘密性和真实性)</h4><ul>
<li>发方：<ul>
<li>①A用自己的私钥KdA加密M，得到中间密文S：S&#x3D;E(M,KdA)</li>
<li>②然后A查PKDB，查到B的公开的公钥KeB</li>
<li>③A用KeB加密S得到最终的密文C：C&#x3D;E(S,KeB)</li>
<li>④A发密文C给B</li>
</ul>
</li>
<li>收方：<ul>
<li>①B接受C</li>
<li>②B用自己的私KdB解密C，得到中间密文S&#x3D;D(C,KdB)</li>
<li>③B查PKDB，查到A的公开的公钥KeA。用KeA解密S得到明文M，M&#x3D;D(S,KeA)</li>
</ul>
</li>
</ul>
<h3 id="非对称加密算法RSA"><a href="#非对称加密算法RSA" class="headerlink" title="非对称加密算法RSA"></a>非对称加密算法RSA</h3><p><font color="red"><strong>欧拉函数</strong></font>：对于一个正整数n，小于n且与n互素的正整数的个数，记为φ(n)。</p>
<ul>
<li>对于一个素数n，可知q(n)&#x3D;n-1</li>
<li>对于两个素数p和q，它们的乘积满足n&#x3D;p×q，则可知φ(n)&#x3D;(p-1)×(9-1)</li>
</ul>
<p><font color="red"><strong>欧几里得算法</strong></font>：gcd(a,b)表示a和b的最大公约数，gcd(a,b)&#x3D;1，表示a,b最大公约数为1，说明a和b<strong>互质</strong>。</p>
<p><font color="red"><strong>同余</strong></font>：两个整数a,b，若它们除以整数m所得的余数相等，则称a与b对于模m同余，或a同余b模m，记作a&#x3D;b(mod m).</p>
<ul>
<li>例如：40&#x3D;1(mod13)，26&#x3D;2(mod12)。</li>
</ul>
<p><strong>求解乘法逆元</strong>：</p>
<ul>
<li><p>5xd&#x3D;1 mod 72，求d ?</p>
</li>
<li><p>5xd-1&#x3D;nx72(n&#x3D;1,2,3,4…)</p>
</li>
<li><p>得：当n&#x3D;2，d&#x3D;29</p>
</li>
</ul>
<h2 id="非对称加密算法RSA计算"><a href="#非对称加密算法RSA计算" class="headerlink" title="非对称加密算法RSA计算"></a>非对称加密算法RSA计算</h2><table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
<th>是否保密</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>随机选择两个大素数p和q</td>
<td>p 和q 保密</td>
</tr>
<tr>
<td>2</td>
<td>计算n&#x3D;pxq</td>
<td>n公开</td>
</tr>
<tr>
<td>3</td>
<td>计算φ(n)&#x3D;(p-1)(9-1)</td>
<td>φ(n)保密</td>
</tr>
<tr>
<td>4</td>
<td>随机选取一个正整数e，1&lt;e&lt;q(n)且gcd(e,φ(n))&#x3D;1</td>
<td>e 公开</td>
</tr>
<tr>
<td>5</td>
<td>根据exd&#x3D;1 mod φ(n)，求出d</td>
<td>d 保密</td>
</tr>
<tr>
<td>6</td>
<td>加密运算C&#x3D;M^e^ mod n，解密运算M&#x3D;C^d^ mod n</td>
<td></td>
</tr>
</tbody></table>
<p><font color="red">RSA密码公开密钥(公钥)Ke&#x3D;&lt;n,e&gt;，保密的解密钥(私钥)Kd &#x3D;&lt;p,9,d,φ(n)&gt;。</font></p>
<h2 id="Hash哈希算法"><a href="#Hash哈希算法" class="headerlink" title="Hash哈希算法"></a>Hash哈希算法</h2><ul>
<li>HASH函数，又称为<font color="red">杂凑函数、散列函数</font>，它能够将<font color="red">任意长度的信息转换成固定长度的哈希值(数字摘要)</font>，并且任意不同消息或文件所生成的哈希值是不一样的。</li>
<li>h表示hash函数，则h满足下列条件：<ul>
<li>(1)h的输入可以是任意长度的消息或文件M；</li>
<li>(2)h的输出的长度是固定的；</li>
<li>(3)给定h和M，计算h(M)是容易的；</li>
<li>(4)给定h的描述，找两个不同的消息M1和M2，使得h(M1)&#x3D;h(M2)是计算上不可行的。</li>
</ul>
</li>
<li>哈希函数特性：<font color="red">不可逆性(单向)、无碰撞性、雪崩效应</font>。</li>
<li>常见的Hash算法有：<ul>
<li>(1)MD5算法：以512位数据块为单位来处理输入，产生<font color="red">128位</font>的信息摘要。常用于文件校验</li>
<li>(2)SHA算法：以512位数据块为单位来处理输入，产生<font color="red">160位</font>的哈希值，具有比MD5更强的安全性。</li>
<li>(3)SM3国产算法：消息分组长度为512比特，输出<font color="red">256位</font>摘要</li>
</ul>
</li>
</ul>
<h3 id="HASH应用"><a href="#HASH应用" class="headerlink" title="HASH应用"></a>HASH应用</h3><h4 id="一-文件完整性校验"><a href="#一-文件完整性校验" class="headerlink" title="(一) 文件完整性校验"></a>(一) 文件完整性校验</h4><p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510070149196.png"></p>
<h4 id="二-账号密码存储"><a href="#二-账号密码存储" class="headerlink" title="(二) 账号密码存储"></a>(二) 账号密码存储</h4><p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510070151413.png"></p>
<h4 id="三-用户身份认证"><a href="#三-用户身份认证" class="headerlink" title="(三) 用户身份认证"></a>(三) 用户身份认证</h4><ul>
<li>MAC&#x3D;Hash(密码+R)增加一个随机数R做哈希</li>
<li>需要双方预先知道这个R</li>
<li>MAC：消除中间人攻击，源认证+完整性校验</li>
</ul>
<h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><ul>
<li>MAC(Message Authentication Code，消息认证码)MAC消息认证码在加密的过程中有两种方法：<ul>
<li>①用单向散列函数的实现，MAC函数用单向hash函数加密时，MAC被称为<font color="red">HMAC(Hash Message Authentication Code), MAC&#x3D;Hash(M+key)</font></li>
<li>②通过分组密码的实现，比如基于AES的CBC-MAC。</li>
</ul>
</li>
</ul>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510070151402.png"></p>
<h3 id="HASH、MAC和HMAC对比"><a href="#HASH、MAC和HMAC对比" class="headerlink" title="HASH、MAC和HMAC对比"></a>HASH、MAC和HMAC对比</h3><ul>
<li>Hash能验证数据完整性，<font color="red">无法进行用户身份认证</font>，计算过程<font color="red">无密钥参与</font>。</li>
<li>MAC能保证数据完整性，同时可以进行用户身份验证，有key参与。可以采用Hash或对称加密算法两种技术产生MAC值。</li>
<li><font color="red">HMAC是MAC的一种</font>，可以验证数据完整性，也可以验证数据是由原始发送方发出的，使用hash函数来构造，HMAC输出长度与Hash长度一样。</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul>
<li>数字签名：签名者使用<font color="red">私钥</font>对<font color="red">待签名数据的哈希值</font>做密码运算得到的结果，该结果只能用签名者的<font color="red">公钥</font>进行验证。【私钥签名，公钥验证】</li>
<li>数字签名具有如下特点：<ul>
<li>①<font color="red">非否认</font>：签名者事后不能抵赖自己的签名。<font color="red">(不可否认性)</font></li>
<li>②<font color="red">真实性</font>：接收者能验证签名，而任何其他人不能伪造签名。(解决冒充问题)</li>
<li>③<font color="red">可鉴别性</font>：如果当事的双方关于签名的真伪发生争执，能够在公正的仲裁者面前通过验证签名来确认其真伪。</li>
<li>④<font color="red">不可篡改</font>：私钥不公开，所以不能篡改签名。</li>
<li>数字签名，可以保证数据的<font color="red">完整性和不可否认性</font>。</li>
</ul>
</li>
<li>典型数字签名算法(公钥加密算法)：<font color="red">RSA</font>、Rabin、ELGamal签名体制和DSS标准</li>
</ul>
<h2 id="PKI与数字证书"><a href="#PKI与数字证书" class="headerlink" title="PKI与数字证书"></a>PKI与数字证书</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书(Digital Certificate，类似身份证的作用)</p>
<p>CA(Certificate Authority，电子商务认证授权机构)</p>
<ul>
<li>数字证书按类别可分为<font color="red">个人证书、机构证书和设备证书</font>，按用途可分为<font color="red">签名证书和加密证书</font>。其中签名证书是用于证明签名公钥的数字证书。加密证书是用于证明加密公钥的数字证书。</li>
<li>为更好的管理数字证书，一般是基于PKI技术建立数字证书认证系统(简称CA)，<font color="red">CA提供数字证书的申请、审核、签发、查询、发布以及证书吊销</font>等全生命周期的管理服务。</li>
<li>数字证书认证系统的构成包括<font color="red">目录服务器、OCSP服务器、注册服务器、签发服务器</font>等。</li>
</ul>
<h3 id="PKI体系结构"><a href="#PKI体系结构" class="headerlink" title="PKI体系结构"></a>PKI体系结构</h3><p>1、<font color="red">用户&#x2F;终端实体</font>：指将要向认证中心申请数字证书的客户，可以是个人，也可以是集团或团体、某政府机构等。</p>
<p>2、<font color="red">注册机构RA</font>：负责受理用户申请证书，对申请人的合法性进行认证，并决定是批准或拒绝证书申请。注册机构并不给用户签发证书，而只是对用户进行资格审查。较小的机构，可以由CA兼任RA的工作</p>
<p>3、<font color="red">证书颁发机构CA</font>：负责给用户颁发、管理和撤销证书。</p>
<p>4、<font color="red">证书发布系统</font>：负责证书发放，如可以通过用户自己或是通过目录服务。</p>
<p><font color="red">CRL库</font>：证书吊销列表，存放过期或者无效证书。</p>
<p><img src="/https%EF%BC%9A/cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202510070158575.png"></p>
<h2 id="密码管理安全协议"><a href="#密码管理安全协议" class="headerlink" title="密码管理安全协议"></a>密码管理安全协议</h2><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>密码系统的安全性依赖于密码管理。密码管理主要可以分成三个方面内容，即<font color="red">密钥管理、密码管理政策、密码测评</font>。</p>
<p>密码管理：主要围绕密钥的生命周期进行，包括<font color="red">密钥生成、密钥存储、密钥分发、密钥使用、密钥更新,密钥撤销、密钥备份、密钥恢复、密钥销毁、密钥审计</font>。</p>
<h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><p><font color="blue"><strong>(可能选择题)</strong></font>   </p>
<ul>
<li><p>Diffie-Hellman密钥交换协议：<font color="red">基于求解离散对数问题的困难性</font>，通过交换控制消息，保障通信双方能生成相同的密钥K，避免密钥在互联网上传输。常用于IPSec密钥交换</p>
</li>
<li><p>SSH(Secure Shell ，安全外壳)是基于公钥的安全应用协议，基于TCP22端口，包含<font color="red">SSH传输层协议、SSH用户认证协议和SSH连接协议</font>三个子协议，实现<font color="red">加密、认证、完整性检查</font>等多种安全服务。</p>
<ul>
<li><font color="red">SSH传输层协议</font>：提供算法协商和密钥交换，并实现服务器的认证，最终形成一个加密的安全连接，该安全连接提供完整性、保密性和压缩选项服务。</li>
<li><font color="red">SSH用户认证协议</font>：利用传输层的服务来建立连接，使用传统的口令认证、公钥认证、主机认证等多种机制认证用户。</li>
<li><font color="red">SSH连接协议</font>：在前面两个协议的基础上，利用已建立的认证连接，并将其分解为多种不同的并发逻辑通道，支持注册会话隧道和TCP转发，而且能为这些通道提供流控服务以及通道参数协商机制。</li>
<li>SSH支持远程登录、rsh，rogin、文件传输等多种安全服务，Linux系统一般提供SSH服务，端口号一般为22。</li>
<li>SSH可能受到中间人攻击和拒绝服务攻击。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第四章-网络安全体系与安全模型"><a href="#第四章-网络安全体系与安全模型" class="headerlink" title="第四章 网络安全体系与安全模型"></a>第四章 网络安全体系与安全模型</h1><h2 id="网络安全模型"><a href="#网络安全模型" class="headerlink" title="网络安全模型"></a>网络安全模型</h2><h3 id="网络安全体系概述"><a href="#网络安全体系概述" class="headerlink" title="网络安全体系概述"></a>网络安全体系概述</h3><p>网络安全体系是网络安全保证系统的<font color="red">最高层概念抽象，是由各种网络安全单元按照一定的规则组成共同实现网络安全的目标。网络安全体系包括法律法规政策文件、安全策略、组织管理、技术措施标准规范、安全建设与运营、人员队伍、教育培训、产业生态、安全投入等多种要素。</p>
<p>网络安全体系特征：整体性、协同性、过程性、全面性、适应性。</p>
<h3 id="BLP模型"><a href="#BLP模型" class="headerlink" title="BLP模型"></a>BLP模型</h3><ul>
<li><p>Bell-LaPadula模型(BLP机密性模型)该模型用于<font color="red">防止非授权信息的扩散</font>，从而保证系统的安全。该模型包含两个特性：<font color="red">简单安全特性和*特性</font>。</p>
<ul>
<li><strong>简单安全特性</strong>：主体对客体进行<font color="red">读访问的必要条件是主体的安全级别不小于客体的安全级别，主体的范畴集合包含客体的全部范畴，即主体<font color="red">只能向下读，不可向上读</font>。</li>
<li>*<strong>特性</strong>：个主体对客体进行<font color="red">写访问的必要条件是客体的安全级支配主体的安全级，即客体的保密级别不小于主体的保密级别，客体的范畴集合包含主体的全部范畴，即主体<font color="red">只能向上写，不可向下写</font>。</li>
</ul>
</li>
<li><p>BLP模型只能保障<font color="red">机密性</font>，不能保障<font color="red">完整性</font>。</p>
</li>
<li><p>BLP机密性模型可用于<font color="red">实现军事安全策略</font>(Miliary Security Policy)。该策略最早是美国国防部为了保护计算机系统中的机密信息而提出的一种限制策略。</p>
</li>
<li><p>策略规定：用户要合法读取某信息，当且仅当<font color="red">用户的安全级大于或等于该信息的安全级</font>，并且用户的访问范畴包含该信息范畴时。</p>
<ul>
<li>安全级：按顺序规定为公开&lt;秘密&lt;机密&lt;绝密</li>
<li>范畴集：指安全级的有效领域或信息所归属的领域，如人事处、财务处等</li>
</ul>
</li>
<li><p>系统访问类例子：</p>
<ul>
<li>文件F访问类：{机密：人事处，财务处}</li>
<li>用户A访问类：{绝密：人事处}</li>
<li>用户B访问类：{绝密：人事处，财务处，科技处}</li>
<li>按照军事安全策略规定，用户B可以阅读文件F，但用户A不能读文件F，因为用户A缺少“财务处”范畴。</li>
</ul>
</li>
</ul>
<h3 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h3><ul>
<li>Biba完整性模型，主要用于<font color="red">防止非授权修改系统信息</font>，以保证系统的信息完整性。</li>
<li>Biba三个特性：<font color="red">简单安全特性、*特性和调用特性</font>。<ul>
<li><strong>简单安全特性</strong>：主体对客体进行修改访问的必要条件是主体的完整性级别不小于客体的完整性级别，主体的范畴包含客体的全部范畴，即<font color="red">主体不能向下读</font>。</li>
<li><strong>特性</strong>：主体的完整性级别小于客体的完整性级别，不能修改客体，即<font color="red">主体不能向上写</font>。</li>
<li><strong>调用特性</strong>：主体的完整性级别小于另一个主体的完整性级别，不能调用另一个主体。</li>
</ul>
</li>
</ul>
<h3 id="信息流模型"><a href="#信息流模型" class="headerlink" title="信息流模型"></a>信息流模型</h3><ul>
<li>信息流模型：是<font color="red">访问控制模型</font>的一种变形，简称FM，该模型不检查主体对客体的存取，而是根据两个客体的安全属性来控制从一个客体到另一个客体的信息传输。</li>
<li>信息流模型可表示为FM&#x3D;(N，P，SC，，一)符号分别代表：N-客体集，P-进程集，SC-安全类型集；②-支持结合、交换的二进制运算符；一流关系。一个安全的FM当且仅当执行系列操作后，不会导致流与流关系产生冲突。</li>
<li>信息流模型可以用于<font color="red">分析系统的隐蔽通道</font>，防止敏感信息通过隐蔽通道泄露。隐蔽通道通常表现为低安全等级主体对高安全等级主体所产生信息的间接读取。</li>
</ul>
<h3 id="信息保障模型"><a href="#信息保障模型" class="headerlink" title="信息保障模型"></a>信息保障模型</h3><p><font color="blue"><strong>(肯定会考，注意背单词，首字母)</strong></font>   </p>
<ul>
<li>信息保障模型：PDRR模型、P2DR模型、WPDRRC模型。<ul>
<li>PDRR模型：保护Protection、检测Detection、恢复Recovery、响应Response。</li>
<li>P2DR模型：安全策略Policy、防护Protection、检测Detection、响应</li>
<li>ResponseWPDRRC模型：预警Warning、保护、检测、反应、恢复、反击Counterattack</li>
</ul>
</li>
</ul>
<h3 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h3><p><font color="blue"><strong>(给过程形容，识别是第几级)</strong></font>   </p>
<ul>
<li><p>能力成熟度模型CMM是对一个组织机构的能力进行成熟度评估，分为五级：</p>
<ul>
<li>1级-非正式执行：具备随机、无序、被动的过程</li>
<li>2级-计划跟踪：具备主动、非体系化的过程</li>
<li>3级-充分定义：具备正式的、规范的过程</li>
<li>4级-量化控制：具备可量化的过程</li>
<li>5级-持续优化：具备可持续优化的过程</li>
</ul>
</li>
<li><p>成熟度模型主要有SSE-CMM系统安全工程能力成熟度模型、数据安全能力成熟度型、软件安全能力成熟度模型等。</p>
<ul>
<li>SSE-CMM是系统安全工程能力成熟度模型，包括工程过程类、组织过程类、项目过程类。</li>
<li>数据安全能力从组织建设、制度流程、技术工具及人员能力四个维度评估。</li>
</ul>
</li>
<li><p>软件安全能力成熟度模型分为五级：</p>
<ul>
<li>CMM1级-补丁修补</li>
<li>CMM2级-渗透测试、安全代码评审</li>
<li>CMM3级-漏洞评估、代码分析、安全编码标准</li>
<li>CMM4级-软件安全风险识别、SDLC实施不同安全检查点</li>
<li>CMM5级-改进软件安全风险覆盖率、评估安全差距</li>
</ul>
</li>
</ul>
<h3 id="其他安全模型"><a href="#其他安全模型" class="headerlink" title="其他安全模型"></a>其他安全模型</h3><ul>
<li>纵深防御模型：①安全保护 ②安全监测③实时响应④恢复</li>
<li>分层防护模型：参考OSI模型，对保护对象进行层次化保护</li>
<li>将信息系统划分成不同安全保护等级，采取相等级保护模型：应的保护措施。</li>
<li>网络生存模型：系统遭受入侵，网络信息系统仍然能够持续提供必要服务的能力。遵循”3R”策略，抵抗(Resistance)、识别(Recognition)、和恢复(Recovery)。</li>
</ul>
<h2 id="网络安全体系框架和建设内容"><a href="#网络安全体系框架和建设内容" class="headerlink" title="网络安全体系框架和建设内容"></a>网络安全体系框架和建设内容</h2><h3 id="网络安全等级保护2-0"><a href="#网络安全等级保护2-0" class="headerlink" title="网络安全等级保护2.0"></a>网络安全等级保护2.0</h3><p><font color="blue"><strong>(记住每个等级的名称)</strong></font>   </p>
<p>等级保护分为五个：第一级(用户自主保护级)、第二级(系统审计保护级)、第三级(安全标记保护级)、第四级(结构化保护级)、第五级(访问验证保护级)。</p>
<p>根据信息系统按照<strong>重要性</strong>和<strong>受破坏后的危害性</strong>进行定级，二级和三级居多。</p>
<p>等保项目流程：定级、备案、安全建设整改、等级测评、安全自查与监督检查。</p>
<hr>
<h1 id="第五章-物理与环境安全技术"><a href="#第五章-物理与环境安全技术" class="headerlink" title="第五章 物理与环境安全技术"></a>第五章 物理与环境安全技术</h1><h2 id="物理安全概述"><a href="#物理安全概述" class="headerlink" title="物理安全概述"></a>物理安全概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>技术框架：包含物理安全概述、机房安全分析与防护、通信线路&#x2F;设备&#x2F;存储介质安全三大模块</li>
<li>攻击特点：物理攻击看似技术含量不高，但能造成大面积系统瘫痪（如光纤断裂影响整个区域）</li>
<li>传统定义：涵盖环境、设备和记录介质等支持网络信息系统运行硬件的总体安全</li>
<li>广义定义：包含硬件、软件、操作人员及环境组成的人-机-物融合系统的安全</li>
<li>威胁分类：<ul>
<li>自然威胁：地震&#x2F;洪水&#x2F;雷电&#x2F;鼠害等</li>
<li>人为威胁：盗窃&#x2F;爆炸&#x2F;硬件攻击等</li>
</ul>
</li>
</ul>
<h3 id="物理安全威胁"><a href="#物理安全威胁" class="headerlink" title="物理安全威胁"></a>物理安全威胁</h3><h4 id="硬件木马"><a href="#硬件木马" class="headerlink" title="硬件木马"></a>硬件木马</h4><ul>
<li><p>植入方式：在IC芯片中嵌入恶意电路，激活后改变原有功能</p>
</li>
<li><p>攻击阶段：</p>
<ul>
<li>设计阶段：通过EDA工具&#x2F;IP核植入</li>
<li>制造阶段：代工厂逆向工程植入</li>
<li>测试阶段：测试环节恶意篡改</li>
</ul>
</li>
<li><p>国产化意义：避免供应链不可控导致的安全隐患（如华为5G芯片断供案例）</p>
</li>
<li><p>硬件协同的恶意代码：</p>
<ul>
<li>攻击特征：非授权软件访问特权内存区域</li>
<li>破坏目标：主要破坏信息安全的机密性属性</li>
</ul>
</li>
<li><p>硬件安全漏洞利用</p>
<ul>
<li>典型漏洞：<ul>
<li>熔断(Meltdown)：允许越权读取内核内存</li>
<li>幽灵(Spectre)：利用预测执行窃取数据</li>
</ul>
</li>
<li>修复难点：硬件漏洞无法通过补丁完全修复，可能需整批设备淘汰</li>
</ul>
</li>
<li><p>基于软件漏洞攻击硬件实体 </p>
<ul>
<li>攻击链条：软件漏洞→参数篡改→物理损坏</li>
<li>震网病毒案例：通过控制软件超频离心机转速导致设备物理损毁</li>
</ul>
</li>
<li><p>基于环境攻击计算机实体 </p>
<ul>
<li>攻击媒介：电磁波&#x2F;磁场&#x2F;温湿度等环境参数</li>
<li>防护措施：电磁屏蔽机房、恒温恒湿控制系统</li>
</ul>
</li>
</ul>
<h3 id="物理安全保护"><a href="#物理安全保护" class="headerlink" title="物理安全保护"></a>物理安全保护</h3><h4 id="设备物理安全"><a href="#设备物理安全" class="headerlink" title="设备物理安全"></a>设备物理安全</h4><ul>
<li>标识管理：设备标签&#x2F;网线标记（防止误接关键设备）</li>
<li>电磁防护：光纤&#x2F;屏蔽网线&#x2F;屏蔽机房三级防护</li>
<li>电源保护：UPS防止瞬间断电损坏设备</li>
<li>抗震设计：防静电地板+槽钢固定机柜</li>
</ul>
<h4 id="环境物理安全"><a href="#环境物理安全" class="headerlink" title="环境物理安全"></a>环境物理安全</h4><ul>
<li>选址要点：<ul>
<li>电力供应：多路供电+柴油发电机</li>
<li>地理安全：避开地震&#x2F;洪水多发区</li>
<li>气候适宜：优先选择内蒙&#x2F;贵州等温带地区</li>
</ul>
</li>
<li>基础防护：防火&#x2F;防水&#x2F;防雷&#x2F;防鼠&#x2F;门禁系统</li>
</ul>
<h4 id="系统物理安全"><a href="#系统物理安全" class="headerlink" title="系统物理安全"></a>系统物理安全</h4><ul>
<li>介质管理：涉密存储介质加密处理</li>
<li>访问控制：机房分级门禁+机柜物理锁</li>
<li>灾备方案：异地容灾备份系统</li>
</ul>
<h4 id="物理安全保护方法"><a href="#物理安全保护方法" class="headerlink" title="物理安全保护方法"></a>物理安全保护方法</h4><ul>
<li>核心方法：<ul>
<li>供应链安全管理（多供应商采购策略）</li>
<li>故障容错机制（冗余设备部署）</li>
<li>安全监测预警（环境传感器网络）</li>
</ul>
</li>
<li>实施要点：符合等保2.0物理安全要求</li>
</ul>
<h4 id="物理安全分析与防护"><a href="#物理安全分析与防护" class="headerlink" title="物理安全分析与防护"></a>物理安全分析与防护</h4><h5 id="防火"><a href="#防火" class="headerlink" title="防火"></a>防火</h5><ul>
<li>隐患消除：定期检查电路老化情况，清理易燃物品</li>
<li>报警系统：机房需安装温感&#x2F;烟感探头，实现水火双重监测</li>
<li>灭火设备：禁止使用水基&#x2F;干粉灭火器，应选用﻿CO2CO_2CO2﻿气体灭火系统</li>
<li>管理规范：制定明火使用制度，禁止在机房内吸烟或使用大功率电器</li>
</ul>
<h5 id="防水"><a href="#防水" class="headerlink" title="防水"></a>防水</h5><ul>
<li>管道限制：原则上禁止铺设水管，特殊情况需做防渗漏处理（如双层套管）</li>
<li>建筑防护：墙面&#x2F;天花板需采用防水涂料，地面应做防潮层处理</li>
<li>排水设计：水管经过处必须设置止水阀，并配套排水沟系统</li>
<li>选址要点：典型案例：某项目将机房设在一层导致设备受潮损坏</li>
<li>电缆防护：地下电缆沟需做防水密封，墙地面接缝处应使用防水胶处理</li>
</ul>
<h5 id="防震"><a href="#防震" class="headerlink" title="防震"></a>防震</h5><ul>
<li>建筑标准：机房建筑抗震等级应高于普通建筑（建议8级以上）</li>
<li>设备固定：机柜需用防震支架固定，重型设备应加装减震装置</li>
<li>操作禁令：严禁带电移动运行中的设备，搬迁前必须断电</li>
</ul>
<h5 id="防盗"><a href="#防盗" class="headerlink" title="防盗"></a>防盗</h5><ul>
<li>多重防护：采用电子门禁+机械锁双认证系统</li>
<li>监控体系：7×24小时视频监控，录像保存不少于90天</li>
<li>访问控制：实行双人陪同制度，所有进出需登记备案</li>
</ul>
<h5 id="防鼠虫害"><a href="#防鼠虫害" class="headerlink" title="防鼠虫害"></a>防鼠虫害</h5><ul>
<li>物理防护：所有孔径大于﻿6mm6mm6mm﻿的孔洞必须封堵</li>
<li>超声驱赶：布置﻿20−60kHz﻿超声波发生器</li>
<li>化学防治：<ul>
<li>电缆涂抹环己基类防鼠剂</li>
<li>隐蔽处投放溴敌隆等慢性毒饵</li>
</ul>
</li>
<li>案例警示：某数据中心因鼠患导致光缆大面积损毁</li>
</ul>
<h5 id="防雷"><a href="#防雷" class="headerlink" title="防雷"></a>防雷</h5><ul>
<li>避雷系统：楼顶安装45°保护角避雷针</li>
<li>接地要求：设备接地电阻&lt;﻿4Ω，需接入建筑地网</li>
<li>重点防护：核心设备应配置三级防雷模块</li>
</ul>
<h5 id="防静电"><a href="#防静电" class="headerlink" title="防静电"></a>防静电</h5><ul>
<li>人员装备：<ul>
<li>防静电服（表面电阻﻿10^5^−10^7^Ω﻿）</li>
<li>导电鞋（电阻&lt;﻿1MΩ﻿）</li>
<li>操作时必须佩戴静电手环</li>
</ul>
</li>
<li>环境控制：保持温度﻿20−25℃，湿度45−65﻿RH</li>
<li>材料选择：工作台面优先选用防静电陶瓷钢板</li>
</ul>
<h5 id="安全供电"><a href="#安全供电" class="headerlink" title="安全供电"></a>安全供电</h5><ul>
<li>电力架构：<ul>
<li>双路市电输入+ATS自动切换</li>
<li>UPS蓄电池组续航≥8小时</li>
<li>柴油发电机应储备72小时用油量</li>
</ul>
</li>
<li>特殊要求：重要设备需配置STS静态切换开关</li>
</ul>
<h2 id="机房安全分析与防护"><a href="#机房安全分析与防护" class="headerlink" title="机房安全分析与防护"></a>机房安全分析与防护</h2><h3 id="机房功能分区"><a href="#机房功能分区" class="headerlink" title="机房功能分区"></a>机房功能分区</h3><ul>
<li>主要工作间：主机房、终端室等核心操作区域，如放置服务器集群的空间</li>
<li>第一类辅助间：低压配电间、UPS室、蓄电池室、空调机房等设备支持区域，图中展示的蓄电池架和空调机组属于此类</li>
<li>第二类辅助间：资料室（含文件柜）、维修室、技术人员办公室等管理区域</li>
<li>第三类辅助间：储藏室、缓冲间、休息室等次要空间，实际机房中较少设置盥洗室</li>
<li>特殊说明：允许功能合并（如一室多用）或根据实际情况增减房间，考试需注意维修室属于第二类而非主要工作间</li>
</ul>
<h3 id="机房等级划分"><a href="#机房等级划分" class="headerlink" title="机房等级划分"></a>机房等级划分</h3><ul>
<li><strong>A级标准</strong>：系统中断将严重危害国家安全&#x2F;社会秩序&#x2F;公共利益，需最严格防护措施（如带附加要求的电磁干扰防护）</li>
<li><strong>B级标准</strong>：系统中断造成较大损害，要求较完善防护（如基础防火要求）</li>
<li><strong>C级标准</strong>：无特殊影响场景，仅需基本防护（灭火器等基础配置）</li>
<li><strong>混合执行</strong>：允许不同项目采用不同级别，例如电磁干扰按A级，火灾报警按C级</li>
</ul>
<h3 id="环境安全性要求"><a href="#环境安全性要求" class="headerlink" title="环境安全性要求"></a>环境安全性要求</h3><ul>
<li>危险源规避：远离油库、煤气站等易燃易爆场所（最小水平间距建议200米）</li>
<li>污染区规避：避开化工厂、水泥厂等粉尘&#x2F;有毒气体污染源</li>
<li>盐雾防护：特别禁止沿海区域和产盐区（腐蚀性水蒸气会损坏金属设备）</li>
<li>雷击防护：需进行雷击风险评估，避免高频落雷区域</li>
</ul>
<h3 id="地质可靠性要求"><a href="#地质可靠性要求" class="headerlink" title="地质可靠性要求"></a>地质可靠性要求</h3><ul>
<li>基础地质：禁止建设在杂填土、流沙层等不稳定地基上</li>
<li>山区选址：需避开滑坡体、溶洞等地质灾害频发区</li>
<li>矿区限制：距离采矿崩落区至少500米，且避开待开采矿脉</li>
<li>湿度控制：禁止低洼地带（防洪要求）和地下水位过高区域</li>
</ul>
<h3 id="数据中心建设与设计要求"><a href="#数据中心建设与设计要求" class="headerlink" title="数据中心建设与设计要求"></a>数据中心建设与设计要求</h3><ul>
<li>数据中心是实现对数据信息的集中处理、存储、传输、交换、管理以及为相关的电子信息设备运行提供运行环境的建筑场所。</li>
<li>按照规模大小可将数据中心分为三类：<strong>超大型数据中心、大型数据中心、中小型数据中心</strong>。<ul>
<li><strong>超大型数据中心</strong>：标准机柜&gt;10000个，重点考虑气候环境、能源供给等要素，特别是以灾备等实时性要求不高的应用为主，优先在气候寒冷、能源充足的一类地区建设，也可在气候适宜，能源充足的二类地区建设。</li>
<li><strong>大型数据中心</strong>： 3000个&lt;标准机柜&lt;10000个，重点考虑气候环境、能源供给等要素，鼓励优先在一类和二类地区建设，也可在气候适宜、靠近能源富集地区的三类地区建设。</li>
<li><strong>中小型数据中心</strong>：标准机架&lt;3000个，重点考虑市场需求、能源供给等要素，鼓励面向当地、以实时应用为主的中小型数据中心，在靠近用户所在地、能源获取便利的地区建设，依市场需求灵活部署。</li>
</ul>
</li>
</ul>
<h3 id="数据中心强制规范"><a href="#数据中心强制规范" class="headerlink" title="数据中心强制规范"></a>数据中心强制规范</h3><p>《数据中心设计规范(GB 50174-2017)》自2018年1月1日起实施，强制性条文内容如下：</p>
<ul>
<li>数据中心内所有设备的金属外壳、各类金属管道、金属线槽、建筑物金属结构必须进行等电位联结并接地；</li>
<li>数据中心的耐火等级不应低于二级；</li>
<li>当数据中心与其他功能用房在同一个建筑内时，数据中心与建筑内其他功能用房之间应采用耐火极限不低于2.0h的防火隔墙和1.5b的楼板隔开，隔墙上开门应采用甲级防火门；</li>
<li>采用管网式气体灭火系统或细水雾灭火系统的主机房，应同时设置两组独立的火灾探测器，火灾报警系统应与灭火系统和视频监控系统联动；</li>
<li>设置气体灭火系统的主机房，应配置专用空气呼吸器或氧气呼吸器。</li>
</ul>
<h3 id="IDC等级划分与规范"><a href="#IDC等级划分与规范" class="headerlink" title="IDC等级划分与规范"></a>IDC等级划分与规范</h3><p>《互联网数据中心工程技术规范(GB51195-2016)》自2017年4月1日起实施，规定IDC机房分成R1、R2和R3三个级别。</p>
<ul>
<li>分级标准：<ul>
<li>R1级：基础冗余，可用性≥99.5%</li>
<li>R2级：完全冗余，可用性≥99.9%</li>
<li>R3级：容错能力，可用性≥99.99%</li>
</ul>
</li>
</ul>
<h2 id="通信线路-设备-存储介质安全"><a href="#通信线路-设备-存储介质安全" class="headerlink" title="通信线路&#x2F;设备&#x2F;存储介质安全"></a>通信线路&#x2F;设备&#x2F;存储介质安全</h2><h3 id="网络通信线路安全分析与防护"><a href="#网络通信线路安全分析与防护" class="headerlink" title="网络通信线路安全分析与防护"></a>网络通信线路安全分析与防护</h3><p>网络通信线路物理威胁：线路被切断、电磁干扰、线路泄露信息。</p>
<p>线路安全防护：设备几余+线路几余。</p>
<h3 id="设备硬件攻击防护"><a href="#设备硬件攻击防护" class="headerlink" title="设备硬件攻击防护"></a>设备硬件攻击防护</h3><ul>
<li>针对硬件攻击，主要安全措施：</li>
<li>(1)硬件木马检测：反向分析法、功耗分析法、侧信道分析法。<ul>
<li>反向分析法：通过逆向工程方法将封装的芯片电路打开，逐层扫描拍照电路，然后使用图形分析软件和电路提取软件重建电路结构图，将恢复出的设计与原始设计进行对比分析，以检测硬件木马。</li>
<li>功耗分析法：获取芯片的功耗特征与“纯净芯片”功耗特征比对，以判断芯片是否被篡改。</li>
<li>侧信道分析法：通过比对电路中的物理特性和旁路信息的不同，发现电路的变化，原理是任何硬件电路的改变都会反映在一些电路参数上，如功率、时序、电磁、热等。</li>
</ul>
</li>
<li>(2)硬件漏洞处理：不同于软件漏洞，硬件漏洞的修补具有不可逆性。通常方法是破坏漏洞利用条件，防止漏洞被攻击者利用。</li>
</ul>
<p><strong>存储介质安全防护介容错容灾存储技术</strong>：采用磁盘阵列、双机在线备份、离线备份等综合安全措施。</p>
<hr>
<h1 id="第六章-认证技术与原理"><a href="#第六章-认证技术与原理" class="headerlink" title="第六章 认证技术与原理"></a>第六章 认证技术与原理</h1><h2 id="认证技术基础与原理"><a href="#认证技术基础与原理" class="headerlink" title="认证技术基础与原理"></a>认证技术基础与原理</h2><h3 id="认证概述"><a href="#认证概述" class="headerlink" title="认证概述"></a>认证概述</h3><ul>
<li>认证一般由标识(Identification)和鉴别(Authentication)两部分组成。<ul>
<li>标识：代表实体对象的身份标志，确保实体的唯一性和可辨识性，同时与实体存在强关联。标识一般用名称和标识符(ID)来表示。通过唯一标识符，可以代表实体。</li>
<li>鉴别：利用口令、电子签名、数字证书、令牌、生物特征、行为表现等相关数字化凭证对实体所声称的属性进行识别验证的过程。</li>
<li>鉴别的凭据&#x2F;认证依据：所知道的秘密信息、所拥有的的实物凭证、所具有的生物特征、所表现的行为特征。</li>
</ul>
</li>
</ul>
<h3 id="认证原理"><a href="#认证原理" class="headerlink" title="认证原理"></a>认证原理</h3><ul>
<li>认证机制由<strong>验证对象、认证协议、鉴别实体</strong>构成。</li>
<li>认证分类：<ul>
<li>按需要认证凭据的类型数量，可分成：单因素认证、双因素认证和多因素认证。</li>
<li>按认证双方角色和所依赖外部条件，分为：单向认证、双向认证和第三方认证根据认证</li>
<li>根依据所利用的时间长度，认证可分为一次性口令、持续认证。一次性口令简称OTP(One TimePassword)用于保护口令安全，防止口令重用攻击，例如短消息验证码、&#x2F;Key 口令。</li>
<li>持续认证是指连续提供身份确认，对用户整个会话过程中的特征行为进行连续检测，不间断的验证用户所具有的特性。标志是将对事件的身份验证转变为对过程的身份验证。持续验证所使用的鉴定因素主要是认知因素、物理因素、上下文因素。认知因素主要有眼手协调、应用行为模式、使用偏好、设备交互模式等。物理因素主要有左右手、按压大小、手震、手臂大小和肌肉使用。</li>
</ul>
</li>
</ul>
<h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>单向认证：验证者对声称者进行单方面的鉴别，而声称者不需要识别验证者的身份<br>单向认证技术有两种：<strong>基于共享秘密和基于挑战响应</strong>。</p>
<h4 id="基于共享秘密的认证"><a href="#基于共享秘密的认证" class="headerlink" title="基于共享秘密的认证"></a>基于共享秘密的认证</h4><ul>
<li>基本要素：<ul>
<li>共享密钥：﻿K<del>AB</del>为双方预先共享的秘密（如密码”123”）</li>
<li>身份标识：﻿ID<del>A</del>表示实体A的唯一标识（如用户名”张三”）</li>
</ul>
</li>
<li>认证流程：<ul>
<li>声称者A发送﻿(ID<del>A</del>,K<del>AB</del>)给验证者B</li>
<li>B核对﻿ID<del>A</del>对应的﻿K<del>AB</del>是否正确</li>
<li>匹配则认证通过，否则失败</li>
</ul>
</li>
<li>安全缺陷：直接传输密钥可能被中间人截获（如明文传输密码”123”）</li>
<li>符号对应：<ul>
<li>﻿ID<del>A</del>﻿：实际应用中的用户名（如”张三”）</li>
<li>﻿K<del>A~~B</del>：共享密码或密钥（如”123”）</li>
</ul>
</li>
</ul>
<h4 id="基于挑战响应的认证"><a href="#基于挑战响应的认证" class="headerlink" title="基于挑战响应的认证"></a>基于挑战响应的认证</h4><ul>
<li><p>核心改进：通过随机数挑战避免密钥直接传输</p>
</li>
<li><p>流程要素：</p>
<ul>
<li>挑战随机数：﻿R<del>B</del>由验证者B生成</li>
<li>身份标识：﻿ID<del>A</del>和﻿ID<del>B</del>分别标识通信双方</li>
</ul>
</li>
<li><p>详细步骤：</p>
<ul>
<li>B生成﻿RBR_BRB﻿并发送﻿(ID<del>B</del>,R<del>B</del>)给A</li>
<li>A使用﻿RBR_BRB﻿生成秘密﻿K<del>AB</del>﻿（通过哈希或加密）</li>
<li>A发送﻿(ID<del>A</del>,K<del>AB</del>)给B进行验证</li>
</ul>
</li>
<li><p>验证方式：</p>
<ul>
<li>哈希算法：B本地计算﻿K<del>AB</del>′&#x3D;Hash(key∣∣R<del>B</del>)进行比对</li>
<li>对称加密：B用密钥解密﻿K<del>AB</del>﻿验证﻿R<del>B</del>正确性</li>
</ul>
</li>
<li><p>安全机制：</p>
<ul>
<li>防重放：每次认证使用不同随机数﻿R<del>B</del></li>
<li>密钥保护：共享密钥﻿K始终不直接传输</li>
</ul>
</li>
<li><p>典型应用：PPP协议中的CHAP认证（三次握手过程）</p>
</li>
<li><p>生成方式：</p>
<ul>
<li>哈希生成：﻿K<del>AB</del>&#x3D;Hash(K∣∣R<del>B</del>)如HMAC）</li>
<li>加密生成：﻿K<del>AB</del>&#x3D;EK(R<del>B</del>)（对称加密）</li>
</ul>
</li>
</ul>
<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><ul>
<li>定义： 验证者与声称者在认证过程中互相鉴别彼此身份，如SSH协议中双方既是生成者也是验证者。</li>
<li>应用场景： 实际项目中双向认证使用相对较少，更常见的是服务端验证客户端身份的单向认证。</li>
</ul>
<h3 id="认证应用"><a href="#认证应用" class="headerlink" title="认证应用"></a>认证应用</h3><p>PAP：两次握手验证协议，口令以明文传送，被验证方首先发起请求。CHAP：三次握手，认证过程不传送认证口令，传送HMAC散列值</p>
<h3 id="Kerberos认证协议"><a href="#Kerberos认证协议" class="headerlink" title="Kerberos认证协议"></a>Kerberos认证协议</h3><ul>
<li>Kerberos包含四个基本实体：<ul>
<li>(1)Kerberos客户机，用户用来访问服务器设备</li>
<li>(2)<strong>AS(Authentication Server</strong>，认证服务器)识别用户身份并提供TGS会话密钥;</li>
<li>(3)**TGS(Ticket Granting Server，票据发放服务器)**，为申请服务的用户授予票据(Ticket);</li>
<li>(4)应用服务器(Application Server)，为用户提供服务的设备或系统。</li>
</ul>
</li>
<li><strong>AS和TGS统称为KDC(Key Distribution Center)</strong></li>
<li>票据(Ticket)是用于安全的传递用户身份所需要的信息的集合，主要<strong>包括客户方实体名称、地址、时间戳、票据生存期和会话密钥</strong>等内容。</li>
<li>Kerberos不足：要求解决主机节点<strong>时间同步问题和抵御拒绝服务攻击</strong>。</li>
</ul>
<h3 id="PKI体系结构-1"><a href="#PKI体系结构-1" class="headerlink" title="PKI体系结构"></a>PKI体系结构</h3><p>1、用户&#x2F;终端实体:指将要向认证中心申请数字证书的客户，可以是个人，也可以是集团或团体、某政府机构等。</p>
<p>2、注册机构RA:注册机构提供用户和CA之间的一个接口，它获取并认证用户的身份，向CA提出证书请求。它主要完成收集用户信息和确认用户身份的功能。注册机构并不给用户签发证书，而只是对用户进行资格审查。较小的机构，可以由CA兼任RA的工作。</p>
<p>3、证书颁发机构CA:负责给用户颁发证书。</p>
<p>4、证书发布系统:负责证书发放，如可以通过用户自已或是通过目录服务。</p>
<p>CRL库:证书吊销列表，存放过期或者无效证书。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向——基本逆向环境配置</title>
    <url>/2025/10/16/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91kx%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="使用虚拟机"><a href="#使用虚拟机" class="headerlink" title="使用虚拟机"></a>使用虚拟机</h2><p><strong>优点</strong>：与系统隔绝，快照功能，不受平台的限制</p>
<ul>
<li>虚拟机具有良好的跨平台特性 <ul>
<li>环境迁移：培训后可将完整虚拟机打包发送，确保学员获得与讲师完全一致的环境</li>
<li>多平台支持：VMware系列产品支持Windows&#x2F;Linux&#x2F;macOS全平台部署</li>
</ul>
</li>
<li>虚拟机具有良好的隔离特性 <ul>
<li>沙盒保护：所有测试操作都在虚拟环境中进行，不会污染真实主机系统</li>
<li>安全测试：特别适合进行各类危险性测试和逆向分析工作</li>
</ul>
</li>
</ul>
<h3 id="使用Kali-Linux配置环境示"><a href="#使用Kali-Linux配置环境示" class="headerlink" title="使用Kali Linux配置环境示"></a>使用Kali Linux配置环境示</h3><ul>
<li><p>下载验证：</p>
<ul>
<li>从官网获取VMware镜像torrent文件</li>
<li>使用certutil工具校验文件SHA256值</li>
<li>确保文件完整性后再进行解压操作</li>
</ul>
</li>
<li><p>配置建议：</p>
<ul>
<li>内存分配：建议配置为物理机内存的50-70%</li>
<li>处理器核心：根据主机配置分配适当核心数（示例配置：4核）</li>
<li>3D加速：建议关闭图形加速功能</li>
<li>网络适配器：默认NAT模式即可</li>
</ul>
</li>
<li><p>使用注意：</p>
<ul>
<li>默认登录账号：kali&#x2F;kali（US键盘布局）</li>
<li>不建议直接使用root权限操作</li>
<li>首次登录后建议立即修改密码</li>
</ul>
</li>
</ul>
<h2 id="Kali-Linux环境配置"><a href="#Kali-Linux环境配置" class="headerlink" title="Kali Linux环境配置"></a>Kali Linux环境配置</h2><h3 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h3><ul>
<li>设置方法：使用命令dpkg-reconfigure tzdata选择Asia→Shanghai时区后重启</li>
<li>常见问题：Kali时间不对通常只是时区问题，不是系统时间错误</li>
<li>注意事项：Arch Linux和Debian的时区调整方法可能不同</li>
</ul>
<h2 id="系统更新与工具安装"><a href="#系统更新与工具安装" class="headerlink" title="系统更新与工具安装"></a>系统更新与工具安装</h2><ul>
<li>基础配置：<ul>
<li>root登录：Kali默认以root用户运行，避免权限问题</li>
<li>历史记录：修改.bashrc中HISTSIZE&#x3D;1000和HISTFILESIZE&#x3D;2000</li>
</ul>
</li>
<li><strong>实用工具</strong>：<ul>
<li>htop<br>  加强版top工具，可以查看当前活跃的、占用高的进程。在编译安卓源码时很好用。Uptime是开机时间，Load average时平均负载。</li>
<li>jnettop<br>  流量查看工具，在安装和使用软件的过程中，可以查看其下载和安装的进度，甚至在AOSP编译时，仍然在连接国外的服务器下载依赖包等等行为一览无遗，如果速度过慢可以及时将其掐断，换上科学上网工具继续安装或编译。还有就是在抓包时往往有奇效，比如实时查看对方IP等。</li>
<li>tree<br>  实时查看当前网卡流量及IP。文件名搜索工具，在解包apk后，搜索文件的名字非常好用。如果想把路径全部打印出来，可以加上一些选项及配合过滤工具grep。如果要搜索文件内容，则使用grep -ril “xxxx”。</li>
<li>tmux<br>  复用神器，可以在一个终端屏幕上管理多个终端（准确来说是伪终端），使用该工具，用户可以连接或断开当前会话，而保持终端在后台运行，管理VPS非常方便，可以保持当前会话永不断开（除非重启）。</li>
</ul>
</li>
</ul>
<h3 id="配置科学上网"><a href="#配置科学上网" class="headerlink" title="配置科学上网"></a>配置科学上网</h3><p><strong>必要性</strong>: Android Studio初始化时需要科学上网才能下载组件</p>
<p><a href="cnblogs.com/volqiu/p/4811402.html">redsocks科学上网配置方法</a></p>
<h2 id="下载和安装Android-Studio"><a href="#下载和安装Android-Studio" class="headerlink" title="下载和安装Android Studio"></a>下载和安装Android Studio</h2><p>在主机找到官网linux版本下载右键复制下载链接。</p>
<p><img src="/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91kx%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.assets/image-20251013222745997.png"></p>
<p>在linux内路径<code>~/Desktop</code>下，输入命令行：<code>wget https://redirector.gvt1.com/edgedl/android/studio/ide-zips/2025.1.4.8/android-studio-2025.1.4.8-linux.tar.gz</code></p>
<p>需要解压最新版Android Studio（使用zxvf命令）</p>
<p>运行方法: 直接进入bin目录运行studio.sh</p>
<p>指路<a href="https://blog.csdn.net/huanzhongying/article/details/144240084">Gradle加载失败、超时等问题的总结_gradle下载超时-CSDN博客</a></p>
<ul>
<li><p>设置连接手机的路径</p>
<ul>
<li><p>先找到adb的路径输入命令行验证查看是否真的存在。</p>
<p><code>/root/Android/Sdk/platform-tools</code></p>
</li>
<li><p>验证真实存在后把这个路径加入系统就可以了。然后输入命令行<code>nano ~/.bashrc</code></p>
<p><a href="https://blog.csdn.net/haozhepeng/article/details/100584451">Linux PATH 作用以及查看和修改方法_linuxenv中path-CSDN博客</a></p>
</li>
<li><p>最后输入<code>source adb</code>即可</p>
</li>
<li><p>出现 “修改 <code>.bashrc</code> 后配置环境变量没效果” 的情况</p>
<ul>
<li><p><strong>Android SDK 的 <code>platform-tools</code> 未正确安装</strong></p>
<p>  如果 <code>/root/Android/Sdk/platform-tools</code> 目录本身不存在，或里面没有 <code>adb</code> 文件，说明 Android SDK 的<strong>平台工具（platform-tools）未安装 &#x2F; 安装失败</strong>。这种情况下，手动配置路径也没用，建议通过系统包管理安装（更简单可靠）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install google-android-platform-tools-installer</span><br></pre></td></tr></table></figure>

<p>  安装后，系统会自动配置 <code>adb</code> 到环境变量，无需手动改 <code>.bashrc</code>。</p>
</li>
<li><p>在安装 <code>google-android-platform-tools-installer</code> 时，需要选择一个<strong>镜像源</strong>来下载 Android 相关包。</p>
<p>  由于谷歌官方源（<code>https://dl.google.com/android/repository</code>）在国内访问可能存在速度慢、不稳定的问题，而 ** 腾讯云镜像（<code>https://mirrors.cloud.tencent.com/AndroidSDK</code>）** 是国内源，下载速度通常更快、更稳定。</p>
<p>  因此，建议选择 **<code>https://mirrors.cloud.tencent.com/AndroidSDK</code>**，然后按 <code>&lt;Ok&gt;</code> 确认即可。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安装远程桌面的软件scrcpy</p>
<ul>
<li><code>apt search apt scrcpy</code></li>
<li><code>apt install scrcpy</code></li>
</ul>
</li>
</ul>
<h2 id="实用动静态分析工具"><a href="#实用动静态分析工具" class="headerlink" title="实用动静态分析工具"></a>实用动静态分析工具</h2><h3 id="Java反编译神器：jadx"><a href="#Java反编译神器：jadx" class="headerlink" title="Java反编译神器：jadx"></a>Java反编译神器：jadx</h3><ul>
<li><p>核心功能：将安卓项目反编译成Java源码，支持APK、DEX、JAR等格式的反编译</p>
</li>
<li><p>搜索功能：可以sign为关键字搜索整个APK，方便查找签名算法</p>
</li>
<li><p>类名复制：在类标题栏右键可直接复制类名，便于在Frida中使用Java.use调用</p>
</li>
<li><p>下载网址：<a href="https://github.com/skylot/jadx">GitHub - skylot&#x2F;jadx: Dex to Java decompiler</a></p>
<p><img src="/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91kx%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E9%80%86%E5%90%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.assets/image-20251013223916604.png"></p>
<ul>
<li>操作步骤：<ul>
<li>终端路径<code>~/Desktop</code>下输入命令行<code>git clone https://github.com/skylot/jadx</code></li>
<li>从release页面下载最新版解压<code>7z x jadx-1.5.3.zip</code></li>
<li>进入解压文件，命令行<ul>
<li><code>cd jadx-1.5.3</code>&#x2F;</li>
<li><code>cd bin/</code></li>
<li>运行<code>./jadx-gui</code></li>
</ul>
</li>
<li>注意不要关窗口关了，就没了</li>
</ul>
</li>
</ul>
</li>
<li><p>功能：</p>
<ul>
<li>使用关键字搜索功能定位关键代码</li>
<li>右键查看类&#x2F;方法的调用关系</li>
<li>在code和smali视图间切换分析</li>
</ul>
</li>
</ul>
<h3 id="二进制查看修改神器：010Editor"><a href="#二进制查看修改神器：010Editor" class="headerlink" title="二进制查看修改神器：010Editor"></a>二进制查看修改神器：010Editor</h3><ul>
<li>功能特点：支持二进制数据的复制粘贴和修改</li>
<li>命名含义：010代表二进制，Editor表示编辑器</li>
<li>下载网址：<a href="https://www.sweetscape.com/010editor/">010 Editor - Pro Text&#x2F;Hex Editor | Edit 300+ Formats | Fast &amp; Powerful | Reverse Engineering</a><ul>
<li>解压方式：<code>tar zxvf....</code></li>
<li>直接运行安装包就行了<code>010EditorLinux64installer</code></li>
</ul>
</li>
</ul>
<h2 id="Python版本管理器：pyenv"><a href="#Python版本管理器：pyenv" class="headerlink" title="Python版本管理器：pyenv"></a>Python版本管理器：pyenv</h2><p>管理多个 Python 版本的工具，可方便切换不同 Python 版本，隔离项目环境</p>
<ul>
<li><p>下载地址：<a href="https://github.com/pyenv/pyenv">pyenv&#x2F;pyenv: Simple Python version management</a></p>
<p>  注意添加环境配置还有前置编译包</p>
</li>
<li><p><strong>使用技巧</strong>：</p>
<ul>
<li><p><strong>快速查看可用版本</strong>：<code>pyenv install --list</code> 列出可安装的 Python 版本，加 grep 筛选：<code>pyenv install --list | grep &quot;3.11&quot;</code></p>
</li>
<li><p><strong>安装指定版本</strong>：<code>pyenv install 3.11.4</code>（安装后需执行 <code>pyenv rehash</code> 刷新命令）</p>
<ul>
<li><strong>灵活切换版本</strong>：<ul>
<li>全局默认：<code>pyenv global 3.11.4</code>（影响整个系统）</li>
<li>项目局部：<code>pyenv local 3.9.16</code>（仅当前目录生效，生成 <code>.python-version</code> 文件）</li>
<li>临时会话：<code>pyenv shell 3.8.18</code>（仅当前终端生效）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查看版本状态</strong>：<code>pyenv versions</code> 列出所有已安装版本（带 <code>*</code> 为当前使用版本）；<code>pyenv version</code> 显示当前版本</p>
</li>
<li><p><strong>卸载无用版本</strong>：<code>pyenv uninstall 3.7.17</code> 清理不再需要的版本</p>
</li>
<li><p><strong>配合插件增强</strong>：安装 <code>pyenv-virtualenv</code> 插件，可创建隔离虚拟环境：<code>pyenv virtualenv 3.11.4 myproj-env</code></p>
</li>
</ul>
</li>
<li><p>手动下载：</p>
<ul>
<li>文件放到 <code>~/.pyenv/cache/</code> 目录</li>
<li>然后<code>Installing Python-版本</code></li>
</ul>
</li>
</ul>
<h2 id="Jeb环境"><a href="#Jeb环境" class="headerlink" title="Jeb环境"></a>Jeb环境</h2><ul>
<li>安装步骤：<a href="https://blog.csdn.net/Sunshine_xiaohao/article/details/143464299">JEB 4.16.0 安装流程_jeb安装教程-CSDN博客</a></li>
<li>下载资源：<a href="https://www.52pojie.cn/thread-1645863-1-1.html">jeb-demo-4.16.0.202205110304和谐 - 吾爱破解 - 52pojie.cn</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘网址</title>
    <url>/2025/09/27/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>记录工具网址</p>
<p><a href="https://iloveofd.cn/word-compress">WORD压缩免费 - 缩小WORD体积 - iLoveOFD在线</a></p>
<p><a href="https://yasuo.xunjiepdf.com/word/">Word压缩 - 免费在线压缩Word文件大小 – 迅捷压缩在线</a></p>
<p><a href="https://remeins.com/">记灵在线工具 - 更专注于发现工具的实用性</a></p>
<p><a href="https://snapany.com/zh/youtube">YouTube高清视频在线下载 - 保存油管4K视频到本地</a></p>
<p><a href="https://www.yishuzi.cn/">Ai艺术字体在线生成_艺术字转换器_字体转换器_艺术字网</a></p>
<p><a href="https://app.diagrams.net/">未命名绘图 - draw.io</a></p>
<p><a href="https://www.remove.bg/zh">在线抠图软件_图片去除背景 | remove.bg – remove.bg</a></p>
<p><a href="https://blog.csdn.net/2303_79965980/article/details/146592400">win11怎么批量清理失效的环境变量_环境变量清理-CSDN博客</a></p>
<p><a href="https://zh.z-library.sk/">Z-Library – 世界上最大的电子图书馆。自由访问知识和文化。</a></p>
<p><a href="https://1元机场.com/#/login">一元机场</a></p>
<p><a href="https://down.52pojie.cn/Tools/">爱盘 - 最新的在线破解工具包</a></p>
<p>资源站</p>
<p><a href="https://www.fontsquirrel.com/fonts/list/find_fonts?filter%5Bclassifications%5D%5B0%5D=comic&filter%5Bclassifications%5D%5B1%5D=handdrawn&filter%5Bclassifications%5D%5B2%5D=programming&sort=popular">找免费字体| Font Squirrel</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p><a href="https://www.cnblogs.com/cxint/p/7209394.html">在虚拟机安装windows xp时所需要的序列号 - 煜叔 - 博客园</a></p>
<p><a href="https://repo.huaweicloud.com/java/jdk/">Index of java-local&#x2F;jdk</a></p>
<p><a href="https://mirrors.cloud.tencent.com/">腾讯软件源</a></p>
<p><a href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站</a></p>
<p><a href="https://www.landiannews.com/downloads/page/4">软件下载 – 第 4 页 – 蓝点网</a></p>
<p><a href="https://mirror.nyist.edu.cn/github-release/YerongAI/Office-Tool/">南阳理工学院开源镜像站 </a></p>
<p>学习平台</p>
<p><a href="https://www.ichunqiu.com/">【i春秋】-专注网络安全_信息安全_白帽子的在线学习_教育_培训平台</a></p>
<p><a href="https://bbs.kanxue.com/">看雪安全社区｜专业技术交流与安全研究论坛</a></p>
<p><a href="https://juejin.cn/">稀土掘金</a></p>
<p><a href="https://developer.android.google.cn/courses/android-basics-compose/course?hl=zh-cn">“Android 之 Compose 开发基础”课程  | Android Basics with Compose  | Android Developers</a></p>
<p><a href="https://www.jianshu.com/p/109a421302f1">Smali 语法 - 简书</a></p>
<p><a href="https://www.365exe.com/">三六五网络学院 - 专注个人技术能力视频教程网站|VIP教程论坛 - Powered by Discuz!</a></p>
<p><a href="https://gitcode.com/">AtomGit | GitCode - 全球开发者的开源社区,开源代码托管平台</a></p>
<p><a href="https://www.w3school.com.cn/index.html">w3school 在线教程</a></p>
<p>恶意代码分析</p>
<p><a href="https://github.com/Vxer-Lee/MalwareAnalysis">Vxer-Lee&#x2F;MalwareAnalysis: 恶意代码分析实战系列文章</a></p>
<p><a href="https://www.freebuf.com/column/2876">恶意代码分析实战系列 - FreeBuf网络安全行业门户</a></p>
]]></content>
  </entry>
  <entry>
    <title>等保测评学习笔记</title>
    <url>/2025/09/01/%E7%AD%89%E4%BF%9D%E6%B5%8B%E8%AF%84/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>适用于 各个行业的企业，特别是那些涉及到重要信息资产的行业。例如，金融、电信、能源、政府、军事等行业都需要进行等保测评。等保测评能够发现信息系统中存在的安全漏洞和风险，帮助企业即使采取措施加强安全防护，保护重要信息资产的安全。等保测评是企业遵守相关法律法规和合规要求的重要手段，通过评估和测试，企业可以确保自身信息系统的安全性达到国家标准和规范要求。还能提升企业信誉度。并且等保测评可发现潜在的信息泄露风险和漏洞，即使采取措施修复，从而避免因信息泄露而导致的损失和影响。</p>
<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><h4 id="初代（2007年前）"><a href="#初代（2007年前）" class="headerlink" title="初代（2007年前）"></a>初代（2007年前）</h4><ul>
<li><strong>1994 年</strong>，国务院颁布《计算机信息系统安全保护条例》（国务院 147 号令），首次以行政法规形式提出计算机信息系统实行安全等级保护。但因缺乏配套细则，初期实施效果有限。</li>
<li><strong>1999 年</strong>，公安部联合高校发布《计算机信息系统安全保护等级划分准则》（GB17859-1999），参考国际标准确立 5 级保护框架，为后续分级管理奠定基础。</li>
<li><strong>2003 年</strong>，中央办公厅 27 号文件明确 “实行信息安全等级保护”，将其纳入国家信息安全战略。</li>
<li><strong>2007 年</strong>，四部门联合发布《信息安全等级保护管理办法》，确立定级备案、建设整改、测评检查等 5 项核心流程，标志等级保护 1.0 正式启动。</li>
</ul>
<h4 id="1-0时代（2007年-2016年）"><a href="#1-0时代（2007年-2016年）" class="headerlink" title="1.0时代（2007年-2016年）"></a>1.0时代（2007年-2016年）</h4><ul>
<li><strong>2008 年</strong>，发布《信息安全技术 信息系统安全等级保护基本要求》（GB&#x2F;T22239-2008），从<strong>物理、网络、主机、应用、数据</strong> 5 个层面提出分等级的技术要求，成为等保 1.0 的核心技术依据。配套的测评、设计等标准陆续出台，形成完整技术框架。</li>
<li><strong>2010年</strong>，国家开始推动等级保护测评工作，要求各级政府部门和相关单位开展信息系统等级保护测评。</li>
</ul>
<h4 id="2-0时代（2016年至今）"><a href="#2-0时代（2016年至今）" class="headerlink" title="2.0时代（2016年至今）"></a>2.0时代（2016年至今）</h4><ul>
<li><strong>2017 年</strong>，《网络安全法》正式实施，将等级保护上升为法律义务，明确 “网络运营者应当履行安全保护义务”，并将关键信息基础设施纳入重点保护范围。</li>
<li><strong>2019 年</strong>，发布《网络安全等级保护基本要求》（GB&#x2F;T22239-2019）。</li>
<li><strong>2019年</strong>，《信息安全技术 网络安全等级保护定级指南》（GB&#x2F;T 22240-2020）等配套标准发布，进一步完善了等级保护测评体系。</li>
<li><strong>2020年</strong>，等保2.0相关标准全面实施，测评工作更加注重实际效果和安全能力的提升。</li>
</ul>
<h4 id="1-0和2-0的区别"><a href="#1-0和2-0的区别" class="headerlink" title="1.0和2.0的区别"></a>1.0和2.0的区别</h4><p>可以从对象、结构调整和防御理念三个方面进行详细阐述：</p>
<p><strong>对象</strong></p>
<ul>
<li><strong>等保1.0对象</strong><ul>
<li>主要针对的是计算机信息系统，关注点在于信息系统的安全防护。</li>
<li>重点保护的是政府机构重要信息系统的安全。</li>
</ul>
</li>
<li><strong>等保2.0对象</strong><ul>
<li>扩展到了网络运营者，不仅限于信息系统，还包括网络基础设施、数据处理系统等。</li>
<li>保护范围扩展到所有网络运营者，尤其是关键信息基础设施，如能源、交通、金融的等领域。</li>
</ul>
</li>
</ul>
<p><strong>结构调整</strong></p>
<ul>
<li><strong>等级划分</strong><ul>
<li><strong>等保1.0</strong>：等级划分较为粗放，主要分为五个等级。</li>
<li><strong>等保2.0</strong>：等级划分更加细致，每个等级的保护要求更加明确和具体。</li>
</ul>
</li>
<li><strong>标准体系</strong><ul>
<li><strong>等保1.0</strong>：标准体系较为分散，涉及多个不同标准文件。</li>
<li><strong>等保2.0</strong>：形成了更为同意和完善的标准体系，包括基于要求、定级指南、安全要求等多个标准。</li>
</ul>
</li>
<li><strong>测评体系</strong><ul>
<li><strong>等保1.0</strong>：测评体系较为基础，测评方法和流程较为简单。</li>
<li><strong>等保2.0</strong>：测评体系更加完善，测评流程更加科学，测评方法和工具更加先进。</li>
</ul>
</li>
<li><strong>管理体系</strong><ul>
<li><strong>等保1.0</strong>：管理要求叫相对较弱，侧重与技术层面的防护。</li>
<li><strong>等保2.0</strong>：增加了详细的管理要求，如安全管理、安全策略、风险管理等。</li>
</ul>
</li>
</ul>
<p><strong>防御理念</strong></p>
<ul>
<li><p><strong>静态与动态</strong></p>
<ul>
<li><strong>等保1.0</strong>：更多的静态的合规性检查，侧重于时候的安全评估</li>
<li><strong>等保2.0</strong>：强调动态保护和持续改进，要求进行持续的安全检测、风险评估和事件响应</li>
</ul>
</li>
<li><p><strong>被动与主动</strong></p>
<ul>
<li><strong>等保1.0</strong>：防御理念教委被动，主要是对已知的威胁的防御</li>
<li><strong>等保2.0</strong>：采取更加注定的防御理念，强调预测性防护和应对位置威胁的能力</li>
</ul>
</li>
<li><p><strong>合规性于失效性</strong></p>
<ul>
<li><p><strong>等保1.0</strong>：侧重于合规性，即满足一定的安全标准</p>
</li>
<li><p><strong>等保2.0</strong>：不仅要求合规，还强调安全防护的实际效果和能力，如应急响应、安全事件的预防和处理</p>
</li>
</ul>
</li>
<li><p><strong>防御范围</strong></p>
<ul>
<li><p><strong>等保1.0</strong>：防御单位较为狭窄，主要关注喜欢同的安全威胁</p>
</li>
<li><p><strong>等保2.0</strong>：防御范围更加广泛，包括传统安全威胁和新兴技术带来的安全挑战</p>
</li>
</ul>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>三大特点，十大变化。</p>
<p><strong>特点</strong>：对象范围扩大、分类结构统一、强调可信计算</p>
<p><strong>十大变化</strong>：标准名称变化、保护对象变化、安全要求变化、章节结构变化、分类结构变化、新增云计算安全扩展要求、新增移动互联网安全扩展要求、新增物联网安全扩展要求、新增工业控制系统安全扩展要求、增加应用场景要求。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><p>能源、交通、水利、金融、医疗卫生、教育各个领域的网络和信息系统。所见基本都涉及。</p>
<h4 id="保护对象等级划分"><a href="#保护对象等级划分" class="headerlink" title="保护对象等级划分"></a><strong>保护对象等级划分</strong></h4><ul>
<li><strong>第一级</strong>：一般网络，对国家安全、社会秩序和公共利益影响较小</li>
<li><strong>第二级</strong>：重要网络，对国家安全、社会秩序和公共利益有一定影响</li>
<li><strong>第三级</strong>：关键网络，对国家安全、社会秩序和公共利益有较大影响</li>
<li><strong>第四级</strong>：非常重要网络，对国家安全、社会秩序和公共利益有严重影响</li>
<li><strong>第五级</strong>：极其严重网络，对国家安全、社会秩序和公共利益极其严重的影响</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="1-定级阶段"><a href="#1-定级阶段" class="headerlink" title="1.定级阶段"></a>1.定级阶段</h5><ul>
<li><strong>定级对象识别</strong>：确定需要进行等级保护的网络和信息系统</li>
<li><strong>风险评估</strong>：对系统肯面临的安全风险进行评估，包括业务影响分析、威胁分析、脆弱性分析等。</li>
<li><strong>定级结果确定</strong>：根据风险评估结果，确定系统的安全保护等级。</li>
</ul>
<h5 id="2-备案阶段"><a href="#2-备案阶段" class="headerlink" title="2.备案阶段"></a>2.备案阶段</h5><ul>
<li><strong>备案申报</strong>：网络运营者向网络安全监管部门提交等级保护备案申请</li>
<li><strong>备案审核</strong>：监管部门对备案材料进行审核，确定备案信息的准确性</li>
</ul>
<h5 id="3-建设整改阶段"><a href="#3-建设整改阶段" class="headerlink" title="3.建设整改阶段"></a>3.建设整改阶段</h5><ul>
<li><strong>安全防护方案制定</strong>：根据顶级结果和备案要求，指定安全防护方案</li>
<li><strong>安全建设实施</strong>：按照安全防护方案，对网络和信息系统进行安全建设和整改</li>
<li><strong>安全措施验证</strong>：验证安全错是的有效性，确保系统达到备案要求</li>
</ul>
<h5 id="4-测评阶段"><a href="#4-测评阶段" class="headerlink" title="4.测评阶段"></a>4.测评阶段</h5><ul>
<li><strong>自评估</strong>：网络运营者自行评估系统的安全状况，确保符合等级保护要求</li>
<li><strong>第三方测评</strong>：选择第三方测评机构对系统进行测评，出局测评报告</li>
<li><strong>测评结果整改</strong>：根据测评报告，对发现的安全问题进行整改</li>
</ul>
<h5 id="5-监督与检查阶段"><a href="#5-监督与检查阶段" class="headerlink" title="5.监督与检查阶段"></a>5.监督与检查阶段</h5><ul>
<li><strong>日常监督</strong>：监管部门对网络运营者的安全防护措施进行日常监督</li>
<li><strong>定期检查</strong>：监督部门定期对网络运营者进行安全检查，确保等级保护措施的有效性</li>
</ul>
<h5 id="6-持续改进阶段"><a href="#6-持续改进阶段" class="headerlink" title="6.持续改进阶段"></a>6.持续改进阶段</h5><ul>
<li><strong>安全培训与教育</strong>：定期对相关人员开展安全培训和教育，提升安全意识</li>
<li><strong>安全事件处理</strong>：安全事件处理机制，对发生的安全事件进行有效响应和处理</li>
<li><strong>定期复审</strong>：定期复审等级保护措施，根据新的威胁和风险进行调整和优化</li>
</ul>
<h4 id="测评流程"><a href="#测评流程" class="headerlink" title="测评流程"></a>测评流程</h4><p>闭环过程，强调持续改进和动态防护。</p>
<h5 id="1-测评准备"><a href="#1-测评准备" class="headerlink" title="1.测评准备"></a>1.测评准备</h5><p>确定测评对象和范围；收集测评所需的资料和数据；指定测评计划和时间表。</p>
<h5 id="2-自我评估"><a href="#2-自我评估" class="headerlink" title="2.自我评估"></a>2.自我评估</h5><p>网络运营者自行评估系统的安全状况，确保符合等级保护要求；完成自我评估报告。</p>
<h5 id="3-第三方测评"><a href="#3-第三方测评" class="headerlink" title="3.第三方测评"></a>3.第三方测评</h5><p>选择第三方测评机构进行测评；第三方测评机构根据等保2.0测i奥准和要求，对系统进行全面测评。</p>
<h5 id="4-测评报告"><a href="#4-测评报告" class="headerlink" title="4.测评报告"></a>4.测评报告</h5><p>第三方测评机构出具测评报告，包括测评结果和整改建议；报告需详细描述测评过程发现的安全问题、风险评估和整改措施。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>等保测评</tag>
      </tags>
  </entry>
  <entry>
    <title>无线电与硬件基础</title>
    <url>/2025/08/12/%E6%97%A0%E7%BA%BF%E7%94%B5%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、频率与宽带（MHz、GHz）"><a href="#一、频率与宽带（MHz、GHz）" class="headerlink" title="一、频率与宽带（MHz、GHz）"></a>一、频率与宽带（MHz、GHz）</h2><h3 id="1-频率（Frequency）：信号的“频道号码”"><a href="#1-频率（Frequency）：信号的“频道号码”" class="headerlink" title="1.频率（Frequency）：信号的“频道号码”"></a>1.频率（Frequency）：信号的“频道号码”</h3><p>你可以把频率想象成电台的频道编号。比如你调到FM 98.8 听音乐，这个98.8 就是频率，单位是兆赫兹（MHz）。频率越高，信号的“编号”越大。</p>
<ul>
<li><p><strong>定义</strong>：频率是信号在单位时间内完成周期性变化的次数，单位为赫兹（Hz）。1 MHz &#x3D; 1,000,000 Hz，1 GHz &#x3D; 1,000,000,000 Hz。</p>
</li>
<li><p><strong>实际应用</strong>：</p>
<ul>
<li>普通收音机用88 - 108 MHz（兆赫兹）</li>
<li>家里的 Wi-Fi 用2.4 GHz或5GHz（吉赫兹）</li>
<li>5G手机通信会用到28GHz这样的高频段</li>
</ul>
</li>
<li><p><strong>数字关系</strong>：</p>
<p>  频率与波长成反比（波长 &#x3D; 光速 &#x2F; 频率）</p>
</li>
<li><p><strong>形象类比</strong>：</p>
<p>  就像电视台的频道，每个频道对应不同的信号源。不同频道的信号有不同特性：低频信号传播远但音质一般；高频信号能穿大量数据但容易被障碍物阻挡。</p>
</li>
</ul>
<h3 id="2-带宽（Bandwidth）：信息传输的“道路宽度”"><a href="#2-带宽（Bandwidth）：信息传输的“道路宽度”" class="headerlink" title="2.带宽（Bandwidth）：信息传输的“道路宽度”"></a>2.带宽（Bandwidth）：信息传输的“道路宽度”</h3><ul>
<li><p><strong>定义</strong>：</p>
<p>  宽带是信号所占据的频率范围，单位为Hz。例如，FM广播的宽带约为200 kHz，而5G毫米米波频段的宽带可达800 MHz。</p>
</li>
<li><p><strong>关键作用</strong>：</p>
<ul>
<li><strong>数据传输能力</strong>：带宽越大，可同时传输的数据量越多（例如高速公路车道越多，同行效率越高）。</li>
<li><strong>信号质量</strong>：高带宽支持更复杂的调制方式（如5G的QAM调制），提高抗干扰能力。</li>
</ul>
</li>
<li><p><strong>测量方法</strong>：</p>
<ul>
<li><strong>扫频法</strong>：使用信号发生器和频谱分析仪，通过扫描频率范围测量 - 3dB 点对应的带宽。</li>
<li><strong>噪声激励法</strong>：输入白噪声信号，分析输出信号的功率谱密度确定带宽。</li>
</ul>
</li>
</ul>
<h2 id="二、串行通信协议：UART、SPI、I2C"><a href="#二、串行通信协议：UART、SPI、I2C" class="headerlink" title="二、串行通信协议：UART、SPI、I2C"></a>二、串行通信协议：UART、SPI、I2C</h2><p>把设备间的通信想象成人类交流：不同协议就像不同语言，各有适合的场景。</p>
<h3 id="1-UART（通用异步收发传输器）"><a href="#1-UART（通用异步收发传输器）" class="headerlink" title="1.UART（通用异步收发传输器）"></a>1.UART（通用异步收发传输器）</h3><p>类似设备间的“电话聊天”，最简单的额通信方式，就像两个人打电话，不需要第三方协调（异步通信）。</p>
<ul>
<li><p><strong>原理</strong>：异步通信，通过起始位（低电平）和停止位（高电平）同步，无需时钟线。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>接口简单</strong>：仅需TX（发送）、RX（接收）、GND（地线）。</li>
<li><strong>传输速率</strong>：常见波特率有9600、115200等，受始终稳定性影响（高波特率需严格校准）。</li>
<li><strong>应用场景</strong>：短距离通信（如手机与外设）、调试串口（如Arduino的Serial Monitor）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Arduino调试串口</span></span><br><span class="line"><span class="comment">// 简单的UART通信代码</span></span><br><span class="line"><span class="built_in">void</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">begin</span>(<span class="number">9600</span>); <span class="comment">// 约定波特率9600（相当于说话速度）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;你好，UART！&quot;</span>); <span class="comment">// 通过TX发送数据</span></span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-SPI（串行外设接口）"><a href="#2-SPI（串行外设接口）" class="headerlink" title="2.SPI（串行外设接口）"></a>2.SPI（串行外设接口）</h3><p>类似高速数据的“快递专线”，有严格的发车。</p>
<ul>
<li><strong>原理</strong>：同步通信，主设备通过时钟线（SCK）控制数据传输，支持双全公。</li>
<li><strong>特点</strong>：<ul>
<li><strong>高速率</strong>：可达数十MHz，适合传感器（如加速度计）与微控制器通信。</li>
<li><strong>硬件组成</strong>：<ul>
<li>SCK（时钟线）：像节拍器，控制数据传输速度</li>
<li>MOSI（主发从收）：主设备发送数据</li>
<li>MISO（主发从发）：主设备接收数据</li>
<li>CS（片选线）：选择要通信的设备（像快递的收件地址）</li>
</ul>
</li>
<li><strong>工作模式</strong>：四种时钟极性（CPOL）和相位（CPHA）组合，需主从一致。</li>
</ul>
</li>
</ul>
<h3 id="3-I2C（集成电路总线）"><a href="#3-I2C（集成电路总线）" class="headerlink" title="3.I2C（集成电路总线）"></a>3.I2C（集成电路总线）</h3><ul>
<li><strong>原理</strong>：同步通信，使用两根线（SDA数据线、SCL时钟线），支持多设备挂载。</li>
<li><strong>特点</strong>：<ul>
<li><strong>低功耗</strong>：开漏输出，需上拉电阻，适合低速设备（如 EEPROM）。</li>
<li><strong>地址分配</strong>：每个从设备有唯一 7 位地址（如 0x48 为 ADC 芯片地址）。</li>
<li><strong>协议流程</strong>：起始信号（SDA 下降沿）→ 地址传输 → 数据传输 → 停止信号（SDA 上升沿）。</li>
</ul>
</li>
</ul>
<h2 id="协议对比表"><a href="#协议对比表" class="headerlink" title="协议对比表"></a>协议对比表</h2><table>
<thead>
<tr>
<th>特性</th>
<th>UART</th>
<th>SPI</th>
<th>I2C</th>
</tr>
</thead>
<tbody><tr>
<td><strong>同步方式</strong></td>
<td>异步（无时钟）</td>
<td>同步（主设备时钟）</td>
<td>同步（主设备时钟）</td>
</tr>
<tr>
<td><strong>线数</strong></td>
<td>2（TX&#x2F;RX）</td>
<td>3-4（SCK&#x2F;MOSI&#x2F;MISO&#x2F;CS）</td>
<td>2（SDA&#x2F;SCL）</td>
</tr>
<tr>
<td><strong>速率</strong></td>
<td>低速（kbps 级）</td>
<td>高速（Mbps 级）</td>
<td>低速（kbps 级）</td>
</tr>
<tr>
<td><strong>拓扑</strong></td>
<td>点对点</td>
<td>主从式（多从设备需 CS）</td>
<td>多设备总线</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>调试串口、蓝牙</td>
<td>传感器、存储芯片</td>
<td>传感器、EEPROM</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/2025/08/12/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、IP-地址、子网掩码、网关：网络世界的「户籍系统」"><a href="#一、IP-地址、子网掩码、网关：网络世界的「户籍系统」" class="headerlink" title="一、IP 地址、子网掩码、网关：网络世界的「户籍系统」"></a>一、IP 地址、子网掩码、网关：网络世界的「户籍系统」</h2><h3 id="1-IP-地址：设备的「全球门牌号」"><a href="#1-IP-地址：设备的「全球门牌号」" class="headerlink" title="1.IP 地址：设备的「全球门牌号」"></a>1.IP 地址：设备的「全球门牌号」</h3><ul>
<li><strong>作用</strong>：唯一标识网络中的设备，类似身份证号码。</li>
<li><strong>IPv4 格式</strong>：四段十进制数（如<code>192.168.1.10</code>），每段 0-255。</li>
<li><strong>分类</strong>：<ul>
<li><strong>公网 IP</strong>：全球唯一（如<code>202.96.134.133</code>），类似「国际地址」。</li>
<li><strong>私网 IP</strong>：局域网内使用（如<code>192.168.x.x</code>），类似「小区内门牌号」。</li>
</ul>
</li>
<li><strong>动态与静态</strong>：<ul>
<li><strong>动态 IP</strong>：路由器自动分配（如家庭网络），类似「租房地址」。</li>
<li><strong>静态 IP</strong>：手动固定（如公司服务器），类似「自有房产地址」。</li>
</ul>
</li>
</ul>
<h3 id="2-子网掩码：划分网络的「虚拟围墙」"><a href="#2-子网掩码：划分网络的「虚拟围墙」" class="headerlink" title="2. 子网掩码：划分网络的「虚拟围墙」"></a>2. 子网掩码：划分网络的「虚拟围墙」</h3><ul>
<li><strong>作用</strong>：区分 IP 地址中的网络部分和主机部分，类似邮政编码的区域划分。</li>
<li><strong>示例</strong>：<ul>
<li>IP 地址：<code>192.168.1.10</code></li>
<li>子网掩码：<code>255.255.255.0</code>（二进制前 24 位为 1）</li>
<li><strong>计算方法</strong>：<ul>
<li>网络号 &#x3D; <code>192.168.1.0</code>（IP 与掩码按位与运算）</li>
<li>主机号 &#x3D; <code>10</code>（最后一段剩余部分）</li>
</ul>
</li>
</ul>
</li>
<li><strong>CIDR 表示法</strong>：<code>192.168.1.0/24</code>，<code>/24</code>表示前 24 位为网络号。</li>
</ul>
<h3 id="3-网关：跨网络通信的「海关口岸」"><a href="#3-网关：跨网络通信的「海关口岸」" class="headerlink" title="3. 网关：跨网络通信的「海关口岸」"></a>3. 网关：跨网络通信的「海关口岸」</h3><ul>
<li><strong>作用</strong>：连接不同网络的桥梁，类似小区大门。</li>
<li><strong>示例</strong>：<ul>
<li>家庭路由器 IP 通常为<code>192.168.1.1</code>，作为局域网的默认网关。</li>
<li>数据从局域网发往互联网时，必须经过网关转发。</li>
</ul>
</li>
<li><strong>配置方式</strong>：<ul>
<li>自动获取：路由器通过 DHCP 协议分配。</li>
<li>手动设置：在设备网络属性中填写网关 IP。</li>
</ul>
</li>
</ul>
<h2 id="二、TCP-与-UDP：数据传输的「快递员」与「信使」"><a href="#二、TCP-与-UDP：数据传输的「快递员」与「信使」" class="headerlink" title="二、TCP 与 UDP：数据传输的「快递员」与「信使」"></a>二、TCP 与 UDP：数据传输的「快递员」与「信使」</h2><h3 id="1-TCP：可靠的「快递员」"><a href="#1-TCP：可靠的「快递员」" class="headerlink" title="1. TCP：可靠的「快递员」"></a>1. TCP：可靠的「快递员」</h3><ul>
<li><strong>核心特点</strong>：<ul>
<li><strong>三次握手</strong>：建立连接（类似电话确认）。</li>
<li><strong>数据确认</strong>：接收方回复 ACK 确认，丢包自动重传。</li>
<li><strong>流量控制</strong>：滑动窗口机制避免接收方过载。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>HTTP&#x2F;HTTPS</strong>：网页加载需确保数据完整。</li>
<li><strong>文件传输（FTP）</strong>：防止文件损坏。</li>
<li><strong>邮件协议（SMTP&#x2F;POP3）</strong>：确保邮件内容不丢失。</li>
</ul>
</li>
</ul>
<h3 id="2-UDP：高效的「信使」"><a href="#2-UDP：高效的「信使」" class="headerlink" title="2. UDP：高效的「信使」"></a>2. UDP：高效的「信使」</h3><ul>
<li><strong>核心特点</strong>：<ul>
<li><strong>无连接</strong>：直接发送数据（类似发短信）。</li>
<li><strong>轻量级</strong>：头部仅 8 字节（TCP 为 20 字节）。</li>
<li><strong>不可靠</strong>：不保证顺序和到达，但延迟极低。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>视频会议（Zoom）</strong>：优先实时性，少量丢包不影响体验。</li>
<li><strong>在线游戏（王者荣耀）</strong>：快速响应玩家操作。</li>
<li><strong>DNS 查询</strong>：单次请求无需建立连接。</li>
</ul>
</li>
</ul>
<h3 id="3-对比表格"><a href="#3-对比表格" class="headerlink" title="3. 对比表格"></a>3. 对比表格</h3><table>
<thead>
<tr>
<th>特性</th>
<th>TCP（快递员）</th>
<th>UDP（信使）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接方式</strong></td>
<td>面向连接（三次握手）</td>
<td>无连接</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠（重传机制）</td>
<td>不可靠（尽力而为）</td>
</tr>
<tr>
<td><strong>延迟</strong></td>
<td>高（需确认和重传）</td>
<td>极低（直接发送）</td>
</tr>
<tr>
<td><strong>典型应用</strong></td>
<td>网页浏览、文件传输</td>
<td>视频会议、在线游戏</td>
</tr>
</tbody></table>
<h3 id="三、常用端口号：服务的「房间号码」"><a href="#三、常用端口号：服务的「房间号码」" class="headerlink" title="三、常用端口号：服务的「房间号码」"></a>三、常用端口号：服务的「房间号码」</h3><h3 id="1-端口的作用"><a href="#1-端口的作用" class="headerlink" title="1. 端口的作用"></a>1. 端口的作用</h3><ul>
<li>区分同一设备上的不同服务，类似酒店房间号。</li>
<li><strong>范围</strong>：0-65535，其中 0-1023 为知名端口（系统保留）。</li>
</ul>
<h3 id="2-核心端口解析"><a href="#2-核心端口解析" class="headerlink" title="2. 核心端口解析"></a>2. 核心端口解析</h3><ul>
<li><strong>22（SSH）</strong>：<ul>
<li><strong>功能</strong>：安全远程登录。</li>
<li><strong>场景</strong>：通过命令行管理 Linux 服务器（如<code>ssh user@server</code>）。</li>
</ul>
</li>
<li><strong>80（HTTP）</strong>：<ul>
<li><strong>功能</strong>：未加密的网页传输。</li>
<li><strong>示例</strong>：访问<code>http://example.com</code>时默认使用 80 端口。</li>
</ul>
</li>
<li><strong>443（HTTPS）</strong>：<ul>
<li><strong>功能</strong>：加密网页传输（SSL&#x2F;TLS 协议）。</li>
<li><strong>示例</strong>：银行网站<code>https://bank.com</code>通过 443 端口传输数据。</li>
</ul>
</li>
</ul>
<h4 id="3-其他常见端口"><a href="#3-其他常见端口" class="headerlink" title="3. 其他常见端口"></a>3. 其他常见端口</h4><ul>
<li><strong>21（FTP）</strong>：文件传输协议，用于上传 &#x2F; 下载文件。</li>
<li><strong>53（DNS）</strong>：域名解析，将<code>www.baidu.com</code>转换为 IP 地址。</li>
<li><strong>3389（RDP）</strong>：Windows 远程桌面连接。</li>
</ul>
<h3 id="四、实用网络命令：排查问题的「瑞士军刀」"><a href="#四、实用网络命令：排查问题的「瑞士军刀」" class="headerlink" title="四、实用网络命令：排查问题的「瑞士军刀」"></a>四、实用网络命令：排查问题的「瑞士军刀」</h3><h4 id="1-ping：测试网络连通性"><a href="#1-ping：测试网络连通性" class="headerlink" title="1. ping：测试网络连通性"></a>1. ping：测试网络连通性</h4><ul>
<li><p><strong>作用</strong>：发送 ICMP 数据包，检查目标是否可达。</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>测试与百度服务器的连接：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"><span class="comment"># 输出类似：Reply from 220.181.38.148: bytes=32 time=30ms TTL=53</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>连续测试（Ctrl+C 终止）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping 192.168.1.1 -t</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-ipconfig-ifconfig：查看网络配置"><a href="#2-ipconfig-ifconfig：查看网络配置" class="headerlink" title="2. ipconfig&#x2F;ifconfig：查看网络配置"></a>2. ipconfig&#x2F;ifconfig：查看网络配置</h4><ul>
<li><p>Windows（ipconfig）：</p>
<ul>
<li><p>查看基本信息：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br><span class="line"><span class="comment"># 输出：IPv4地址、子网掩码、默认网关</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看详细信息：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br><span class="line"><span class="comment"># 包含DNS服务器、MAC地址等</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Linux&#x2F;macOS（ifconfig）：</p>
<ul>
<li><p>查看所有接口：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"><span class="comment"># 输出：eth0、wlan0等接口的IP地址、子网掩码</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-netstat：监控网络连接"><a href="#3-netstat：监控网络连接" class="headerlink" title="3. netstat：监控网络连接"></a>3. netstat：监控网络连接</h4><ul>
<li><p><strong>作用</strong>：查看当前网络连接、端口状态和路由表。</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>查看所有活动连接：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看特定端口的连接（如 80 端口）：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :80</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看路由表：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>实操·会员验证+猜数游戏</title>
    <url>/2025/08/11/%E5%AE%9E%E6%93%8D%C2%B7%E4%BC%9A%E5%91%98%E9%AA%8C%E8%AF%81-%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>内容：实现流程：打开 APP 先显示验证页 → 输入正确会员密码 → 跳转到猜数字游戏页。</p>
<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><ol>
<li>在“ New Project ”界面，选择<strong>Empty  Views Activity</strong>（空活动，最简单的模板），点击“ Next ”。</li>
<li>填写项目信息：<ul>
<li>Name（项目名）：<code>GuessTheNumbers</code></li>
<li>Package name（包名）：默认即可（类似<code>com.example.Guessthenumber</code>）</li>
<li>Save location（保存路径）：选一个自己能找到的文件夹</li>
<li>Language（语言）：选<strong>Java</strong>（更基础）</li>
<li>Minimum SDK（最低支持的安卓版本）：选默认的“ API 24 ”（覆盖大多数手机）</li>
</ul>
</li>
<li>点击“ Finish ”，等待项目加载完成（第一次可能会久一点，看网络）。</li>
</ol>
<h2 id="第二步-设计会员验证页面布局（activity-login-xml）"><a href="#第二步-设计会员验证页面布局（activity-login-xml）" class="headerlink" title="第二步 设计会员验证页面布局（activity_login.xml）"></a>第二步 设计会员验证页面布局（activity_login.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;会员验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_vip_password&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入会员密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_vip_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;点击验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_vip_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三步-会员验证页面逻辑（LoginActivity-java）"><a href="#第三步-会员验证页面逻辑（LoginActivity-java）" class="headerlink" title="第三步 会员验证页面逻辑（LoginActivity.java）"></a>第三步 会员验证页面逻辑（LoginActivity.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.guessthenumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText etVipPassword;</span><br><span class="line">    <span class="keyword">private</span> Button btnVipCheck;</span><br><span class="line">    <span class="keyword">private</span> TextView tvVipResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CORRECT_PASSWORD=<span class="string">&quot;vip666&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载布局</span></span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        <span class="comment">// 绑定控件（通过ID关联布局中的元素）</span></span><br><span class="line">        etVipPassword = findViewById(R.id.et_vip_password);</span><br><span class="line">        btnVipCheck = findViewById(R.id.btn_vip_check);</span><br><span class="line">        tvVipResult = findViewById(R.id.tv_vip_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮点击事件：验证密码并跳转</span></span><br><span class="line">        btnVipCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取用户输入的密码</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> etVipPassword.getText().toString().trim();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 验证逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (inputPassword.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 输入为空</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;请输入会员密码&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputPassword.equals(CORRECT_PASSWORD)) &#123;</span><br><span class="line">                    <span class="comment">// 密码正确：跳转到猜数字页面</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;验证成功，正在进入游戏...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建跳转意图（从当前页到游戏页）</span></span><br><span class="line">                    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(LoginActivity.<span class="built_in">this</span>, MainActivity.class);</span><br><span class="line">                    startActivity(intent); <span class="comment">// 执行跳转</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 关闭当前验证页（可选：防止返回键回到验证页）</span></span><br><span class="line">                    finish();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 密码错误</span></span><br><span class="line">                    <span class="comment">// （正确密码：vip666）</span></span><br><span class="line">                    tvVipResult.setText(<span class="string">&quot;密码错误，请重新输入&quot;</span>);</span><br><span class="line">                    <span class="comment">// 清空输入框</span></span><br><span class="line">                    etVipPassword.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第四步-设计猜数游戏页面布局（activity-main-xml）"><a href="#第四步-设计猜数游戏页面布局（activity-main-xml）" class="headerlink" title="第四步 设计猜数游戏页面布局（activity_main.xml）"></a>第四步 设计猜数游戏页面布局（activity_main.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;猜数游戏&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_game_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入0-100之间的数字&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_game_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;点击验证&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#CECECE&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_game_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="第五步-猜数游戏逻辑（MainActivity-java）"><a href="#第五步-猜数游戏逻辑（MainActivity-java）" class="headerlink" title="第五步 猜数游戏逻辑（MainActivity.java）"></a>第五步 猜数游戏逻辑（MainActivity.java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.guessthenumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控件声明</span></span><br><span class="line">    <span class="keyword">private</span> EditText etGameNumber;    <span class="comment">// 数字输入框</span></span><br><span class="line">    <span class="keyword">private</span> Button btnGameCheck;      <span class="comment">// 猜测按钮</span></span><br><span class="line">    <span class="keyword">private</span> TextView tvGameResult;    <span class="comment">// 结果提示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetGameNumber;     <span class="comment">// 目标随机数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minRange</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">// 当前范围最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRange</span> <span class="operator">=</span> <span class="number">100</span>;   <span class="comment">// 当前范围最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载布局</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定控件</span></span><br><span class="line">        etGameNumber = findViewById(R.id.et_game_number);</span><br><span class="line">        btnGameCheck = findViewById(R.id.btn_game_check);</span><br><span class="line">        tvGameResult = findViewById(R.id.tv_game_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成0-100的随机数（游戏初始化）</span></span><br><span class="line">        targetGameNumber = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">101</span>);  <span class="comment">// 0-100闭区间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 猜测按钮点击事件</span></span><br><span class="line">        btnGameCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取用户输入的数字</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> etGameNumber.getText().toString().trim();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 输入验证</span></span><br><span class="line">                <span class="keyword">if</span> (input.isEmpty()) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入数字后再猜～&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 转换为整数（处理非数字输入）</span></span><br><span class="line">                <span class="type">int</span> userNumber;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    userNumber = Integer.parseInt(input);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入有效的数字！&quot;</span>);</span><br><span class="line">                    etGameNumber.setText(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空错误输入</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 检查数字范围</span></span><br><span class="line">                <span class="keyword">if</span> (userNumber &lt; <span class="number">0</span> || userNumber &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;请输入0-100之间的数字！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 核心逻辑：对比用户输入与目标数字</span></span><br><span class="line">                <span class="keyword">if</span> (userNumber == targetGameNumber) &#123;</span><br><span class="line">                    <span class="comment">// 猜对了</span></span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;恭喜你！猜对了！🎉&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (userNumber &lt; targetGameNumber) &#123;</span><br><span class="line">                    <span class="comment">// 猜小了：更新最小值</span></span><br><span class="line">                    minRange = userNumber;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;猜小了～ 范围：&quot;</span> + minRange + <span class="string">&quot; 到 &quot;</span> + maxRange);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 猜大了：更新最大值</span></span><br><span class="line">                    maxRange = userNumber;</span><br><span class="line">                    tvGameResult.setText(<span class="string">&quot;猜大了～ 范围：&quot;</span> + minRange + <span class="string">&quot; 到 &quot;</span> + maxRange);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 清空输入框，方便下次输入</span></span><br><span class="line">                etGameNumber.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="第六步-配置文件（AndroidManifest-xml）"><a href="#第六步-配置文件（AndroidManifest-xml）" class="headerlink" title="第六步 配置文件（AndroidManifest.xml）"></a>第六步 配置文件（AndroidManifest.xml）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/taikongren&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/taikongren&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.GuessTheNumbers&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.LoginActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="完整流程测试步骤"><a href="#完整流程测试步骤" class="headerlink" title="完整流程测试步骤"></a>完整流程测试步骤</h2><ol>
<li><p>运行 APP，首先显示「会员验证页」。</p>
<p> 效果如下图所示：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508151645644.png" alt="会员验证界面"></p>
</li>
<li><p>输入正确密码 <code>vip666</code>（可在 <code>LoginActivity</code> 中修改）。</p>
</li>
<li><p>点击「验证并进入游戏」，自动跳转到「猜数字游戏页」。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508151646861.png" alt="猜数游戏界面"></p>
</li>
<li><p>在游戏页输入数字猜测，系统会提示范围（如 “猜小了～ 范围：20 到 100”）。</p>
</li>
<li><p>猜对后显示 “恭喜你！猜对了！🎉”。</p>
</li>
</ol>
<h2 id="核心技术点说明"><a href="#核心技术点说明" class="headerlink" title="核心技术点说明"></a>核心技术点说明</h2><ul>
<li><strong>页面跳转</strong>：通过 <code>Intent</code> 实现两个页面的切换，<code>startActivity(intent)</code> 触发跳转。</li>
<li><strong>启动页设置</strong>：<code>AndroidManifest.xml</code> 中，<code>LoginActivity</code> 包含 <code>&lt;intent-filter&gt;</code> 标记，因此成为 APP 打开的第一个页面。</li>
<li><strong>数据验证</strong>：两个页面都添加了输入检查（空输入、格式错误等），提升用户体验。</li>
<li><strong>生命周期管理</strong>：<code>finish()</code> 方法关闭验证页，防止用户按返回键回到验证页（可选逻辑）。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓实操</tag>
      </tags>
  </entry>
  <entry>
    <title>实操·开发简单APP</title>
    <url>/2025/08/11/%E5%AE%9E%E6%93%8D%C2%B7%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95APP/</url>
    <content><![CDATA[<p>内容：写一个“输入密码 → 验证” 的简单APP（含按钮点击事件、密码判断逻辑），生成APK。</p>
<p>工具：Android Studio 2024.2.1 Path 2</p>
<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><ol>
<li>在“ New Project ”界面，选择<strong>Empty  Views Activity</strong>（空活动，最简单的模板），点击“ Next ”。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508110117481.png" alt="New Project"></p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508110119734.png" alt="Empty Views Activity"></p>
<ol start="2">
<li>填写项目信息：<ul>
<li>Name（项目名）：<code>PassworkChecker</code></li>
<li>Package name（包名）：默认即可（类似<code>com.example.passworkchecker</code>）</li>
<li>Save location（保存路径）：选一个自己能找到的文件夹</li>
<li>Language（语言）：选<strong>Java</strong>（更基础）</li>
<li>Minimum SDK（最低支持的安卓版本）：选默认的“ API 24 ”（覆盖大多数手机）</li>
</ul>
</li>
<li>点击“ Finish ”，等待项目加载完成（第一次可能会久一点，看网络）。</li>
</ol>
<h2 id="第二步-设计界面（输入密码的页面）"><a href="#第二步-设计界面（输入密码的页面）" class="headerlink" title="第二步 设计界面（输入密码的页面）"></a>第二步 设计界面（输入密码的页面）</h2><p>需要一个“ 输入框 ”让用户输密码，一个“ 按钮 ”点击验证，一个“ 文字 ”显示结果。</p>
<ol>
<li><p>找到页面设计文件：</p>
<p> 在左侧“ Project ”面板中，展开<code>app &gt; res &gt; layout</code>，双击<code>activity_main.xml</code>（这是默认的页面布局文件）。</p>
</li>
<li><p>切换道“ 代码试图 ”：</p>
<p> 点击右上角的<strong>Code</strong>标签（默认可能时“ Design ”可视化视图，直接写简单代码更清晰）。</p>
</li>
<li><p>替换布局代码：</p>
<p> 把原来的代码全都删掉，编写一下代码：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 垂直排列的容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_hight</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:padding</span>=<span class="string">&quot;30dp&quot;</span>	&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_password&quot;</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>+&quot;<span class="attr">wrap_content</span>&quot;</span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;20dp&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 验证按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    	<span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_check&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;验证密码&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 结果显示文字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_result&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_higth</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span>	/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 左侧预览窗会显示：一个输入框、一个按钮、一个空白区域（用于显示结果）</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140114082.png"></p>
</li>
</ol>
<h2 id="第三步：写逻辑代码（点击按钮验证密码）"><a href="#第三步：写逻辑代码（点击按钮验证密码）" class="headerlink" title="第三步：写逻辑代码（点击按钮验证密码）"></a>第三步：写逻辑代码（点击按钮验证密码）</h2><p>点击 “验证密码” 按钮后，获取输入的密码，判断是否正确（比如设定正确密码是 “123456”），然后显示结果。</p>
<ol>
<li><p>找到逻辑代码文件：<br> 在左侧 “Project” 面板中，展开 <code>app &gt; java &gt; 包名（com.example.xxx）</code>，双击 <code>MainActivity.java</code>。</p>
</li>
<li><p>替换逻辑代码：<br> 把原来的代码全删掉，复制下面的代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.passwordchecker;  <span class="comment">// 这里的包名要和你项目的一致（默认不用改）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义控件变量（提前声明，方便后面使用）</span></span><br><span class="line">    <span class="keyword">private</span> EditText etPassword;  <span class="comment">// 密码输入框</span></span><br><span class="line">    <span class="keyword">private</span> Button btnCheck;      <span class="comment">// 验证按钮</span></span><br><span class="line">    <span class="keyword">private</span> TextView tvResult;    <span class="comment">// 结果显示文字</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 加载我们写的界面布局</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到界面中的控件（通过ID匹配）</span></span><br><span class="line">        etPassword = findViewById(R.id.et_password);</span><br><span class="line">        btnCheck = findViewById(R.id.btn_check);</span><br><span class="line">        tvResult = findViewById(R.id.tv_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给按钮设置“点击事件”：点击后执行验证逻辑</span></span><br><span class="line">        btnCheck.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 获取输入的密码（从输入框中取文字）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> etPassword.getText().toString();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 判断密码是否正确（这里设定正确密码是“123456”）</span></span><br><span class="line">                <span class="keyword">if</span> (password.equals(<span class="string">&quot;123456&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 正确：显示“验证成功”</span></span><br><span class="line">                    tvResult.setText(<span class="string">&quot;密码正确！验证通过～&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 错误：显示“密码错误”</span></span><br><span class="line">                    tvResult.setText(<span class="string">&quot;密码错误，请重新输入！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="第四步：运行-APP（在模拟器上测试）"><a href="#第四步：运行-APP（在模拟器上测试）" class="headerlink" title="第四步：运行 APP（在模拟器上测试）"></a>第四步：运行 APP（在模拟器上测试）</h2><ol>
<li>创建模拟器：<br> 点击顶部工具栏的 <strong>Device Manager</strong>（像手机一样的图标），点击 “Create device”，选择一个手机型号（比如 “Pixel 5”），点击 “Next”，选择一个安卓版本（比如 “Tiramisu”），下载后点击 “Finish”。</li>
<li>启动模拟器：<br> 在 Device Manager 中，点击刚创建的模拟器右侧的 “启动” 按钮（三角形），等待模拟器启动（第一次可能要几分钟，会显示一个安卓手机界面）。</li>
<li>运行 APP：<br> 点击 Android Studio 顶部的 <strong>Run</strong> 按钮（绿色三角形），选择刚才的模拟器，等待编译运行（底部会显示进度）。<br> 成功后，模拟器上会出现我们的 APP，打开后可以：<ul>
<li>在输入框中输入文字</li>
<li>点击 “验证密码” 按钮</li>
<li>看到结果（输入 “123456” 显示正确，其他显示错误）</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140113304.png"></p>
<h2 id="第五步：生成-APK-文件（可安装到手机的文件）"><a href="#第五步：生成-APK-文件（可安装到手机的文件）" class="headerlink" title="第五步：生成 APK 文件（可安装到手机的文件）"></a>第五步：生成 APK 文件（可安装到手机的文件）</h2><p>APK 是安卓应用的安装包，生成后可以传到自己的手机上安装。</p>
<ol>
<li><p>生成步骤：<br> 顶部菜单选择 **Build &gt; Build Bundle(s) &#x2F; APK(s) &gt; Build APK(s)**。<br> 等待编译完成，底部会提示 “APK generated successfully”，点击 “locate”，会打开文件夹，里面的 <code>app-debug.apk</code> 就是我们的安装包。</p>
</li>
<li><p>安装到手机：<br> 把 <code>app-debug.apk</code> 传到自己的安卓手机上（用微信 &#x2F; QQ 发送），在手机上点击该文件，按照提示安装（可能需要开启 “未知来源应用安装” 权限）。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508140126526.jpg"></p>
</li>
</ol>
<h3 id="总结一下核心逻辑"><a href="#总结一下核心逻辑" class="headerlink" title="总结一下核心逻辑"></a>总结一下核心逻辑</h3><ol>
<li>界面（XML）：用 3 个控件（输入框、按钮、结果文字）垂直排列。</li>
<li>逻辑（Java）：<ul>
<li>找到界面上的控件</li>
<li>给按钮设置点击事件</li>
<li>点击时获取输入的密码，和 “123456” 对比，显示结果</li>
</ul>
</li>
</ol>
<p>这个过程涵盖了安卓开发的基础：界面设计、控件操作、事件处理。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓实操</tag>
      </tags>
  </entry>
  <entry>
    <title>破解·壳与程序的特征</title>
    <url>/2025/08/11/%E7%A0%B4%E8%A7%A3%C2%B7%E5%A3%B3%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<p>学习链接：[破解基础知识之认识壳与程序的特征](<a href="https://www.52pojie.cn/thread-234739-1-1.html">【初学者教程】破解基础知识之认识壳与程序的特征 - 吾爱破解 - 52pojie.cn</a>)</p>
<p><strong>基础状态</strong>：程序在刚编译完成时，通常为无壳状态。</p>
<p><strong>无可程序差异</strong>：不同编译器编译的无壳程序存在区别（因编译器特性、生成机制不同）。</p>
<p><strong>学习逻辑</strong>：先认识不同编译器的无壳程序特征，是理解加壳后程序特征的基础（由基础到复杂，降低学习难度）。</p>
<p><strong>核心方法</strong>：通过对比无壳程序与加壳后程序，可明确两者的特征差异。</p>
<p><strong>特征确定维度</strong>：程序的核心特征主要从以下信息判断：</p>
<ul>
<li>入口点代码</li>
<li>程序区段</li>
<li>加载模块</li>
</ul>
<h2 id="VC6-编译无壳程序的核心特点"><a href="#VC6-编译无壳程序的核心特点" class="headerlink" title="VC6 编译无壳程序的核心特点"></a>VC6 编译无壳程序的核心特点</h2><h4 id="1-入口点代码特征（固定模板）"><a href="#1-入口点代码特征（固定模板）" class="headerlink" title="1.入口点代码特征（固定模板）"></a>1.入口点代码特征（固定模板）</h4><ul>
<li><p><strong>OD（OllyDbg）视角：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55          push ebp        ; 保存基址指针</span><br><span class="line">8B EC       mov ebp, esp    ; 建立新栈帧</span><br><span class="line">[若干压栈指令]  ; 不同程序的push地址可能不同（如参数、环境变量）</span><br><span class="line">call xxx     ; 调用VC6运行库初始化函数（如 __set_app_type、__p__fmode 等固定API）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键固定行为</strong>：无论程序逻辑如何，<strong>入口必包含压栈保环境 → 调用VC6运行库初始化</strong>的固定流程。</li>
<li><strong>与VS区别</strong>：VS编译的程序入口仅两行（<code>call + jmp</code>），无连接压栈和直接API调用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190151191.png"></p>
</li>
<li><p><strong>工具识别</strong>：</p>
<p>  PEID&#x2F;ExeinfoPE 直接标注为 <code>Microsoft Visual C++ ver 5.0/6.0</code>，入口点特征可辅助确认。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190152565.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190153467.png"></p>
</li>
</ul>
<h4 id="2-区段（Section）特征（固定四区段）"><a href="#2-区段（Section）特征（固定四区段）" class="headerlink" title="2. 区段（Section）特征（固定四区段）"></a><strong>2. 区段（Section）特征（固定四区段）</strong></h4><ul>
<li><p><strong>PEID&#x2F;ExeinfoPE 视角</strong>：</p>
<p>  区段固定为 4 个，无<code>.reloc</code>（重定位段）：</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>用途</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>包含程序指令，可读可执行</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读数据段</td>
<td>存储常量、字符串、导入表等</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>存储全局变量、静态变量</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>包含图标、对话框等二进制资源</td>
</tr>
</tbody></table>
<ul>
<li><strong>与 VS 区别</strong>：VS 编译的程序多一个<code>.reloc</code>段（用于基址重定位），区段总数为 5 个。</li>
</ul>
</li>
</ul>
<h4 id="3-运行库初始化行为（固定-API-调用）"><a href="#3-运行库初始化行为（固定-API-调用）" class="headerlink" title="3. 运行库初始化行为（固定 API 调用）"></a><strong>3. 运行库初始化行为（固定 API 调用）</strong></h4><ul>
<li>入口点调用的 API 固定指向 VC6 运行库（如 <code>MSVCRT.dll</code> 中的 <code>__set_app_type</code>、<code>__p__fmode</code> 等），用于初始化 C 运行时环境（如 I&#x2F;O 模式、浮点状态）。</li>
<li>不同程序的差异仅体现在<strong>压栈的参数地址</strong>（如命令行、环境变量指针），但 API 调用顺序和目标固定。</li>
</ul>
<h4 id="4-实际应用场景（逆向工程中的识别）"><a href="#4-实际应用场景（逆向工程中的识别）" class="headerlink" title="4.实际应用场景（逆向工程中的识别）"></a><strong>4.实际应用场景（逆向工程中的识别）</strong></h4><ul>
<li><strong>快速判断开发环境</strong>：通过 PEID 区段数（4 个）+ OD 入口指令（<code>push ebp + mov ebp, esp</code>）可秒级确认 VC6 编译。</li>
<li><strong>区分壳与无壳</strong>：若程序区段被混淆（如合并区段）或入口代码被加密，则可能加壳（需进一步脱壳）。</li>
<li><strong>对比易语言独立编译</strong>：易语言独立编译调用 VC 链接器，区段和入口特征与 VC6 完全一致，需结合其他特征（如易语言运行库函数）区分。</li>
</ul>
<h2 id="VS2008和VS2013编译无壳程序"><a href="#VS2008和VS2013编译无壳程序" class="headerlink" title="VS2008和VS2013编译无壳程序"></a>VS2008和VS2013编译无壳程序</h2><p>可从 <strong>入口点代码、程序区段、运行库 &#x2F; API 调用</strong> 三个维度分析特征，两者存在共性也有版本差异.</p>
<h3 id="一、共性核心特征"><a href="#一、共性核心特征" class="headerlink" title="一、共性核心特征"></a><strong>一、共性核心特征</strong></h3><h4 id="1-入口点代码：简洁的-“CALL-JMP”-结构"><a href="#1-入口点代码：简洁的-“CALL-JMP”-结构" class="headerlink" title="1.入口点代码：简洁的 “CALL + JMP” 结构"></a>1.<strong>入口点代码：简洁的 “CALL + JMP” 结构</strong></h4><ul>
<li><p><strong>指令形态</strong>：<br>  无壳程序入口仅 <strong>2 行核心指令</strong>，典型形式：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    00401005  ; 调用内部函数（实际跳转到运行库初始化）</span><br><span class="line">jmp     00401010  ; 跳转至真正的程序逻辑（如main函数前的初始化）</span><br></pre></td></tr></table></figure>

<p>  进入<code>call</code>后的子逻辑，会调用 <strong>固定的系统 &#x2F; 运行库 API</strong>（如初始化 C++ 运行时、获取系统时间等）。</p>
</li>
<li><p><strong>与 VC6 对比</strong>：<br>  VC6 入口有连续压栈（<code>push ebp</code>等）和多个 API 调用，而 VS 入口更 “紧凑”，通过间接跳转隐藏细节。</p>
</li>
</ul>
<h4 id="2-程序区段：新增-reloc段（支持-ASLR）"><a href="#2-程序区段：新增-reloc段（支持-ASLR）" class="headerlink" title="2. 程序区段：新增.reloc段（支持 ASLR）"></a>2. <strong>程序区段：新增<code>.reloc</code>段（支持 ASLR）</strong></h4><ul>
<li><p><strong>区段列表</strong>：<br>  相比 VC6 的 4 个区段（.text、.rdata、.data、.rsrc），VS 编译程序多一个 <strong><code>.reloc</code>段</strong>，用于 <strong>基址重定位</strong>（适配 Windows 的 ASLR 随机化加载机制）。</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>用途</th>
<th>特征说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>包含程序指令，可读可执行</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读数据段</td>
<td>存储常量、字符串、导入表等</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>存储全局变量、静态变量</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>包含图标、对话框等二进制资源</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td>重定位表</td>
<td>存储基址重定位信息</td>
</tr>
</tbody></table>
</li>
<li><p><strong>意义</strong>：<br>  <code>.reloc</code>记录了程序加载到非默认基址时，需要修正的地址偏移，是现代编译器对 “内存安全” 的适配。</p>
</li>
</ul>
<h3 id="二、版本差异（VS2008-vs-VS2013）"><a href="#二、版本差异（VS2008-vs-VS2013）" class="headerlink" title="二、版本差异（VS2008 vs VS2013）"></a><strong>二、版本差异（VS2008 vs VS2013）</strong></h3><h4 id="1-链接器版本与标识"><a href="#1-链接器版本与标识" class="headerlink" title="1. 链接器版本与标识"></a>1. <strong>链接器版本与标识</strong></h4><ul>
<li><strong>VS2008</strong>：链接器版本 <code>9.0</code>，工具（如 PEID）可检测到 “Microsoft Visual C++ 9.0” 标识。</li>
<li><strong>VS2013</strong>：链接器版本 <code>12.0</code>，标识为 “Microsoft Visual C++ 12.0”。</li>
</ul>
<h4 id="2-入口-API-调用细节"><a href="#2-入口-API-调用细节" class="headerlink" title="2. 入口 API 调用细节"></a>2. <strong>入口 API 调用细节</strong></h4><ul>
<li><p>VS2013：</p>
<p>  进入<code>call</code>后的初始化逻辑，更倾向调用现代系统 API（如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call KERNEL32.GetSystemTimeAsFileTime  ; 获取系统时间（高精度）</span><br><span class="line">call KERNEL32.GetCurrentProcessId      ; 获取进程ID</span><br><span class="line">call KERNEL32.GetCurrentThreadId       ; 获取线程ID</span><br></pre></td></tr></table></figure>

<p>  这些 API 在 VS2008 中可能被更早期的函数替代（如<code>GetSystemTime</code>而非<code>GetSystemTimeAsFileTime</code>）。</p>
</li>
</ul>
<h3 id="三、逆向分析中的识别方法"><a href="#三、逆向分析中的识别方法" class="headerlink" title="三、逆向分析中的识别方法"></a><strong>三、逆向分析中的识别方法</strong></h3><ol>
<li><p><strong>工具快速检测</strong>：</p>
<ul>
<li><strong>PEID&#x2F;ExeinfoPE</strong>：直接显示编译器版本（“VS2008” 或 “VS2013”），并验证<code>.reloc</code>区段存在。</li>
</ul>
</li>
<li><p><strong>OllyDbg 动态验证</strong>：加载程序后，入口指令若为 “<code>call + jmp</code>”，且跟随<code>call</code>后看到运行库初始化逻辑（如调用上述 KERNEL32 API），则符合 VS 特征。</p>
</li>
</ol>
<h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a><strong>总结对比表</strong></h3><table>
<thead>
<tr>
<th>维度</th>
<th>VS2008</th>
<th>VS2013</th>
</tr>
</thead>
<tbody><tr>
<td><strong>入口代码</strong></td>
<td>2 行（call + jmp），调用早期 API</td>
<td>2 行（call + jmp），调用现代 API</td>
</tr>
<tr>
<td><strong>区段</strong></td>
<td>含<code>.reloc</code>，共 5 个核心区段</td>
<td>含<code>.reloc</code>，共 5 个核心区段</td>
</tr>
<tr>
<td><strong>运行库</strong></td>
<td><code>msvcr90.dll</code>（动态）</td>
<td><code>msvcr120.dll</code>（动态）</td>
</tr>
<tr>
<td><strong>工具标识</strong></td>
<td>“Visual C++ 9.0”</td>
<td>“Visual C++ 12.0”</td>
</tr>
</tbody></table>
<h2 id="易语言编译无壳程序"><a href="#易语言编译无壳程序" class="headerlink" title="易语言编译无壳程序"></a>易语言编译无壳程序</h2><p><strong>核心背景</strong>：易语言编译依赖 <strong>VC 链接器</strong>（底层调用 VC 编译器），因此两种编译模式的特征与 <strong>VC 无壳程序</strong> 存在关联，但又因 “是否依赖外部运行库” 产生差异。</p>
<h3 id="一、核心区段结构特征（PEID-ExeinfoPE-视角）"><a href="#一、核心区段结构特征（PEID-ExeinfoPE-视角）" class="headerlink" title="一、核心区段结构特征（PEID&#x2F;ExeinfoPE 视角）"></a>一、核心区段结构特征（PEID&#x2F;ExeinfoPE 视角）</h3><p>易语言底层调用 <strong>VC 链接器</strong> 编译，因此区段框架与 VC6 无壳程序高度一致，但存在细微差异：</p>
<table>
<thead>
<tr>
<th>特征维度</th>
<th>具体表现</th>
</tr>
</thead>
<tbody><tr>
<td>区段数量</td>
<td>固定为 <strong>4 个核心区段</strong>（无 <code>.reloc</code> 区段），是区分现代 VS 编译程序（含 <code>.reloc</code>）的关键标志。</td>
</tr>
<tr>
<td>区段名称</td>
<td>标准命名：<code>.text</code>（代码段）、<code>.rdata</code>（只读数据）、<code>.data</code>（全局变量）、<code>.rsrc</code>（资源），无随机或异常区段名（加壳程序常见随机区段）。</td>
</tr>
<tr>
<td>区段属性</td>
<td><code>.text</code> 区段必含 <strong>可执行属性（Execute）</strong>，<code>.rdata</code> 为只读（Read），<code>.data</code> 可读写（Read&#x2F;Write），属性无异常（加壳程序可能篡改 <code>.text</code> 为不可执行）。</td>
</tr>
</tbody></table>
<h3 id="二、导入表特征（依赖库标识）"><a href="#二、导入表特征（依赖库标识）" class="headerlink" title="二、导入表特征（依赖库标识）"></a>二、导入表特征（依赖库标识）</h3><p>导入表是识别易语言程序的 <strong>核心依据</strong>，因编译模式（独立 &#x2F; 非独立）不同略有差异：</p>
<table>
<thead>
<tr>
<th>编译模式</th>
<th>导入表关键特征</th>
</tr>
</thead>
<tbody><tr>
<td>非独立编译</td>
<td><strong>必依赖易语言支持库</strong>：导入表中明确包含 <code>krnln.fnr</code>（易语言核心支持库）、<code>eapi.fnr</code>（扩展支持库）等易语言特有库，且函数名多为中文标识相关（如 <code>初始化环境</code> <code>创建窗口</code> 等）。 同时依赖 VC 基础运行库 <code>MSVCRT.dll</code>（因底层调用 VC 编译链）。</td>
</tr>
<tr>
<td>独立编译</td>
<td>无外部易语言支持库依赖（支持库被打包进 EXE），导入表仅依赖 <code>MSVCRT.dll</code> 等 VC 运行库，但 EXE 体积通常 <strong>明显更大</strong>（因内置支持库代码）。</td>
</tr>
</tbody></table>
<h3 id="三、入口代码特征（反汇编视角）"><a href="#三、入口代码特征（反汇编视角）" class="headerlink" title="三、入口代码特征（反汇编视角）"></a>三、入口代码特征（反汇编视角）</h3><p>易语言无壳程序的入口代码继承 VC6 特征，但存在细微区别：</p>
<ul>
<li><p>入口指令以 <code>PUSH EBP</code>、<code>MOV EBP, ESP</code> 等栈初始化指令开始（同 VC6 标准入口）。</p>
</li>
<li><p>早期易语言版本入口附近可能调用 <code>MSVCRT.dll!__getmainargs</code> 或 <code>_main</code> 函数（VC 运行库初始化逻辑）。</p>
</li>
<li><p>与纯 VC6 程序的区别：入口后续会跳转到易语言特有初始化逻辑（如支持库加载、窗口创建等），反汇编中可能出现中文函数名的字符串引用（如 <code>_启动窗口_创建完毕</code>）。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508191509164.png" alt="来源吾爱破解作者Hmily链接见文顶"></p>
</li>
</ul>
<h3 id="四、资源与字符串特征"><a href="#四、资源与字符串特征" class="headerlink" title="四、资源与字符串特征"></a>四、资源与字符串特征</h3><ul>
<li><p><strong>资源区段（.rsrc）</strong>：易语言程序通常包含大量窗体资源（对话框、按钮、文本框等），资源类型中可能存在 <code>DLG</code>（对话框）、<code>ICON</code>（图标）等，且资源名称可能含中文标识（如窗体标题）。</p>
</li>
<li><p>字符串特征：程序字符串中常出现易语言特有标识，例如：</p>
<ul>
<li><p>支持库相关：<code>krnln.fnr</code>、<code>eapi.fnr</code>、<code>支持库版本不兼容</code> 等（查看模块）。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508191510023.png" alt="来源吾爱破解作者Hmily链接见文顶"></p>
</li>
<li><p>运行逻辑相关：<code>_启动窗口_</code>、<code>_按钮1_被单击</code>、<code>信息框</code> 等中文函数或事件名。</p>
</li>
</ul>
</li>
</ul>
<h3 id="五、运行时行为特征"><a href="#五、运行时行为特征" class="headerlink" title="五、运行时行为特征"></a>五、运行时行为特征</h3><ul>
<li><strong>独立编译程序</strong>：运行时会在系统临时目录（如 <code>C:\Users\用户名\AppData\Local\Temp</code>）释放打包的支持库文件（<code>.fnr</code>&#x2F;<code>.fne</code>），程序退出后通常自动删除。</li>
<li><strong>非独立编译程序</strong>：若目标机未安装易语言或未放置对应支持库，运行时会弹窗报错（如 <code>找不到指定的支持库文件</code>），依赖外部库的特征明显。</li>
</ul>
<h3 id="关键区分点"><a href="#关键区分点" class="headerlink" title="关键区分点"></a>关键区分点</h3><ol>
<li>与 VC6 无壳程序的区别：VC6 程序无 <code>krnln.fnr</code> 等易语言库依赖，且字符串中无中文事件 &#x2F; 函数名；易语言程序即使独立编译，也可能在代码中残留支持库相关字符串。</li>
<li>与加壳程序的区别：加壳程序区段名称混乱（如 <code>.upx0</code>、<code>.pack</code>）、区段数量异常（通常 2-3 个），且导入表可能被隐藏（需脱壳后才能看到真实依赖）；而易语言无壳程序区段规范、导入表清晰。</li>
</ol>
<p>可以从程序里找一些call的调用最终都会走到上面核心代码图位置（文字不太好表达），这个方法可以区分和VC的区别，非独立编译比较容易识别，入口特征和模块特征都有krnln.fnr。</p>
<h2 id="Delhpi编译无壳程序"><a href="#Delhpi编译无壳程序" class="headerlink" title="Delhpi编译无壳程序"></a>Delhpi编译无壳程序</h2><h3 id="一、区段结构特征（PEID-ExeinfoPE-视角）"><a href="#一、区段结构特征（PEID-ExeinfoPE-视角）" class="headerlink" title="一、区段结构特征（PEID&#x2F;ExeinfoPE 视角）"></a>一、区段结构特征（PEID&#x2F;ExeinfoPE 视角）</h3><p>Delphi 编译器生成的 PE 区段结构相对固定，与 VC &#x2F; 易语言等有明显差异：</p>
<table>
<thead>
<tr>
<th>特征维度</th>
<th>具体表现</th>
</tr>
</thead>
<tbody><tr>
<td>区段数量</td>
<td>典型包含 <strong>4-5 个核心区段</strong>：<code>.text</code>（代码段）、<code>.data</code>（全局数据）、<code>.rsrc</code>（资源段）、<code>.idata</code>（导入表），部分版本可能含 <code>.reloc</code>（重定位表，通常较小或缺失）。</td>
</tr>
<tr>
<td>区段名称</td>
<td>区段命名规范且无随机名：<code>.text</code> 为可执行代码，<code>.data</code> 存放全局变量和常量，<code>.rsrc</code> 含窗体 &#x2F; 图标等资源，<code>.idata</code> 明确存储导入函数信息（无加壳程序的混乱区段名如 <code>.pack</code>）。</td>
</tr>
<tr>
<td>区段属性</td>
<td><code>.text</code> 必含 <strong>可执行属性（Execute）</strong>，<code>.data</code> 为读写属性（Read&#x2F;Write），<code>.rsrc</code> 和 <code>.idata</code> 为只读（Read），属性无异常篡改（加壳程序常将 <code>.text</code> 改为不可执行以隐藏代码）。</td>
</tr>
</tbody></table>
<h3 id="二、导入表特征（依赖库标识）-1"><a href="#二、导入表特征（依赖库标识）-1" class="headerlink" title="二、导入表特征（依赖库标识）"></a>二、导入表特征（依赖库标识）</h3><p>Delphi 程序依赖其专属运行时库（RTL）和组件库（VCL），导入表是识别的核心依据：</p>
<table>
<thead>
<tr>
<th>编译模式（静态 &#x2F; 动态）</th>
<th>导入表关键特征</th>
</tr>
</thead>
<tbody><tr>
<td>动态编译（默认）</td>
<td>依赖 <strong>Delphi 运行时 BPL 库</strong>：导入表中必含 <code>rtlXX.bpl</code>（RTL 核心库，XX 为版本号，如 <code>rtl100.bpl</code> 对应 Delphi 6）、<code>vclXX.bpl</code>（VCL 组件库，含窗体 &#x2F; 控件逻辑）。 同时依赖系统基础库：<code>kernel32.dll</code>、<code>user32.dll</code> 等，但核心逻辑依赖 BPL 库，函数名多为 Pascal 风格（如 <code>@System@Initialize</code>）。</td>
</tr>
<tr>
<td>静态编译（链接时嵌入）</td>
<td>无外部 BPL 库依赖（RTL&#x2F;VCL 代码被打包进 EXE），导入表仅含系统 API（如 <code>kernel32.dll!CreateFileA</code>、<code>user32.dll!MessageBoxA</code>），但程序体积 <strong>显著增大</strong>（因内置运行时库代码）。</td>
</tr>
<tr>
<td>函数名特征</td>
<td>导入函数名无 VC 风格的修饰符（如 <code>_函数名@参数大小</code>），多为原始 API 名或 Pascal 命名规范的函数（如 <code>@SysUtils@StrLen</code>），区分于 C&#x2F;C++ 程序的下划线前缀。</td>
</tr>
</tbody></table>
<h3 id="三、入口代码特征（反汇编视角）-1"><a href="#三、入口代码特征（反汇编视角）-1" class="headerlink" title="三、入口代码特征（反汇编视角）"></a>三、入口代码特征（反汇编视角）</h3><p>Delphi 程序入口点（OEP）代码逻辑固定，与其他编译器差异明显：</p>
<ul>
<li>入口指令以 <strong>栈初始化</strong> 开始：<code>PUSH EBP</code> → <code>MOV EBP, ESP</code> → <code>PUSH EBX</code> → <code>PUSH ESI</code> → <code>PUSH EDI</code>（标准 Pascal 函数栈帧）。</li>
<li>入口后直接调用 Delphi 运行时初始化函数：如 <code>@System@StartExe</code> 或 <code>@Vcl@Forms@TApplication@Initialize</code>（VCL 程序特有），无 VC 程序的 <code>__security_init_cookie</code> 等安全检查指令。</li>
<li>代码中大量使用 <strong>寄存器间接寻址</strong>（如 <code>MOV EAX, [ESI+0x14]</code>），因 Pascal 调用约定更依赖寄存器传递参数。</li>
</ul>
<h3 id="四、其他关键特征"><a href="#四、其他关键特征" class="headerlink" title="四、其他关键特征"></a>四、其他关键特征</h3><ol>
<li><strong>无壳与加壳区分</strong>：加壳 Delphi 程序区段名混乱（如 <code>.upx</code> 区段）、导入表被隐藏（需脱壳后才见 BPL 依赖），而无壳程序区段规范、导入表清晰可见。</li>
<li><strong>程序体积</strong>：动态编译的小型程序体积通常在 <strong>500KB-2MB</strong>（依赖 BPL 库），静态编译则可能达 <strong>5-10MB</strong>（内置 RTL&#x2F;VCL 代码），显著大于同功能的易语言程序。</li>
</ol>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用OllyDbg打开练习文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280031082.png"></p>
<h4 id="分区域细节分析"><a href="#分区域细节分析" class="headerlink" title="分区域细节分析"></a>分区域细节分析</h4><ol>
<li><strong>反汇编窗口（左上）：入口代码与逻辑</strong></li>
</ol>
<ul>
<li><strong>入口指令</strong>：<code>0044EDF4</code> 处的 <code>PUSH EBP ; MOV EBP, ESP</code>，是 <strong>Pascal 函数的标准栈帧初始化</strong>（旧版 Delphi 典型特征，区别于 VC 的简洁入口）。</li>
<li><strong>调用逻辑</strong>：后续 <code>CALL 吾爱破解.004xxxx</code> 均指向 <strong>程序内部函数</strong>（而非系统库或壳的解密逻辑），符合 Delphi 程序 “依赖自身运行时” 的特点。</li>
</ul>
<h5 id="2-寄存器窗口（右上）：运行时状态"><a href="#2-寄存器窗口（右上）：运行时状态" class="headerlink" title="2. 寄存器窗口（右上）：运行时状态"></a>2. <strong>寄存器窗口（右上）：运行时状态</strong></h5><ul>
<li><strong>EIP &#x3D; 0044EDF4</strong>：指向程序入口点（与 Exeinfo PE 的 <code>Entry Point</code> 一致），说明调试器正确定位到 <strong>原生 OEP（原始入口点）</strong>。</li>
<li><strong>LastErr &#x3D; ERROR_ENVVAR_NOT_FOUND</strong>：调试时的环境变量读取失败（非致命，仅为调试环境问题，不影响程序原生性）。</li>
</ul>
<h5 id="3-内存转储窗口（左下）：数据与字符串"><a href="#3-内存转储窗口（左下）：数据与字符串" class="headerlink" title="3. 内存转储窗口（左下）：数据与字符串"></a>3. <strong>内存转储窗口（左下）：数据与字符串</strong></h5><ul>
<li><strong>ASCII 区可见中文</strong>：如 <code>吾爱破解</code> 等字符串，是 <strong>程序自身的明文字符</strong>（加壳程序通常会加密字符串，此处无加密）。</li>
<li><strong>数据无混淆</strong>：十六进制数据无乱码或加密特征（如固定偏移的加密块），符合无壳程序的内存布局。</li>
</ul>
<h5 id="4-栈窗口（右下）：调用链与返回地址"><a href="#4-栈窗口（右下）：调用链与返回地址" class="headerlink" title="4. 栈窗口（右下）：调用链与返回地址"></a>4. <strong>栈窗口（右下）：调用链与返回地址</strong></h5><ul>
<li><strong>返回地址</strong>：<code>RETURN to KERNEL32.7608FC9</code>，指向系统库 <code>KERNEL32</code>，是 <strong>程序正常调用系统 API 的结束流程</strong>（如 <code>ExitProcess</code>），无壳的异常跳转（如壳的解密后跳转）。</li>
</ul>
<p>刚开始在使用Exeinfo PE从区段特征判断，我是判断该程序并非 Delphi 无壳原生程序，更可能是经过加壳处理的程序，原因如下：</p>
<ul>
<li>区段命名不规范<ul>
<li>出现了<code>CODE</code>、<code>DATA</code>、<code>BSS</code> 等<strong>自定义名称</strong></li>
</ul>
</li>
<li>区段数量异常<ul>
<li>多达 <strong>8 个区段</strong>，明显超出正常范围，壳会拆分&#x2F;伪造区段以隐藏原始代码</li>
</ul>
</li>
<li>区段属性矛盾<ul>
<li><code>.rdata</code> 区段（只读数据段）的 <code>Flags</code> 为 <code>50000040</code>（含 <strong>可执行属性</strong>），但 <code>.rdata</code> 正常应为 <strong>只读不可执行</strong>，此矛盾是<strong>壳的混淆特征</strong>（故意篡改区段属性，干扰调试））。</li>
<li><code>.reloc</code> 区段（重定位段）同样被标记为 <code>50000040</code>（可执行），不符合原生程序的只读属性。</li>
</ul>
</li>
</ul>
<p>但是查了一下，发现这只是旧版Delphi程序的“特殊特征”：</p>
<p>此前区段查看器中 <strong>自定义区段名（CODE、DATA 等）</strong> 看似异常，实际是 <strong>旧版 Delphi 编译器的历史特性</strong>：</p>
<ul>
<li>旧版 Delphi（2.0~7.0）允许 <strong>自定义区段命名</strong>（如 <code>CODE</code> 存代码，<code>DATA</code> 存数据），而非现代编译器的 <code>.text</code>&#x2F;<code>.data</code> 标准命名。</li>
<li>区段数量多（8 个）是因旧版编译器为 <strong>调试信息、资源、重定位表</strong> 单独创建区段，属于原生设计，并非加壳篡改。</li>
</ul>
<h2 id="加壳程序识别"><a href="#加壳程序识别" class="headerlink" title="加壳程序识别"></a>加壳程序识别</h2><h3 id="一、查壳工具识别法（特征码匹配原理）"><a href="#一、查壳工具识别法（特征码匹配原理）" class="headerlink" title="一、查壳工具识别法（特征码匹配原理）"></a><strong>一、查壳工具识别法（特征码匹配原理）</strong></h3><ol>
<li><p><strong>核心原理</strong>：<br> 工具内置 <strong>加壳程序特征库</strong>（如特征码、区段 &#x2F; 入口模式），通过对比程序数据判定壳类型。</p>
</li>
<li><p><strong>工具对比与优劣</strong>：</p>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>代表工具</th>
<th>特征库机制</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统工具</strong></td>
<td>PEiD、FFI 等</td>
<td>依赖公开库（如<code>userdb.txt</code>）</td>
<td>支持用户自定义特征，灵活扩展</td>
<td>特征库陈旧（多基于 2009 年前数据），对新壳（如 VMProtect）<strong>误报率高</strong>（如 VMProtect 常被误判为 UPolyX）</td>
</tr>
<tr>
<td><strong>现代工具</strong></td>
<td>Exeinfo PE</td>
<td>作者独立维护 + 新版支持外部库</td>
<td>对新壳（VMProtect、Themida、WinLicense 等）识别更准，覆盖范围广</td>
<td>早期版本不支持自定义特征，对壳版本识别模糊</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="二、手动特征识别法（区段-入口分析）"><a href="#二、手动特征识别法（区段-入口分析）" class="headerlink" title="二、手动特征识别法（区段 + 入口分析）"></a><strong>二、手动特征识别法（区段 + 入口分析）</strong></h3><ol>
<li><strong>核心维度</strong>：<br> 突破工具局限，通过 <strong>程序自身结构特征</strong> 判断，适用于新壳 &#x2F; 定制壳。</li>
<li><strong>区段信息分析</strong>：<ul>
<li><strong>查看方式</strong>：PEiD&#x2F;Exeinfo PE 的 “区段查看” 功能（如 PEiD 的 EP 区段按钮）。</li>
<li><strong>判断逻辑</strong>：<ul>
<li>异常区段：壳常篡改区段名（如<code>.upx0</code>、<code>.pack</code>）、数量（2-3 个冗余区段）、属性（代码段标记为不可执行）。</li>
<li>典型壳特征：Themida&#x2F;WinLicense 会生成<code>._OVR</code>等特殊区段；压缩壳（如 UPX）区段数据高度压缩。</li>
</ul>
</li>
</ul>
</li>
<li><strong>入口代码分析</strong>：<ul>
<li><strong>查看方式</strong>：OllyDbg 载入后，**<code>Ctrl+A</code>**让 OD 分析入口代码，观察指令、字符串特征。</li>
<li><strong>判断逻辑</strong>：<ul>
<li>壳的入口多为 <strong>解密 &#x2F; 解压逻辑</strong>（如循环异或、调用系统 API 前的混淆指令）。</li>
<li>典型壳特征：Safengine 壳入口有<code>SE</code>相关字符串；VProtect 入口含特定跳转模式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="三、方法互补性"><a href="#三、方法互补性" class="headerlink" title="三、方法互补性"></a><strong>三、方法互补性</strong></h3><ul>
<li><strong>工具优先</strong>：快速筛除已知壳（如传统压缩壳、老版本加密壳），降低分析成本。</li>
<li><strong>手动兜底</strong>：面对新壳（如定制 VMProtect）、特征库未覆盖的壳，通过区段 + 入口特征定位脱壳方向。</li>
</ul>
<p><strong>总结</strong>：查壳工具是 “快速筛子”，手动分析是 “深度探针”，两者结合可覆盖绝大多数加壳识别场景。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="无壳的-NET-程序"><a href="#无壳的-NET-程序" class="headerlink" title="无壳的 .NET 程序"></a>无壳的 .NET 程序</h3><p>文件：吾爱破解论坛学习脱壳实例_.NET.rar</p>
<p>工具：Exeinfo PE</p>
<h4 id="一、核心信息解读"><a href="#一、核心信息解读" class="headerlink" title="一、核心信息解读"></a><strong>一、核心信息解读</strong></h4><ol>
<li><p><strong>编译器与平台</strong>：<br> Exeinfo PE 检测显示：<code>MS Visual C# / Basic.NET [Link 11]</code>，说明程序由 <strong>.NET 框架</strong> 编写（C# 或 <a href="https://vb.net/">VB.NET</a> 语言），链接器版本对应 .NET Framework 相关编译工具（如 Visual Studio 的 C# 编译器）。</p>
</li>
<li><p><strong>是否加壳</strong>：</p>
<ul>
<li>工具未报 “加壳” 相关标识（如 <code>Packed by XXX</code>），反而提示 <code>try Analyze with .NET Reflector</code>（建议用 .NET 反编译工具分析），说明 <strong>程序无传统加密壳</strong>（传统壳会篡改区段 &#x2F; 入口，此程序区段规范、检测逻辑指向原生 .NET 程序）。</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508200022298.png"></p>
</li>
</ol>
<h4 id="二、区段特征分析（3-个区段，符合无壳-NET-程序规律）"><a href="#二、区段特征分析（3-个区段，符合无壳-NET-程序规律）" class="headerlink" title="二、区段特征分析（3 个区段，符合无壳 .NET 程序规律）"></a><strong>二、区段特征分析（3 个区段，符合无壳 .NET 程序规律）</strong></h4><table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>属性（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><code>00002000</code></td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>IL 代码</strong>（.NET 中间语言）和预编译的本机代码，是程序逻辑核心区。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td><code>00006000</code></td>
<td>只读（Read）</td>
<td>存储程序资源（图标、字符串、版本信息等），无执行属性，符合资源段规范。</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td><code>00008000</code></td>
<td>只读（Read）</td>
<td>存储基址重定位信息，适配 Windows 加载器的 ASLR 机制，是 PE 格式的标准区段。</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508200022526.png"></p>
<h4 id="三、-NET-程序的-“非壳”-保护说明"><a href="#三、-NET-程序的-“非壳”-保护说明" class="headerlink" title="三、.NET 程序的 “非壳” 保护说明"></a><strong>三、.NET 程序的 “非壳” 保护说明</strong></h4><p>虽然程序无 <strong>传统加密壳</strong>（如 UPX、VMProtect），但 .NET 程序常通过 <strong>代码混淆器</strong>（如 ConfuserEx、SmartAssembly）进行保护：</p>
<ul>
<li>混淆 vs 加壳：<ul>
<li>加壳：加密 PE 代码段，运行时动态解密（篡改区段、入口逻辑）；</li>
<li>混淆：修改 IL 代码结构（如重命名类 &#x2F; 方法、插入冗余代码），但 <strong>不改变 PE 区段的原生性</strong>（区段名、属性仍符合 .NET 程序特征）。</li>
</ul>
</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>文件本质</strong>：无壳的 .NET 程序（C#&#x2F;<a href="https://vb.net/">VB.NET</a> 编写），依赖 .NET Framework 运行时。</p>
<h3 id="AutoIt-脚本编译的可执行程序"><a href="#AutoIt-脚本编译的可执行程序" class="headerlink" title="AutoIt 脚本编译的可执行程序"></a><strong>AutoIt 脚本编译的可执行程序</strong></h3><p>(AutoIt 编译的程序并非传统加密壳，而是 <strong>脚本打包器产物</strong>)</p>
<h4 id="一、核心识别结论"><a href="#一、核心识别结论" class="headerlink" title="一、核心识别结论"></a>一、核心识别结论</h4><ol>
<li><p><strong>Exeinfo PE 关键提示</strong>：</p>
<ul>
<li>底部信息：<code>AutoIt v3.3.12.0 - Jonathan Bennett &amp; AutoIt Team</code> → 明确为 <strong>AutoIt 编译产物</strong>（AutoIt 是 Windows 脚本语言，编译后生成 EXE，内置解释器 + 脚本）。</li>
<li>附加说明：<code>Exe2Aut.exe decompiler, &quot;AU3&quot; packed scr...</code> → 可通过 <code>Exe2Aut</code> 工具 <strong>反编译提取内部 AU3 脚本</strong>，暗示程序内含 “打包的脚本数据”。</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280032853.png"></p>
</li>
</ol>
<h4 id="二、Autolt编译程序的“打包特征”分析"><a href="#二、Autolt编译程序的“打包特征”分析" class="headerlink" title="二、Autolt编译程序的“打包特征”分析"></a>二、Autolt编译程序的“打包特征”分析</h4><ol>
<li><strong>区段与数据特征</strong></li>
</ol>
<ul>
<li><p><strong>区段命名</strong>：<code>.text</code>（代码段，存 AutoIt 解释器代码）、<code>.rdata</code>（只读数据，存字符串 &#x2F; 导入表）、<code>.data</code>（全局数据，存脚本压缩包）、<code>.rsrc</code>（资源，存图标等），命名规范但 <strong>数据段隐藏脚本</strong>。</p>
</li>
<li><p><strong>数据隐藏</strong>：</p>
<ul>
<li><code>.data</code> 或 <code>.rdata</code> 段可能包含 <strong>压缩的 AU3 脚本数据</strong>（AutoIt 编译时会将脚本压缩后嵌入 EXE），可通过 <code>Exe2Aut</code> 解包提取。</li>
<li>区段的 <code>First bytes</code> 无明显加密特征（因是 “打包” 而非 “加密壳”，脚本仅压缩，未加密）。</li>
</ul>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280032097.png"></p>
</li>
</ul>
<h4 id="2-入口代码与运行时特征（OllyDbg-视角）"><a href="#2-入口代码与运行时特征（OllyDbg-视角）" class="headerlink" title="2. 入口代码与运行时特征（OllyDbg 视角）"></a>2. <strong>入口代码与运行时特征（OllyDbg 视角）</strong></h4><ul>
<li><strong>入口指令</strong>：<code>CALL 吾爱破解.00B62DE3</code> → 调用 <strong>AutoIt 解释器的初始化函数</strong>（负责解压脚本、加载运行时环境），而非传统壳的 “解密代码”。</li>
<li><strong>运行时依赖</strong>：导入表会包含 <code>AutoIt3.dll</code> 相关函数（若动态链接），或直接内置解释器代码（静态编译，体积较大）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280033284.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>该程序 <strong>不是传统加密壳</strong>，而是 <strong>AutoIt 脚本的编译产物</strong>，其 “打包特征” 体现在：</p>
<ul>
<li>内置 AutoIt 解释器，区段隐藏压缩脚本；</li>
<li>可被 <code>Exe2Aut</code> 等工具直接解包；</li>
<li>入口指向解释器初始化函数，而非解密逻辑。</li>
</ul>
<h3 id="TASM-FASM-编译"><a href="#TASM-FASM-编译" class="headerlink" title="TASM&#x2F;FASM 编译"></a><strong>TASM&#x2F;FASM 编译</strong></h3><p>(纯汇编编写的无壳程序)</p>
<h4 id="一、核心结论"><a href="#一、核心结论" class="headerlink" title="一、核心结论"></a>一、核心结论</h4><ol>
<li><strong>编译器与类型</strong>：<br> Exeinfo PE 检测显示：<code>TASM / FASM (MASM - compatible assembler) - Linker: 5.12</code>，说明程序由 <strong>TASM（Turbo Assembler）或 FASM（Flat Assembler，兼容 MASM 语法）</strong> 编译，属于 <strong>手写汇编程序</strong>（无高级语言依赖）。</li>
<li><strong>是否加壳</strong>：<ul>
<li>工具明确标记 <code>Not packed</code>（未加壳）；</li>
<li>区段、入口、导入表均符合 <strong>原生 PE 程序特征</strong>（无壳的篡改痕迹）。</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280033239.png"></p>
<h4 id="二、无壳特征的多维度验证"><a href="#二、无壳特征的多维度验证" class="headerlink" title="二、无壳特征的多维度验证"></a>二、无壳特征的多维度验证</h4><h4 id="1-区段特征（4-个规范区段）"><a href="#1-区段特征（4-个规范区段）" class="headerlink" title="1. 区段特征（4 个规范区段）"></a>1. <strong>区段特征（4 个规范区段）</strong></h4><table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>标志（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td><code>00001000</code></td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>手写汇编指令</strong>（程序核心逻辑），指令直接对应机器码，无加密 &#x2F; 混淆。</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td><code>00002000</code></td>
<td>只读（Read）</td>
<td>存储 <strong>只读常量</strong>（如字符串、API 导入表），数据未加密，可直接解析。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td><code>00003000</code></td>
<td>可读写（Read&#x2F;Write）</td>
<td>存储 <strong>全局变量</strong>（如未初始化数据），无异常属性（如壳会将数据段标记为可执行）。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td><code>00004000</code></td>
<td>只读（Read）</td>
<td>存储 <strong>资源数据</strong>（如图标、版本信息），命名和属性均符合 PE 标准，无篡改。</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280033090.png"></p>
<h4 id="2-入口代码特征（OllyDbg-反汇编）"><a href="#2-入口代码特征（OllyDbg-反汇编）" class="headerlink" title="2. 入口代码特征（OllyDbg 反汇编）"></a>2. <strong>入口代码特征（OllyDbg 反汇编）</strong></h4><ul>
<li><strong>指令逻辑</strong>：入口 <code>00401088</code> 处直接调用 <strong>系统 API</strong>（如 <code>kernel32.GetModuleHandleA</code>、<code>user32.DialogBoxParamA</code>），无壳的 <strong>解密 &#x2F; 解压前置逻辑</strong>（如循环异或、跳转混淆）。</li>
<li><strong>调用链</strong>：所有调用均指向 <code>kernel32.dll</code>、<code>user32.dll</code> 等系统库，无异常第三方库（如壳的运行时库），符合 <strong>纯汇编程序直接调用系统 API 的特征</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280033485.png"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>该程序是 <strong>TASM&#x2F;FASM 编译的纯汇编无壳程序</strong>，特征为：</p>
<ul>
<li>汇编器编译标识明确，无加壳标记；</li>
<li>区段规范、属性正常，无篡改；</li>
<li>入口直接调用系统 API，逻辑清晰，无混淆。</li>
</ul>
<h3 id="Borland-C-6-0-编译无壳程序"><a href="#Borland-C-6-0-编译无壳程序" class="headerlink" title="Borland C++ 6.0 编译无壳程序"></a>Borland C++ 6.0 编译无壳程序</h3><h4 id="一、编译器与无壳的核心判定"><a href="#一、编译器与无壳的核心判定" class="headerlink" title="一、编译器与无壳的核心判定"></a><strong>一、编译器与无壳的核心判定</strong></h4><ol>
<li><p><strong>ExeinfoPE 关键标识</strong>：</p>
<ul>
<li>检测结果：<code>Borland C++ - Copyright 2002 Borland Info Corporation</code> → 明确为 <strong>Borland C++ 6.0</strong> 编译（经典老版 C++ 编译器，区别于微软 VC）。</li>
<li>链接器版本：<code>Linker Info: 5.00</code> → 匹配 BC++6 的默认链接器版本。</li>
<li>加壳判定：<code>Not packed</code>（未加壳），结合区段、入口特征验证。</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280033468.png"></p>
</li>
</ol>
<h4 id="二、区段特征（8-个区段的结构解析）"><a href="#二、区段特征（8-个区段的结构解析）" class="headerlink" title="二、区段特征（8 个区段的结构解析）"></a><strong>二、区段特征（8 个区段的结构解析）</strong></h4><p>BC++6 编译的程序区段 <strong>划分更细</strong>（对比 VC6 的 4 个区段），典型区段及意义：</p>
<table>
<thead>
<tr>
<th>区段名</th>
<th>虚拟地址</th>
<th>标志（Flags）</th>
<th>用途与特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>代码段</td>
<td>可执行（Execute）+ 可读（Read）</td>
<td>存储 <strong>程序指令</strong>，包含 Borland C++ 运行时初始化逻辑（区别于 VC 的 MSVCRT 依赖）。</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>数据段</td>
<td>可读写（Read&#x2F;Write）</td>
<td>存储 <strong>全局 &#x2F; 静态变量</strong>，BC++6 的数据段可能包含 Borland 运行库的初始化数据。</td>
</tr>
<tr>
<td><code>.rdata</code></td>
<td>只读段</td>
<td>只读（Read）</td>
<td>存储 <strong>常量、字符串、只读数据</strong>，但 **导入表独立存于 <code>.idata</code>**（VC6 常将导入表放 <code>.rdata</code>）。</td>
</tr>
<tr>
<td><code>.idata</code></td>
<td>导入段</td>
<td>只读（Read）</td>
<td>单独存储 <strong>导入表</strong>（系统 API 及 Borland 运行库函数），结构清晰，便于逆向分析。</td>
</tr>
<tr>
<td><code>.edata</code></td>
<td>导出段</td>
<td>可执行（Execute）+ 读（Read）</td>
<td>若程序有导出函数，会单独存于 <code>.edata</code>（VC6 通常无此区段，或合并到其他段）。</td>
</tr>
<tr>
<td><code>.rsrc</code></td>
<td>资源段</td>
<td>只读（Read）</td>
<td>存储 <strong>图标、对话框、版本信息</strong>，命名和结构符合 PE 标准，无混淆。</td>
</tr>
<tr>
<td><code>.reloc</code></td>
<td>重定位段</td>
<td>只读（Read）</td>
<td>存储基址重定位信息，适配 Windows 加载器（类似 VS 系列的 <code>.reloc</code>，但 BC++6 更少见）。</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280034027.png"></p>
<h4 id="三、入口代码与运行时特征（OllyDbg-视角）"><a href="#三、入口代码与运行时特征（OllyDbg-视角）" class="headerlink" title="三、入口代码与运行时特征（OllyDbg 视角）"></a><strong>三、入口代码与运行时特征（OllyDbg 视角）</strong></h4><ol>
<li><strong>入口指令逻辑</strong>：<ul>
<li>入口 <code>004012FC</code> 处可见 <code>JMP SHORT</code> 跳转 + 连续 <code>DB</code> 指令（如 <code>DB 66</code>、<code>DB 32</code>）→ 这些 <code>DB</code> 是 <strong>嵌入代码段的字符串或常量</strong>（BC++6 编译时会将短字符串直接放在代码段附近，而非单独的 <code>.rdata</code> 偏移，是老编译器的特征）。</li>
<li>后续调用 <code>kernel32.GetModuleHandleA</code> 等系统 API，同时隐含 <strong>Borland 运行库的初始化逻辑</strong>（如内存管理、异常处理，因 BC++6 依赖自身运行库 <code>borlndmm.dll</code> 等，若静态链接则无导入，需从代码中识别）。</li>
</ul>
</li>
<li><strong>运行时依赖</strong>：<ul>
<li>若动态链接 Borland 库，导入表会含 <code>borlndmm.dll</code>（内存管理）、<code>vcl60.bpl</code>（VCL 组件，若用可视化库）；</li>
<li>若静态链接，导入表仅含系统 API（如 <code>kernel32.dll</code>、<code>user32.dll</code>），但程序体积更大（内置 Borland 运行时代码）。</li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508280034616.png"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>该程序是 <strong>Borland C++ 6.0 编译的无壳原生程序</strong>，特征为：</p>
<ul>
<li>编译器标识明确，工具判定无壳；</li>
<li>区段划分精细（8 个区段，含独立导入段 <code>.idata</code>）；</li>
<li>代码段嵌入短字符串（<code>DB</code> 指令），运行时隐含 Borland 库逻辑；</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>smali</title>
    <url>/2025/08/10/smali/</url>
    <content><![CDATA[<h2 id="一、什么是-Smali？"><a href="#一、什么是-Smali？" class="headerlink" title="一、什么是 Smali？"></a>一、什么是 Smali？</h2><p>你可以把 Smali 理解为**Android 应用的 “汇编语言”**。就像电脑程序的 C 语言会被编译成汇编语言一样，Android 的 Java 代码会被编译成<code>.dex</code>文件，而 Smali 就是<code>.dex</code>文件反编译后的 “可读形式”。</p>
<ul>
<li>作用：修改 Smali 代码 &#x3D; 直接修改 Android 应用的逻辑（比如破解付费功能、去除广告）</li>
<li>特点：基于 “寄存器” 工作（所有数据都存在寄存器里，类似我们用的变量）</li>
<li>工具：通过 APKTool 等工具可以把 APK 里的<code>.dex</code>文件转成 Smali 代码，修改后再转回去</li>
</ul>
<h2 id="二、最基础的结构：寄存器"><a href="#二、最基础的结构：寄存器" class="headerlink" title="二、最基础的结构：寄存器"></a>二、最基础的结构：寄存器</h2><p>Smali 里没有 “变量名”，所有数据都存在<strong>寄存器</strong>里，就像一个个小盒子，每个盒子有编号。</p>
<h3 id="2-1-寄存器的两种类型"><a href="#2-1-寄存器的两种类型" class="headerlink" title="2.1 寄存器的两种类型"></a>2.1 寄存器的两种类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>命名</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>局部寄存器</td>
<td>v0, v1, v2…</td>
<td>存方法里的临时数据（类似 Java 的局部变量）</td>
<td>v0 存一个数字，v1 存一个字符串</td>
</tr>
<tr>
<td>参数寄存器</td>
<td>p0, p1, p2…</td>
<td>存方法的参数（包括特殊的<code>this</code>）</td>
<td>调用<code>setName(&quot;张三&quot;)</code>时，p1 存 “张三”</td>
</tr>
</tbody></table>
<h3 id="2-2-关键区别：静态方法-vs-非静态方法的参数寄存器"><a href="#2-2-关键区别：静态方法-vs-非静态方法的参数寄存器" class="headerlink" title="2.2 关键区别：静态方法 vs 非静态方法的参数寄存器"></a>2.2 关键区别：静态方法 vs 非静态方法的参数寄存器</h3><ul>
<li><strong>非静态方法</strong>（普通方法）：p0 固定是<code>this</code>（当前对象），p1 才是第一个参数<br>  例：Java 的<code>void eat(String food)</code>，Smali 中 p0 是 “这个对象”，p1 是 food 参数</li>
<li><strong>静态方法</strong>（带 static 的方法）：没有<code>this</code>，p0 直接是第一个参数<br>  例：Java 的<code>static int add(int a, int b)</code>，Smali 中 p0 是 a，p1 是 b</li>
</ul>
<h2 id="三、类的声明（对应-Java-的-class）"><a href="#三、类的声明（对应-Java-的-class）" class="headerlink" title="三、类的声明（对应 Java 的 class）"></a>三、类的声明（对应 Java 的 class）</h2><h3 id="3-1-基本格式（必须掌握）"><a href="#3-1-基本格式（必须掌握）" class="headerlink" title="3.1 基本格式（必须掌握）"></a>3.1 基本格式（必须掌握）</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span> 权限修饰符 类的全路径;  // 声明类（类似Java的<span class="string">&quot;public class 包名.类名&quot;</span>）</span><br><span class="line"><span class="keyword">.super</span> 父类全路径;  // 声明父类（类似Java的<span class="string">&quot;extends 父类&quot;</span>）</span><br><span class="line"><span class="keyword">.implements</span> 接口全路径;  // 声明实现的接口（类似Java的<span class="string">&quot;implements 接口&quot;</span>）</span><br><span class="line"><span class="keyword">.source</span> <span class="string">&quot;Java文件名.java&quot;</span>  // 对应Java源码文件（可选，混淆后可能没有）</span><br></pre></td></tr></table></figure>

<h3 id="3-2-实例（对照-Java-看更清楚）"><a href="#3-2-实例（对照-Java-看更清楚）" class="headerlink" title="3.2 实例（对照 Java 看更清楚）"></a>3.2 实例（对照 Java 看更清楚）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="comment">// 类内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/example/Student;</span>  // <span class="class">L开头+包名/类名+;</span>结尾（固定格式）</span><br><span class="line"><span class="keyword">.super</span> <span class="class">Lcom/example/Person;</span>  // 父类是Person</span><br><span class="line"><span class="keyword">.implements</span> <span class="class">Lcom/example/Study;</span>  // 实现Study接口</span><br><span class="line"><span class="keyword">.source</span> <span class="string">&quot;Student.java&quot;</span>  // 对应Java文件</span><br></pre></td></tr></table></figure>

<h3 id="3-3-特别注意"><a href="#3-3-特别注意" class="headerlink" title="3.3 特别注意"></a>3.3 特别注意</h3><ul>
<li>所有类 &#x2F; 接口的全路径必须以<code>L</code>开头，以<code>;</code>结尾（比如<code>Ljava/lang/String;</code>对应<code>java.lang.String</code>）</li>
<li>如果类在某个类内部（内部类），用<code>$</code>连接，比如<code>Student$Score</code>对应 Smali 的<code>Lcom/example/Student$Score;</code></li>
</ul>
<h2 id="四、字段（对应-Java-的成员变量）"><a href="#四、字段（对应-Java-的成员变量）" class="headerlink" title="四、字段（对应 Java 的成员变量）"></a>四、字段（对应 Java 的成员变量）</h2><p>字段就是类里的变量（包括静态变量和非静态变量），声明格式很固定。</p>
<h3 id="4-1-基本格式"><a href="#4-1-基本格式" class="headerlink" title="4.1 基本格式"></a>4.1 基本格式</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.field</span> 权限修饰符 静态修饰符 变量名:变量类型;</span><br></pre></td></tr></table></figure>

<ul>
<li>权限修饰符：<code>public</code>&#x2F;<code>private</code>&#x2F;<code>protected</code>（和 Java 一样）</li>
<li>静态修饰符：<code>static</code>（静态变量加，非静态不加）</li>
<li>变量类型：Smali 的特殊写法（后面会详细讲）</li>
</ul>
<h3 id="4-2-实例（对照-Java）"><a href="#4-2-实例（对照-Java）" class="headerlink" title="4.2 实例（对照 Java）"></a>4.2 实例（对照 Java）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 非静态字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;  <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> isMale;  <span class="comment">// 非静态字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/example/Student;</span></span><br><span class="line"><span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非静态字段：private String name;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span> name:<span class="class">Ljava/lang/String;</span>  // 类型是String（<span class="class">Ljava/lang/String;</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态字段：public static int age;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> public</span><span class="keyword"> static</span> age:I  // 类型是int（I）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非静态字段：protected boolean isMale;</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> protected</span> isMale:Z  // 类型是boolean（Z）</span><br></pre></td></tr></table></figure>

<h2 id="五、数据类型（Smali-的-“密码本”）"><a href="#五、数据类型（Smali-的-“密码本”）" class="headerlink" title="五、数据类型（Smali 的 “密码本”）"></a>五、数据类型（Smali 的 “密码本”）</h2><p>Smali 的类型写法和 Java 完全不同，必须死记！这是看懂 Smali 的基础。</p>
<h3 id="5-1-基本类型（简单类型）"><a href="#5-1-基本类型（简单类型）" class="headerlink" title="5.1 基本类型（简单类型）"></a>5.1 基本类型（简单类型）</h3><table>
<thead>
<tr>
<th>Smali 类型</th>
<th>对应 Java 类型</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>int（整数）</td>
<td>123、-45</td>
</tr>
<tr>
<td>Z</td>
<td>boolean（布尔）</td>
<td>true（1）、false（0）</td>
</tr>
<tr>
<td>B</td>
<td>byte（字节）</td>
<td>0~255 的数</td>
</tr>
<tr>
<td>C</td>
<td>char（字符）</td>
<td>‘A’、’ 中’</td>
</tr>
<tr>
<td>S</td>
<td>short（短整数）</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>J</td>
<td>long（长整数）</td>
<td>超过 int 范围的数（占 2 个寄存器）</td>
</tr>
<tr>
<td>F</td>
<td>float（单精度浮点数）</td>
<td>3.14f</td>
</tr>
<tr>
<td>D</td>
<td>double（双精度浮点数）</td>
<td>3.1415926（占 2 个寄存器）</td>
</tr>
</tbody></table>
<h3 id="5-2-引用类型（对象-数组）"><a href="#5-2-引用类型（对象-数组）" class="headerlink" title="5.2 引用类型（对象 &#x2F; 数组）"></a>5.2 引用类型（对象 &#x2F; 数组）</h3><table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>对应 Java</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>类类型</td>
<td>L 包名 &#x2F; 类名；</td>
<td>类对象</td>
<td><code>Ljava/lang/String;</code> → <code>String</code></td>
</tr>
<tr>
<td>数组类型</td>
<td>[元素类型</td>
<td>数组</td>
<td><code>[I</code> → <code>int[]</code>；<code>[Ljava/lang/String;</code> → <code>String[]</code></td>
</tr>
<tr>
<td>多维数组</td>
<td>[[元素类型（几维就加几个 [）</td>
<td>多维数组</td>
<td><code>[[I</code> → <code>int[][]</code>；<code>[[[B</code> → <code>byte[][][]</code></td>
</tr>
</tbody></table>
<h3 id="5-3-方法签名（方法的-“身份证”）"><a href="#5-3-方法签名（方法的-“身份证”）" class="headerlink" title="5.3 方法签名（方法的 “身份证”）"></a>5.3 方法签名（方法的 “身份证”）</h3><p>Smali 用 “方法签名” 表示方法，格式：<code>方法名(参数类型列表)返回值类型</code><br>参数之间没有分隔符，直接连写！</p>
<p><strong>例子</strong>：</p>
<table>
<thead>
<tr>
<th>Smali 签名</th>
<th>对应 Java 方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>getName()Ljava/lang/String;</code></td>
<td><code>String getName()</code></td>
</tr>
<tr>
<td><code>setAge(I)V</code></td>
<td><code>void setAge(int age)</code></td>
</tr>
<tr>
<td><code>add(IF)F</code></td>
<td><code>float add(int a, float b)</code></td>
</tr>
<tr>
<td><code>show(String[] arr, int num)Z</code> → 签名是<code>show([Ljava/lang/String;I)Z</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="六、方法的声明与实现"><a href="#六、方法的声明与实现" class="headerlink" title="六、方法的声明与实现"></a>六、方法的声明与实现</h2><p>方法是 Smali 的核心，所有逻辑都在这里写。</p>
<h3 id="6-1-方法的基本结构"><a href="#6-1-方法的基本结构" class="headerlink" title="6.1 方法的基本结构"></a>6.1 方法的基本结构</h3><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span> 权限修饰符 静态修饰符 方法签名  // 方法声明（类似Java的<span class="string">&quot;public static int add(int a)&quot;</span>）</span><br><span class="line"><span class="keyword">    .locals</span> N  // 局部寄存器的数量（v0到vN-1）</span><br><span class="line"><span class="keyword">    .prologue</span>  // 代码开始的标记（固定加）</span><br><span class="line"><span class="keyword">    .line</span> 10  // 对应Java源码的行号（可选，删除不影响运行）</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法体（具体逻辑）</span></span><br><span class="line">    </span><br><span class="line">    返回指令  // 比如return-void（返回空）<span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span>  // 方法结束标记</span><br></pre></td></tr></table></figure>

<h3 id="6-2-实例：简单方法（对照-Java）"><a href="#6-2-实例：简单方法（对照-Java）" class="headerlink" title="6.2 实例：简单方法（对照 Java）"></a>6.2 实例：简单方法（对照 Java）</h3><p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非静态方法：设置名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String newName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> setName(<span class="class">Ljava/lang/String;</span>)V  // 方法签名：参数是String，返回void</span><br><span class="line"><span class="keyword">    .locals</span> 0  // 不需要局部寄存器（v0都不用）</span><br><span class="line"><span class="keyword">    .prologue</span>  // 代码开始</span><br><span class="line"><span class="keyword">    .line</span> 8  // 对应Java第8行</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 核心逻辑：this.name = newName</span></span><br><span class="line">    <span class="comment"># p0是this（当前Student对象），p1是newName参数</span></span><br><span class="line">   <span class="built_in"> iput-object </span>p1, p0, <span class="class">Lcom/example/Student;</span>-&gt;name:<span class="class">Ljava/lang/String;</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void </span> // 返回空<span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-特殊方法：构造方法（）"><a href="#6-3-特殊方法：构造方法（）" class="headerlink" title="6.3 特殊方法：构造方法（）"></a>6.3 特殊方法：构造方法（<init>）</h3><p>构造方法是创建对象时调用的方法，Smali 中固定叫<code>&lt;init&gt;</code>，必须调用父类的构造方法！</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;  <span class="comment">// 给name赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> &lt;init&gt;(<span class="class">Ljava/lang/String;</span>)V  // 构造方法固定叫&lt;init&gt;</span><br><span class="line"><span class="keyword">    .locals</span> 0</span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 5</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一步：必须调用父类的构造方法（Object的构造方法）</span></span><br><span class="line">   <span class="built_in"> invoke-direct </span>&#123;p0&#125;, <span class="class">Ljava/lang/Object;</span>-&gt;&lt;init&gt;()V  // p0是this</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二步：给当前对象的name赋值（this.name = 参数name）</span></span><br><span class="line">   <span class="built_in"> iput-object </span>p1, p0, <span class="class">Lcom/example/Student;</span>-&gt;name:<span class="class">Ljava/lang/String;</span></span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-特殊方法：静态代码块（）"><a href="#6-4-特殊方法：静态代码块（）" class="headerlink" title="6.4 特殊方法：静态代码块（）"></a>6.4 特殊方法：静态代码块（<clinit>）</h3><p>Java 的静态代码块（<code>static &#123; ... &#125;</code>）在 Smali 中对应<code>&lt;clinit&gt;</code>方法，用于初始化静态字段。</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        school = <span class="string">&quot;阳光小学&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.field</span><span class="keyword"> public</span><span class="keyword"> static</span> school:<span class="class">Ljava/lang/String;</span>  // 静态字段school</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态代码块对应&lt;clinit&gt;方法（静态构造方法）</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> static</span><span class="keyword"> constructor</span> &lt;clinit&gt;()V  // 固定写法</span><br><span class="line"><span class="keyword">    .locals</span> 1  // 需要1个局部寄存器v0</span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 4</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 给静态字段school赋值</span></span><br><span class="line">   <span class="built_in"> const-string </span>v0, <span class="string">&quot;阳光小学&quot;</span>  // v0存字符串<span class="string">&quot;阳光小学&quot;</span></span><br><span class="line">   <span class="built_in"> sput-object </span>v0, <span class="class">Lcom/example/Student;</span>-&gt;school:<span class="class">Ljava/lang/String;</span>  // 存入静态字段</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="七、常用指令（Smali-的-“动词”）"><a href="#七、常用指令（Smali-的-“动词”）" class="headerlink" title="七、常用指令（Smali 的 “动词”）"></a>七、常用指令（Smali 的 “动词”）</h2><p>指令是 Smali 的动作，比如 “赋值”、”调用方法”、”跳转” 等，必须掌握常用的。</p>
<h3 id="7-1-赋值指令（给寄存器存数据）"><a href="#7-1-赋值指令（给寄存器存数据）" class="headerlink" title="7.1 赋值指令（给寄存器存数据）"></a>7.1 赋值指令（给寄存器存数据）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>const&#x2F;4 vA, 0xN</td>
<td>存一个小整数（-8 到 7）到 vA</td>
<td><code>const/4 v0, 0x1</code> → v0&#x3D;1</td>
</tr>
<tr>
<td>const&#x2F;16 vA, 0xN</td>
<td>存中等整数（-32768 到 32767）到 vA</td>
<td><code>const/16 v0, 0x100</code> → v0&#x3D;256</td>
</tr>
<tr>
<td>const-string vA, “内容”</td>
<td>存字符串到 vA</td>
<td><code>const-string v0, &quot;你好&quot;</code> → v0&#x3D;”你好”</td>
</tr>
<tr>
<td>const-class vA, L 类名；</td>
<td>存类的 Class 对象到 vA</td>
<td><code>const-class v0, Ljava/lang/String;</code> → v0&#x3D;String.class</td>
</tr>
</tbody></table>
<h3 id="7-2-字段操作指令（存-取字段的值）"><a href="#7-2-字段操作指令（存-取字段的值）" class="headerlink" title="7.2 字段操作指令（存 &#x2F; 取字段的值）"></a>7.2 字段操作指令（存 &#x2F; 取字段的值）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>iget-object vA, vB, 字段</td>
<td>从 vB 对象中取 “对象类型字段” 到 vA</td>
<td><code>iget-object v0, p0, LStudent;-&gt;name:LString;</code> → v0 &#x3D; this.name</td>
</tr>
<tr>
<td>iput-object vA, vB, 字段</td>
<td>把 vA 的对象存入 vB 对象的 “对象类型字段”</td>
<td><code>iput-object v0, p0, LStudent;-&gt;name:LString;</code> → this.name &#x3D; v0</td>
</tr>
<tr>
<td>sget-object vA, 静态字段</td>
<td>取 “静态对象字段” 到 vA</td>
<td><code>sget-object v0, LStudent;-&gt;school:LString;</code> → v0 &#x3D; Student.school</td>
</tr>
<tr>
<td>sput-object vA, 静态字段</td>
<td>把 vA 的对象存入 “静态对象字段”</td>
<td><code>sput-object v0, LStudent;-&gt;school:LString;</code> → Student.school &#x3D; v0</td>
</tr>
<tr>
<td>iget vA, vB, 字段</td>
<td>取 “基本类型字段”（int 等）到 vA</td>
<td><code>iget v0, p0, LStudent;-&gt;age:I</code> → v0 &#x3D; this.age</td>
</tr>
<tr>
<td>iput vA, vB, 字段</td>
<td>存 “基本类型字段”（int 等）</td>
<td><code>iput v0, p0, LStudent;-&gt;age:I</code> → this.age &#x3D; v0</td>
</tr>
</tbody></table>
<h3 id="7-3-方法调用指令（执行另一个方法）"><a href="#7-3-方法调用指令（执行另一个方法）" class="headerlink" title="7.3 方法调用指令（执行另一个方法）"></a>7.3 方法调用指令（执行另一个方法）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>invoke-virtual {参数}, 方法签名</td>
<td>调用普通方法（非私有、非静态）</td>
<td><code>invoke-virtual &#123;p0&#125;, LStudent;-&gt;getName()LString;</code> → 调用 this.getName ()</td>
</tr>
<tr>
<td>invoke-static {参数}, 方法签名</td>
<td>调用静态方法</td>
<td><code>invoke-static &#123;v0&#125;, LInteger;-&gt;parseInt(LString;)I</code> → 调用 Integer.parseInt (v0)</td>
</tr>
<tr>
<td>invoke-direct {参数}, 方法签名</td>
<td>调用私有方法或构造方法</td>
<td><code>invoke-direct &#123;p0&#125;, LObject;-&gt;&lt;init&gt;()V</code> → 调用父类构造方法</td>
</tr>
</tbody></table>
<p><strong>调用后取返回值</strong>：</p>
<ul>
<li>若方法返回对象（如 String）：<code>move-result-object vA</code> → 把结果存到 vA</li>
<li>若方法返回基本类型（如 int）：<code>move-result vA</code> → 把结果存到 vA</li>
</ul>
<p><strong>例子</strong>：调用<code>Integer.parseInt(&quot;123&quot;)</code>并获取结果</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">const-string v0, <span class="string">&quot;123&quot;</span>  // v0 = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="comment"># 调用静态方法：Integer.parseInt(&quot;123&quot;)</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">invoke-static </span>&#123;v0&#125;, <span class="class">Ljava/lang/Integer;</span>-&gt;parseInt(<span class="class">Ljava/lang/String;</span>)I<span class="built_in"></span></span><br><span class="line"><span class="built_in">move-result </span>v1  // 把返回的int值存到v1（v1=123）</span><br></pre></td></tr></table></figure>

<h3 id="7-4-条件跳转指令（做判断）"><a href="#7-4-条件跳转指令（做判断）" class="headerlink" title="7.4 条件跳转指令（做判断）"></a>7.4 条件跳转指令（做判断）</h3><p>条件跳转就像 Java 的<code>if</code>语句，满足条件就跳到指定标签（如<code>:cond_0</code>）。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用（满足条件则跳转）</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>if-eq vA, vB, :label</td>
<td>vA &#x3D;&#x3D; vB</td>
<td><code>if-eq v0, v1, :cond_0</code> → 若 v0 等于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-ne vA, vB, :label</td>
<td>vA !&#x3D; vB</td>
<td><code>if-ne v0, v1, :cond_0</code> → 若 v0 不等于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-lt vA, vB, :label</td>
<td>vA &lt; vB</td>
<td><code>if-lt v0, v1, :cond_0</code> → 若 v0 小于 v1，跳去:cond_0</td>
</tr>
<tr>
<td>if-gt vA, vB, :label</td>
<td>vA &gt; vB</td>
<td><code>if-gt v0, v1, :cond_0</code> → 若 v0 大于 v1，跳去:cond_0</td>
</tr>
</tbody></table>
<p><strong>例子</strong>：判断年龄是否大于 18</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设v0存年龄（比如20）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const/4 </span>v1, 0x12  <span class="comment"># v1 = 18（0x12是18的十六进制）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">if-gt </span>v0, v1,<span class="keyword"> :is_adult</span>  <span class="comment"># 若v0&gt;v1（20&gt;18），跳去:is_adult</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未成年人逻辑</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;未成年&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">goto </span>:end  <span class="comment"># 跳过成年人逻辑</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">:is_adult</span>  <span class="comment"># 成年人标签</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;成年人&quot;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">:end</span>  <span class="comment"># 结束标签</span></span><br><span class="line"><span class="comment"># 最终v2的值是&quot;成年人&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-5-数组操作指令（数组的增删改查）"><a href="#7-5-数组操作指令（数组的增删改查）" class="headerlink" title="7.5 数组操作指令（数组的增删改查）"></a>7.5 数组操作指令（数组的增删改查）</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>new-array vA, vB, [类型</td>
<td>创建长度为 vB 的数组，存到 vA</td>
<td><code>new-array v0, v1, [I</code> → 创建 int 数组，长度 v1，存到 v0</td>
</tr>
<tr>
<td>aget-object vA, vB, vC</td>
<td>取数组 vB 中索引 vC 的对象到 vA</td>
<td><code>aget-object v0, v1, v2</code> → v0 &#x3D; v1 [v2]（v1 是 String []）</td>
</tr>
<tr>
<td>aput-object vA, vB, vC</td>
<td>把 vA 的对象存入数组 vB 的索引 vC</td>
<td><code>aput-object v0, v1, v2</code> → v1[v2] &#x3D; v0</td>
</tr>
<tr>
<td>array-length vA, vB</td>
<td>取数组 vB 的长度到 vA</td>
<td><code>array-length v0, v1</code> → v0 &#x3D; v1.length</td>
</tr>
</tbody></table>
<p><strong>例子</strong>：创建 String 数组并赋值</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">const/4 v0, 0x2  <span class="comment"># v0=2（数组长度）</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">new-array </span>v1, v0, [<span class="class">Ljava/lang/String;</span>  <span class="comment"># 创建长度2的String数组，存到v1</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;苹果&quot;</span>  <span class="comment"># v2=&quot;苹果&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">aput-object </span>v2, v1, 0x0  <span class="comment"># 数组[0] = &quot;苹果&quot;</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">const-string </span>v2, <span class="string">&quot;香蕉&quot;</span>  <span class="comment"># v2=&quot;香蕉&quot;</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">aput-object </span>v2, v1, 0x1  <span class="comment"># 数组[1] = &quot;香蕉&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时v1是[&quot;苹果&quot;, &quot;香蕉&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="八、异常处理（try-catch）"><a href="#八、异常处理（try-catch）" class="headerlink" title="八、异常处理（try-catch）"></a>八、异常处理（try-catch）</h2><p>和 Java 的<code>try-catch</code>一样，Smali 用<code>.try</code>和<code>.catch</code>处理异常。</p>
<p><strong>Java 代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 可能出错的代码</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对应的 Smali 代码</strong>：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span> readFile()V</span><br><span class="line"><span class="keyword">    .locals</span> 2  <span class="comment"># 局部寄存器v0、v1</span></span><br><span class="line"><span class="keyword">    .prologue</span></span><br><span class="line"><span class="keyword">    .line</span> 6</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># try块开始</span></span><br><span class="line"><span class="keyword">    .try</span>_start_0</span><br><span class="line">        <span class="comment"># 创建FileReader对象（可能抛异常）</span></span><br><span class="line">       <span class="built_in"> const-string </span>v0, <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">       <span class="built_in"> new-instance </span>v1, <span class="class">Ljava/io/FileReader;</span></span><br><span class="line">       <span class="built_in"> invoke-direct </span>&#123;v1, v0&#125;, <span class="class">Ljava/io/FileReader;</span>-&gt;&lt;init&gt;(<span class="class">Ljava/lang/String;</span>)V</span><br><span class="line"><span class="keyword">    .try</span>_end_0</span><br><span class="line">    <span class="comment"># 捕获FileNotFoundException，跳去:catch_0</span></span><br><span class="line"><span class="keyword">    .catch</span> <span class="class">Ljava/io/FileNotFoundException;</span> &#123;:try_start_0 ..<span class="keyword"> :try_end_0</span>&#125;<span class="keyword"> :catch_0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 没有异常就直接返回</span></span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span>    </span><br><span class="line">    <span class="comment"># catch块：处理异常</span></span><br><span class="line">   <span class="keyword"> :catch_0</span></span><br><span class="line">   <span class="built_in"> move-exception </span>v0  <span class="comment"># v0 = 捕获到的异常对象</span></span><br><span class="line">    <span class="comment"># 调用printStackTrace()</span></span><br><span class="line">   <span class="built_in"> invoke-virtual </span>&#123;v0&#125;, <span class="class">Ljava/lang/Throwable;</span>-&gt;printStackTrace()V</span><br><span class="line">   <span class="built_in"> return-void</span></span><br><span class="line"><span class="built_in"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="九、工具使用（动手实操必备）"><a href="#九、工具使用（动手实操必备）" class="headerlink" title="九、工具使用（动手实操必备）"></a>九、工具使用（动手实操必备）</h2><p>学完语法，必须会用工具才能真正修改 Smali：</p>
<ol>
<li><p><strong>APKTool</strong>（核心工具）：</p>
<ul>
<li>功能：把 APK 反编译成 Smali 代码和资源文件</li>
<li>命令：<ul>
<li>反编译：<code>apktool d 你的应用.apk</code>（会生成一个文件夹，里面的<code>smali</code>目录就是 Smali 代码）</li>
<li>重新打包：修改完 Smali 后，<code>apktool b 反编译的文件夹</code>（生成的 APK 在<code>dist</code>目录）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>辅助工具</strong>：</p>
<ul>
<li><p>AndroidKiller：可视化界面，集成反编译、编辑、打包（新手推荐）</p>
</li>
<li><p>JEB：把 Smali 转成类似 Java 的代码（方便分析逻辑，但修改仍需改 Smali）</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://source.android.google.cn/docs/core/runtime/dalvik-bytecode?hl=zh-cn">Dalvik 字节码格式  | Android Open Source Project</a>]</p>
<p>[smali介绍](<a href="https://github.com/JesusFreke/smali/wiki">Home · JesusFreke&#x2F;smali Wiki</a>)</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
  <entry>
    <title>破解·常用工具</title>
    <url>/2025/08/10/%E7%A0%B4%E8%A7%A3%C2%B7%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h2><p>[学习链接]([渗透之OllyDbg逆向分析动态调试工具使用 - 大柿子 - 博客园](<a href="https://www.cnblogs.com/xsj210/p/15770601.html#:~:text=%E8%8B%A5%E6%98%AF%E4%BD%A0%E6%83%B3%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AAEXE%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8F%B3%E9%94%AE%E7%9B%B4%E6%8E%A5%E5%8F%AF%E4%BB%A5%E7%94%A8OllyDbg%E6%89%93%E5%BC%80%EF%BC%8C%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%91%A2%EF%BC%9F">https://www.cnblogs.com/xsj210/p/15770601.html#:~:text=若是你想选中一个EXE文件，右键直接可以用OllyDbg打开，怎么设置呢？</a> 点击 “选项” -&gt;,“添加到浏览器”，添加OllyDbg到系统资源管理器菜单。 若是咱们每次运行OD都提示管理员权限运行，则能够进行快捷键简单的设置。 设置方式以下：兼容性中选择“以管理员身份运行此程序”。 下面简单讲解经常使用的快捷键调试方式。 设置断点，只要在光标定位的位置按下F2键便可，再按一次F2键会删除断点。))</p>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>动态调试工具</p>
<p>Windows 平台专属工具，主要用于分析 <strong>x86 架构的 PE 格式程序</strong>（如 .exe、.dll）。</p>
<p>包括反汇编窗口、寄存器窗口、信息窗口、数据窗口、堆栈窗口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200012.png"></p>
<p>当界面乱象时，可以点击顶部快捷键C，主窗口最大化便可优化布局。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200837.png"></p>
<p>各个窗口的含义：</p>
<ul>
<li><p>反汇编窗口： 显示被调试程序的反汇编代码，包括地址、HEX数据、反汇编、注释</p>
</li>
<li><p>寄存器窗口： 显示当前所选线程的CPU寄存器内容，点击标签可切换显示寄存器的方式</p>
</li>
<li><p>信息窗口： 显示反汇编窗口中选中的第一个命令的参数及跳转目标地址、字符等</p>
</li>
<li><p>数据窗口： 显示内存或文件的内容，右键菜单可切换显示方式</p>
</li>
<li><p>堆栈窗口： 显示当前线程的堆栈，记录传递的参数或局部变量</p>
</li>
<li><p>子窗口的快捷方式</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202508190200626.png"></p>
</li>
</ul>
<p>点击 “选项” -&gt; “界面”，设置UDD路径和插件路径</p>
<ul>
<li>UDD路径用于保存咱们调试的信息。</li>
<li>插件路径包含了各类插件，而且能够直接使用。</li>
</ul>
<p>管理员权限运行</p>
<ul>
<li>点击OllyDbg.exe右键点击属性</li>
<li>兼容性中选择“以管理员身份运行此程序”</li>
</ul>
<h3 id="经常快捷键"><a href="#经常快捷键" class="headerlink" title="经常快捷键"></a>经常快捷键</h3><p>F2：设置断点<br>设置断点，只要在光标定位的位置按下F2键便可，再按一次F2键会删除断点。</p>
<p>CTRL+F2：从新开始<br>当程序想从新调试时，按下CTRL+F2便可。</p>
<p>F4：运行到选定位置<br>运行到选定位置，做用就是直接运行到光标所在位置处暂停。当咱们调试过程当中遇到循环，能够调至光标跳过循环。</p>
<p>F7：单步步入<br>单步步入，功能通单步步过（F8）相似，区别是遇到CALL等子程序时会进入其中，进入后首先停留在子程序的第一条指令上。以下图进入CALL子程序。CALL表示进入函数，RETN表示返回。</p>
<p>F8：单步步过<br>单步步过，每按一次这个按键，将执行反汇编窗口中的一条指令，遇到CALL等子程序不进入其代码。</p>
<p>F9：运行<br>按下F9键运行程序，若是没有设置相应的断点，被调试的程序直接开始运行。</p>
<p>CTRL+F9：执行到返回<br>执行到返回，按下此键会执行到一个返回指令时暂停，经常使用于从系统领空返回到咱们调试的程序领空。在调试程序时，按下CTRL+F9会一直运行程序，直到一个RETURN返回。再在RETN 10位置按下F8，则会返回以下图所示的位置，执行完CALL函数进入下一句。</p>
<p>ALT+F9：执行到用户代码<br>执行到用户代码，从系统领空快速返回咱们调试的程序领空。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的APK结构和Dalvik字节码</title>
    <url>/2025/08/10/%E7%AE%80%E5%8D%95%E7%9A%84APK%E7%BB%93%E6%9E%84%E5%92%8CDalvik%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h2 id="简单的APK结构"><a href="#简单的APK结构" class="headerlink" title="简单的APK结构"></a>简单的APK结构</h2><p>应用打包的核心文件——<strong>APK（Android Package）</strong></p>
<p>APK 文件是Android操作系统中的应用程序包，它包含了应用的所有资源、代码和必要的配置文件。可以把APK看作一个容器，其中集成了Android应用的所有组成部分。</p>
<p>实际上，APK 文件是以 <strong>ZIP</strong> 格式进行压缩打包的，只要在电脑上将apk后缀改为zip即可解压。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目根目录/                     # 整个项目的根目录</span><br><span class="line">├── .gradle/                    # Gradle构建工具的缓存文件，自动生成，无需手动修改</span><br><span class="line">├── .idea/                      # Android Studio的配置文件目录，包含项目设置等，自动生成</span><br><span class="line">├── app/                        # 应用的核心模块，主要开发工作在此目录进行</span><br><span class="line">│   ├── src/                    # 源代码和资源的主目录</span><br><span class="line">│   │   ├── main/               # 主代码和资源目录（正式环境）</span><br><span class="line">│   │   │   ├── java/（或kotlin/）  # 源代码目录，按包名组织</span><br><span class="line">│   │   │   │   └── com/example/myapp/  # 应用的包名目录（示例）</span><br><span class="line">│   │   │   │       ├── MainActivity.java（或.kt）  # 应用入口Activity，定义界面逻辑</span><br><span class="line">│   │   │   │       └── utils/  # 工具类目录（如网络、数据处理工具）</span><br><span class="line">│   │   │   ├── res/            # 资源目录，按类型分类</span><br><span class="line">│   │   │   │   ├── drawable/   # 可绘制资源（图片、形状、选择器等）</span><br><span class="line">│   │   │   │   │   ├── ic_logo.png  # 应用图标图片资源</span><br><span class="line">│   │   │   │   │   └── shape_round.xml  # 圆角形状资源</span><br><span class="line">│   │   │   │   ├── layout/     # 布局文件目录，定义UI结构</span><br><span class="line">│   │   │   │   │   └── activity_main.xml  # MainActivity对应的布局文件</span><br><span class="line">│   │   │   │   ├── mipmap/     # 应用图标目录（适配不同屏幕密度）</span><br><span class="line">│   │   │   │   │   └── ic_launcher.png  # 应用桌面图标</span><br><span class="line">│   │   │   │   ├── values/     # 配置资源目录</span><br><span class="line">│   │   │   │   │   ├── strings.xml  # 字符串资源（集中管理文本，避免硬编码）</span><br><span class="line">│   │   │   │   │   ├── colors.xml   # 颜色资源（定义应用配色）</span><br><span class="line">│   │   │   │   │   └── dimens.xml   # 尺寸资源（统一管理控件大小）</span><br><span class="line">│   │   │   │   ├── raw/        # 原始文件目录（音频、视频等）</span><br><span class="line">│   │   │   │   └── xml/        # 自定义XML资源（如菜单、网络配置）</span><br><span class="line">│   │   │   └── AndroidManifest.xml  # 应用清单文件，声明组件、权限、配置等</span><br><span class="line">│   │   ├── androidTest/        # 仪器化测试目录（需在设备/模拟器上运行）</span><br><span class="line">│   │   │   └── java/（或kotlin/）  # 测试代码，如UI交互测试</span><br><span class="line">│   │   └── test/               # 单元测试目录（在本地JVM运行）</span><br><span class="line">│   │       └── java/（或kotlin/）  # 测试代码，如逻辑单元测试</span><br><span class="line">│   ├── build.gradle            # 模块级构建脚本，配置依赖、编译选项等</span><br><span class="line">│   └── proguard-rules.pro      # 代码混淆规则（发布时减小APK体积并保护代码）</span><br><span class="line">├── build/                      # 编译生成的中间文件和APK，自动管理</span><br><span class="line">├── gradle/                     # Gradle包装器配置，自动下载指定版本Gradle</span><br><span class="line">├── gradlew                     # Linux/Mac系统的Gradle命令行脚本</span><br><span class="line">├── gradlew.bat                 # Windows系统的Gradle命令行脚本</span><br><span class="line">├── build.gradle（Project）     # 项目级构建脚本，配置全局插件和仓库</span><br><span class="line">├── settings.gradle             # 声明项目包含的模块（默认包含:app）</span><br><span class="line">└── local.properties            # 记录本地Android SDK路径，自动生成</span><br></pre></td></tr></table></figure>

<h3 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h3><p>APK <strong>文件通常包括以下几个主要部分</strong>：</p>
<ol>
<li><strong>AndroidManifest.xml</strong></li>
<li><strong>classes.dex</strong></li>
<li><strong>resources.arsc</strong></li>
<li><strong>assets&#x2F;</strong></li>
<li><strong>lib&#x2F;</strong></li>
<li><strong>res&#x2F;</strong></li>
<li><strong>META-INF&#x2F;</strong></li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>assets目录</td>
<td>存放APK的静态资源文件，比如视频，音频，图片等（不一定有但常见）</td>
</tr>
<tr>
<td>lib目录</td>
<td>armeabi-v7a基本通用所有Android设备，arm64-v8a只是用与64为的Android设备，x86常用于Android模拟器，其目录下的.so文件时c或者c++编译的动态链接库文件（不一定有但常见）</td>
</tr>
<tr>
<td>META-INF目录</td>
<td>保存应用的签名信息，签名信息可以验证APK文件的额完整性，相当于APK的身份验证（验证文件是否又被修改）</td>
</tr>
<tr>
<td>res目录</td>
<td>res目录存放资源文件，包括图片，字符串等，APK的 脸蛋由它的layout文件设计</td>
</tr>
<tr>
<td>AndroidManifest.xml文件</td>
<td>APK的应用清单信息，他描述了应用的名字，版本，权限，引用的库文件等信息</td>
</tr>
<tr>
<td>classes.dex文件</td>
<td>classes.dex是java原码编译后生成的java字节码文件，APK运行的主要逻辑</td>
</tr>
<tr>
<td>reaources.arsc文件</td>
<td>resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源</td>
</tr>
</tbody></table>
<h4 id="1-AndroidManifest-xml-关键核心"><a href="#1-AndroidManifest-xml-关键核心" class="headerlink" title="1.AndroidManifest.xml(关键核心)"></a>1.AndroidManifest.xml(关键核心)</h4><p><strong>AndroidManifest.xml</strong> 是每个Android应用不可或缺的配置文件，它包含了应用的关键信息。可以把它看作是应用的“蓝图”或“说明书”，它向系统声明了应用的基本属性、组件以及权限等。AndroidManifest.xml中包括以下重要部分：</p>
<ul>
<li><strong>应用的包名（package）</strong>：每个Android应用都有一个唯一的包名，通过包名来区分不同的应用。</li>
<li><strong>应用的组件（Activities, Services, Broadcast Receivers, Content Providers）</strong>：声明应用包含哪些组件，以及这些组件的属性和功能。</li>
<li><strong>权限声明</strong>：列出应用所需的权限，如访问网络、读取存储、使用相机等。</li>
<li><strong>应用主题和图标</strong>：定义应用的UI样式、图标等。</li>
<li><strong>最小SDK版本和目标SDK版本</strong>：确定应用能在什么版本的Android系统上运行。</li>
</ul>
<p><strong>详细解析Manifest中的关键字段</strong></p>
<ul>
<li>&lt;manifest&gt;：包含整个应用的包信息及权限定义。<ul>
<li><code>package</code>: 定义了应用的包名，通常为反向域名格式，如<code>com.example.app</code>。</li>
<li><code>android:versionCode</code>: 定义应用的版本号。</li>
<li><code>android:versionName</code>: 定义应用的版本名称。</li>
</ul>
</li>
<li>&lt;application&gt;：包含应用的核心配置，如主题、图标等。<ul>
<li><code>android:icon</code>: 定义应用的图标。</li>
<li><code>android:label</code>: 定义应用的名称。</li>
<li><code>android:theme</code>: 应用的UI主题。</li>
</ul>
</li>
<li>&lt;activity&gt; ：声明应用的各个界面（Activity），以及这些Activity的属性和行为。<ul>
<li><code>android:name</code>: Activity的类名。</li>
<li><code>android:label</code>: Activity的标签。</li>
<li><code>android:theme</code>: Activity特有的UI主题。</li>
</ul>
</li>
<li>&lt;uses-permission&gt;：声明应用所需要的权限，如访问网络、发送短信等。</li>
<li>&lt;intent-filter&gt;：定义组件的功能和响应的事件，如Activity的启动方式或Broadcast Receiver接收的广播类型。</li>
</ul>
<h4 id="2-classes-dex"><a href="#2-classes-dex" class="headerlink" title="2. classes.dex"></a>2. classes.dex</h4><p><strong>classes.dex</strong> 文件包含了应用程序的可执行代码。它是应用的Dalvik字节码文件，也是Android应用在运行时通过 <strong>Dalvik虚拟机</strong> 或 <strong>ART（Android Runtime）</strong> 解释执行的核心文件。每个Android应用中，所有的Java源代码都经过编译后形成一个或多个DEX（Dalvik Executable）文件，这些文件包含了应用的业务逻辑和代码实现。<br>在Android 5.0（Lollipop）之后，Google引入了 <strong>ART（Android Runtime）</strong> 代替了传统的Dalvik虚拟机，ART的执行方式比Dalvik更高效，支持Ahead-of-Time（AOT）编译和即时编译（JIT）策略。<br>这部分比较难可以拓展阅读一下,相关文档:</p>
<ul>
<li><a href="https://bbs.kanxue.com/elink@9e4K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2">JAVA虚拟机、Dalvik虚拟机和ART虚拟机简要对比_java dalvik-CSDN博客</a></li>
<li><a href="https://bbs.kanxue.com/elink@4a8K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1L8r3!0Y4i4K6u0W2j5%4y4V1L8W2">安卓逆向学习—-smali,dex,java等文件之间转换关系_dex与smail-CSDN博客</a></li>
</ul>
<h4 id="3-resources-arsc"><a href="#3-resources-arsc" class="headerlink" title="3. resources.arsc"></a>3. resources.arsc</h4><p><strong>resources.arsc</strong> 文件包含了应用程序的所有编译后的资源映射信息。这个文件并不存储实际的资源内容（如图片或字符串），而是存储资源与资源ID的映射关系。例如，它会保存应用中的字符串、颜色、尺寸、样式等信息以及这些资源的ID。通过这个文件，Android系统能够在应用运行时快速访问和加载所需的资源。</p>
<h4 id="4-assets"><a href="#4-assets" class="headerlink" title="4. assets&#x2F;"></a>4. assets&#x2F;</h4><p><strong>assets&#x2F;</strong> 目录包含了应用程序的原始资源文件，这些资源不经过编译，直接以原始形式存储。通常，开发者可以在该目录中存放字体文件、音频文件、HTML文件等，应用在运行时通过API来读取这些资源。例如，游戏可能会将所有的地图文件或纹理图像存放在此目录中。通过<code>AssetManager</code> API，应用可以访问这些文件。</p>
<h4 id="5-lib"><a href="#5-lib" class="headerlink" title="5. lib&#x2F;"></a>5. lib&#x2F;</h4><p><strong>lib&#x2F;</strong> 目录包含了本地库文件，通常是通过 <strong>JNI（Java Native Interface）</strong> 与C&#x2F;C++编写的本地代码。这些库文件可以针对不同的硬件架构（如arm、x86等）进行编译，因此<code>lib/</code>目录下通常会为每个架构创建相应的子目录。这个目录中存放的本地库可以通过Java代码调用JNI接口实现与系统底层的交互。</p>
<p>不同架构的手机拥有不同的操汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─arm64-v8a</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">├─armeabi-v7a</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">├─x86</span><br><span class="line">│      libcyberpeace.so</span><br><span class="line">│</span><br><span class="line">└─x86_64</span><br><span class="line">        libcyberpeace.so</span><br></pre></td></tr></table></figure>

<h4 id="6-res"><a href="#6-res" class="headerlink" title="6. res&#x2F;"></a>6. res&#x2F;</h4><p><strong>res&#x2F;</strong> 目录包含了Android应用所需的所有资源文件。与 <strong>assets&#x2F;</strong> 目录不同，<strong>res&#x2F;</strong> 目录中的资源文件是<strong>经过编译</strong>的，按照不同类型的资源进行组织，例如：</p>
<ul>
<li><p>**drawable&#x2F;**：存放图像资源（如PNG、JPEG等格式的图片）。</p>
</li>
<li><p>**layout&#x2F;**：存放XML格式的布局文件，定义界面的结构。</p>
</li>
<li><p>values&#x2F;</p>
<p>  ：存放各种配置文件，定义应用的常量、颜色、字符串等资源。例如：</p>
<ul>
<li><code>strings.xml</code>：存储应用的文本字符串。</li>
<li><code>colors.xml</code>：存储应用使用的颜色资源。</li>
<li><code>styles.xml</code>：存储样式资源。</li>
</ul>
</li>
</ul>
<p>在<code>values/</code>目录下，除了<code>strings.xml</code>、<code>colors.xml</code>等常见资源文件，还会有像<code>dimens.xml</code>（尺寸定义文件）和<code>attrs.xml</code>（自定义属性）等资源文件。</p>
<p>可以在文件夹目录中找到也可以在jadx里面查看。</p>
<h4 id="7-META-INF"><a href="#7-META-INF" class="headerlink" title="7.META-INF&#x2F;"></a>7.META-INF&#x2F;</h4><p><strong>META-INF&#x2F;</strong> 目录与Java的JAR文件类似，用于存放APK文件的元数据，如签名文件、校验信息等。此目录主要包括以下文件：</p>
<ul>
<li><strong>MANIFEST.MF</strong>：存放APK的清单文件，包含关于APK文件本身的信息。</li>
<li><strong>CERT.RSA</strong>：包含APK文件的数字签名。</li>
<li><strong>CERT.SF</strong>：存放APK文件的签名摘要。<br>  这些文件确保了APK的完整性和安全性，保证APK文件没有被篡改，且来自合法的开发者。</li>
</ul>
<h2 id="Dalvik字节码"><a href="#Dalvik字节码" class="headerlink" title="Dalvik字节码"></a>Dalvik字节码</h2><p>Dalvik 字节码是安卓系统早期（Android 4.4 及之前）为<strong>Dalvik 虚拟机（DVM）</strong> 设计的中间代码，是安卓应用程序的核心执行载体。它由 Java 源代码编译生成的<code>.class</code>文件，通过安卓 SDK 中的<code>dx</code>工具进一步转换而来，最终存储在 APK 文件的<code>classes.dex</code>（或多 DEX 文件）中。</p>
<h4 id="与-Java-字节码的核心区别："><a href="#与-Java-字节码的核心区别：" class="headerlink" title="与 Java 字节码的核心区别："></a>与 Java 字节码的核心区别：</h4><ul>
<li><strong>设计目标</strong>：Dalvik 字节码针对移动设备的有限内存和低功耗处理器优化，采用更紧凑的指令集和寄存器架构（Java 字节码是栈式架构），执行效率更高。</li>
<li><strong>存储形式</strong>：Java 字节码以<code>.class</code>文件单独存储，而 Dalvik 字节码将所有<code>.class</code>文件合并为单一的<code>.dex</code>文件，减少冗余并提高加载效率。</li>
<li><strong>运行环境</strong>：Java 字节码运行在 JVM（Java 虚拟机），而 Dalvik 字节码运行在 DVM；后期安卓引入 ART 虚拟机（Android Runtime）后，<code>.dex</code>文件会被预编译为本地机器码（<code>.oat</code>文件），但 Dalvik 字节码仍是逆向分析的基础。</li>
</ul>
<h4 id="逆向破解中作用："><a href="#逆向破解中作用：" class="headerlink" title="逆向破解中作用："></a>逆向破解中作用：</h4><ul>
<li>逆向入口：APK 核心逻辑载体，是提取、分析应用功能的起点（通过 dex2jar 等工具解析）。</li>
<li>静态分析基础：指令直接对应应用逻辑（如条件判断、方法调用），可定位关键函数（验证、付费等）、追踪数据流向。</li>
<li>动态调试对象：支持断点调试，可观察寄存器值、单步执行，实时修改指令绕过验证。</li>
<li>破解核心：可反编译为 Smali（汇编形式）修改指令（如反转条件、删除关键调用），重编译后替换原 dex，实现功能篡改。</li>
<li>对抗保护：即使被混淆 &#x2F; 加壳，仍可通过指令特征、动态捕获解密后字节码突破。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向工程核心流程</title>
    <url>/2025/08/09/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>安卓逆向工程是分析和修改已编译安卓应用程序（APK）的过程，其核心流程可分为以下关键步骤，结合静态分析、动态调试和工具链协作完成：</p>
<h3 id="一、环境与工具准备"><a href="#一、环境与工具准备" class="headerlink" title="一、环境与工具准备"></a>一、环境与工具准备</h3><ol>
<li><strong>基础工具链</strong><ul>
<li><strong>APKTool</strong>（最新版本 2.6.0）：用于解包 &#x2F; 重新打包 APK，提取资源和 AndroidManifest.xml。</li>
<li><strong>JADX</strong>：将 DEX 字节码反编译为可读 Java 代码，支持图形化界面快速定位逻辑。</li>
<li><strong>dex2jar + JD-GUI</strong>：将 DEX 转为 JAR 文件，配合 JD-GUI 查看反编译结果。</li>
<li><strong>IDA Pro&#x2F;Ghidra</strong>：静态分析 Native 代码（SO 文件），支持 ARM&#x2F;x86 架构反汇编与伪代码生成。</li>
</ul>
</li>
<li><strong>动态调试工具</strong><ul>
<li><strong>Frida</strong>：通过注入脚本 Hook Java&#x2F;Native 函数，实时修改运行时行为。</li>
<li><strong>Xposed</strong>：基于框架的全局 Hook 方案，适合系统级行为拦截。</li>
<li><strong>ZjDroid</strong>：针对加固应用的脱壳工具，支持内存 Dump 和 BakSmali 反编译。</li>
</ul>
</li>
<li><strong>签名与测试</strong><ul>
<li><strong>apksigner</strong>：处理 Android 7.0 + 的 V2&#x2F;V3 签名，确保重打包 APK 可安装。</li>
<li><strong>adb</strong>：与设备 &#x2F; 模拟器通信，执行安装、日志抓取等操作。</li>
</ul>
</li>
</ol>
<h3 id="二、逆向核心流程"><a href="#二、逆向核心流程" class="headerlink" title="二、逆向核心流程"></a>二、逆向核心流程</h3><h4 id="（一）APK-获取与初步分析"><a href="#（一）APK-获取与初步分析" class="headerlink" title="（一）APK 获取与初步分析"></a>（一）APK 获取与初步分析</h4><ol>
<li><strong>获取 APK</strong><ul>
<li>从应用商店下载、通过<code>adb pull</code>提取已安装应用，或通过网络爬虫获取目标 APK。</li>
<li>检查 APK 文件完整性：<code>apksigner verify --verbose app.apk</code>。</li>
</ul>
</li>
<li><strong>基础信息解析</strong><ul>
<li>使用<code>apktool d app.apk</code>解包，查看 AndroidManifest.xml 获取包名、权限、Activity 入口等。</li>
<li>分析资源文件（res 目录）和 Smali 代码结构，初步判断是否混淆或加固。</li>
</ul>
</li>
</ol>
<h4 id="（二）反编译与静态分析"><a href="#（二）反编译与静态分析" class="headerlink" title="（二）反编译与静态分析"></a>（二）反编译与静态分析</h4><ol>
<li><strong>代码反编译</strong><ul>
<li><strong>Java 层</strong>：直接用 JADX 打开 APK，导出 Java 代码进行逻辑梳理。</li>
<li><strong>Smali 层</strong>：通过<code>apktool</code>生成的 smali 文件夹，手工修改字节码（如去除广告、破解 VIP 功能）。</li>
<li><strong>Native 层</strong>：用 IDA Pro 打开 SO 文件，分析 JNI 接口和 ARM 汇编逻辑，定位关键算法（如加密、支付验证）。</li>
</ul>
</li>
<li><strong>代码审计</strong><ul>
<li>搜索敏感关键词（如<code>verifyPurchase</code>、<code>encrypt</code>），定位核心功能模块。</li>
<li>分析类继承关系和方法调用链，绘制 UML 图辅助理解架构。</li>
</ul>
</li>
</ol>
<h4 id="（三）动态调试与脱壳"><a href="#（三）动态调试与脱壳" class="headerlink" title="（三）动态调试与脱壳"></a>（三）动态调试与脱壳</h4><ol>
<li><strong>动态行为监控</strong><ul>
<li>使用<code>adb logcat</code>抓取运行时日志，定位关键日志输出点。</li>
<li>配合 Frida 脚本 Hook 目标函数，打印参数 &#x2F; 返回值，验证静态分析结果。</li>
</ul>
</li>
<li><strong>脱壳处理（针对加固应用）</strong><ul>
<li>动态脱壳：<ul>
<li>启动应用后，通过 Frida 注入脚本拦截<code>ClassLoader</code>的<code>loadClass</code>方法，Dump 内存中的原始 DEX。</li>
<li>示例命令：<code>frida -U -l dump_dex.js -f com.example.app --no-pause</code>。</li>
</ul>
</li>
<li><strong>工具辅助</strong>：ZjDroid 可通过广播命令 Dump 内存中的 DEX 并反编译，支持主流加固方案。</li>
</ul>
</li>
<li><strong>对抗反调试技术</strong><ul>
<li>绕过 Root 检测：修改<code>Build.VERSION.SDK_INT</code>或使用 Magisk 隐藏 Root 标识。</li>
<li>处理模拟器检测：通过 Frida Hook<code>Build.FINGERPRINT</code>返回真实设备信息。</li>
</ul>
</li>
</ol>
<h4 id="（四）代码修改与重打包"><a href="#（四）代码修改与重打包" class="headerlink" title="（四）代码修改与重打包"></a>（四）代码修改与重打包</h4><ol>
<li><strong>功能定制</strong><ul>
<li><strong>Java 层修改</strong>：直接编辑 JADX 导出的代码，重新编译为 DEX（需使用 dx 工具或 Android Studio）。</li>
<li><strong>Smali 层修改</strong>：使用文本编辑器调整 Smali 指令，例如将条件跳转<code>if-eq</code>改为<code>if-ne</code>。</li>
<li><strong>Native 层修改</strong>：在 IDA 中定位关键汇编指令，修改机器码（如将<code>BEQ</code>改为<code>BNE</code>），重新编译 SO 文件。</li>
</ul>
</li>
<li><strong>资源替换</strong><ul>
<li>替换 res 目录中的图片、字符串文件，实现界面汉化或 UI 调整。</li>
<li>注意：部分资源（如 9.png）需用<code>draw9patch</code>工具重新处理。</li>
</ul>
</li>
<li><strong>重新打包与签名</strong><ul>
<li>使用<code>apktool b modified_folder -o modified.apk</code>生成未签名 APK。</li>
<li>签名流程：<ol>
<li>生成密钥：<code>keytool -genkey -v -keystore mykey.jks -alias myalias -keyalg RSA -keysize 2048 -validity 10000</code>。</li>
<li>签名 APK：<code>apksigner sign --ks mykey.jks --out signed.apk modified.apk</code>。</li>
<li>优化对齐：<code>zipalign -v 4 signed.apk aligned.apk</code>。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="（五）测试与验证"><a href="#（五）测试与验证" class="headerlink" title="（五）测试与验证"></a>（五）测试与验证</h4><ol>
<li><strong>安装与运行</strong><ul>
<li>通过<code>adb install -r aligned.apk</code>安装修改后的 APK，启动应用验证功能是否正常。</li>
<li>使用<code>adb shell am start -n com.example.app/.MainActivity</code>直接启动指定 Activity。</li>
</ul>
</li>
<li><strong>稳定性测试</strong><ul>
<li>检查是否存在崩溃（通过<code>adb logcat</code>查看 AndroidRuntime 异常）。</li>
<li>验证关键功能（如支付、网络请求）是否按预期修改。</li>
</ul>
</li>
</ol>
<h3 id="三、高级技巧与注意事项"><a href="#三、高级技巧与注意事项" class="headerlink" title="三、高级技巧与注意事项"></a>三、高级技巧与注意事项</h3><ol>
<li><strong>反混淆与去加密</strong><ul>
<li><strong>字符串解密</strong>：使用<code>dex-oracle</code>工具动态执行加密字符串的解密函数，提取明文。</li>
<li><strong>控制流平坦化</strong>：通过 IDA 脚本或 Ghidra 插件还原混淆后的代码结构。</li>
</ul>
</li>
<li><strong>自动化脚本开发</strong><ul>
<li>编写 Frida 脚本批量 Hook 指定类的所有方法，生成调用关系图谱。</li>
<li>使用 Auto.js 实现自动化测试，模拟用户操作触发逆向目标逻辑。</li>
</ul>
</li>
<li><strong>法律与合规</strong><ul>
<li>确保逆向行为符合《计算机软件保护条例》和应用的最终用户许可协议（EULA），避免用于商业盗版或恶意攻击。</li>
<li>仅对自有应用或明确授权的应用进行逆向分析。</li>
</ul>
</li>
</ol>
<h3 id="四、典型场景解决方案"><a href="#四、典型场景解决方案" class="headerlink" title="四、典型场景解决方案"></a>四、典型场景解决方案</h3><ol>
<li><strong>破解 VIP 功能</strong><ul>
<li>定位支付验证逻辑，修改返回值为<code>true</code>或绕过网络校验。</li>
<li>若涉及 SO 文件，通过 IDA 修改 JNI 函数的返回值（如将<code>0</code>改为<code>1</code>）。</li>
</ul>
</li>
<li><strong>去除广告</strong><ul>
<li>Hook 广告 SDK 的初始化方法（如<code>AdManager.getInstance().init()</code>），拦截广告加载流程。</li>
<li>直接删除 Smali 代码中的广告相关类和方法。</li>
</ul>
</li>
<li><strong>脱壳 360 加固应用</strong><ul>
<li>使用 ZjDroid 的<code>backsmali</code>命令 Dump 内存中的 DEX，结合 Xposed Hook<code>ActivityThread</code>的<code>attach</code>方法绕过检测。</li>
</ul>
</li>
</ol>
<h3 id="五、工具链整合与效率提升"><a href="#五、工具链整合与效率提升" class="headerlink" title="五、工具链整合与效率提升"></a>五、工具链整合与效率提升</h3><ol>
<li><p><strong>流程自动化</strong></p>
<ul>
<li><p>编写 Shell 脚本整合<code>apktool</code>、<code>jarsigner</code>等工具，实现一键解包 - 修改 - 签名。</p>
</li>
<li><p>示例脚本片段：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">apktool d app.apk -o workdir</span><br><span class="line"><span class="comment"># 修改代码...</span></span><br><span class="line">apktool b workdir -o modified.apk</span><br><span class="line">apksigner sign --ks mykey.jks modified.apk</span><br><span class="line">adb install modified.apk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>团队协作</strong></p>
<ul>
<li>使用 Git 管理逆向工程中的代码修改和脚本，配合 Jira 追踪漏洞或功能点。</li>
<li>共享 IDA&#x2F;Ghidra 的签名数据库（.til 文件），加速 SO 文件分析。</li>
</ul>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>安卓逆向工程是技术与法律的双重挑战，需综合运用静态分析、动态调试、工具链协作等手段。核心流程可概括为：<strong>获取 APK → 解包反编译 → 分析与修改 → 重打包签名 → 测试验证</strong>，其中脱壳、反混淆、动态调试是应对复杂应用的关键。建议从简单应用入手，逐步掌握 Smali 语法、ARM 汇编和脚本开发，同时严格遵守法律边界，确保逆向行为的合法性。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓理论</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓系统基础</title>
    <url>/2025/08/08/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>理论：Linux 内核、Framework 层（四大组件：Activity&#x2F;Service&#x2F;Broadcast&#x2F;ContentProvider）、APK 结构（classes.dex&#x2F;res&#x2F;AndroidManifest.xml）。</strong></p>
<p>安卓系统就像一座功能强大得“智能大楼”，而<strong>Linux内核、Framework层、APK结构</strong>就是这座大楼得“地基、基础设施、和具体房间”。现使用生活中得例子一步步拆解。</p>
<h2 id="一、Linux内核：安卓得“地基和水电管道”"><a href="#一、Linux内核：安卓得“地基和水电管道”" class="headerlink" title="一、Linux内核：安卓得“地基和水电管道”"></a>一、Linux内核：安卓得“地基和水电管道”</h2><h3 id="易理解"><a href="#易理解" class="headerlink" title="易理解"></a>易理解</h3><p>可以把安卓系统想象成一座大楼，而 <strong>Linux 内核</strong> 就是这座大楼的 “地基” 和 “水电管道系统”。它是安卓系统最底层的核心，负责连接手机的硬件（比如 CPU、内存、电池、摄像头等）和上层的软件（比如你的微信、抖音），让硬件能正常工作。</p>
<h4 id="具体作用（用生活例子说）："><a href="#具体作用（用生活例子说）：" class="headerlink" title="具体作用（用生活例子说）："></a>具体作用（用生活例子说）：</h4><ul>
<li><strong>“交通指挥”</strong>：管理手机里的 “程序任务”（比如同时开微信和抖音），确保它们不打架、不卡顿（专业叫 “进程管理”）。</li>
<li><strong>“水电分配”</strong>：给每个应用分配手机的内存、电量等资源，避免某个应用 “霸占” 太多资源导致手机卡死（专业叫 “内存管理、电源管理”）。</li>
<li><strong>“硬件翻译官”</strong>：手机的摄像头、触摸屏、麦克风等硬件都是 “哑巴”，需要内核来 “翻译” 软件的指令（比如你点屏幕 “拍照”），让硬件听懂并执行（专业叫 “硬件驱动”）。</li>
</ul>
<p>简单说：没有 Linux 内核，手机的硬件就是一堆废铁，上层的任何应用都跑不起来。</p>
<h3 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h3><p>在安卓系统中，<strong>Linux 内核</strong>是整个系统的底层核心，负责硬件与软件之间的 “桥梁” 作用，提供基础的系统资源管理和硬件抽象能力。从专业角度来说，它的核心功能和作用可以概括为以下几个方面：</p>
<h4 id="1-硬件抽象层（Hardware-Abstraction）"><a href="#1-硬件抽象层（Hardware-Abstraction）" class="headerlink" title="1. 硬件抽象层（Hardware Abstraction）"></a>1. <strong>硬件抽象层（Hardware Abstraction）</strong></h4><p>Linux 内核通过 “驱动程序（Drivers）” 对手机的硬件设备（如 CPU、内存、摄像头、触摸屏、传感器、电池、存储芯片等）进行抽象。</p>
<ul>
<li>上层的 Framework 框架和应用程序不需要直接操作硬件的物理接口（如寄存器、电路信号），而是通过内核提供的标准化接口（如系统调用、设备文件）与硬件交互。</li>
<li>例如：当应用需要调用摄像头拍照时，它不会直接发送电信号到摄像头传感器，而是通过内核的摄像头驱动程序，由驱动程序完成硬件的具体控制。</li>
</ul>
<h4 id="2-进程与线程管理"><a href="#2-进程与线程管理" class="headerlink" title="2. 进程与线程管理"></a>2. <strong>进程与线程管理</strong></h4><p>内核负责对系统中的 “进程（Process）” 和 “线程（Thread）” 进行调度和管理，确保多任务高效运行：</p>
<ul>
<li><strong>进程调度</strong>：通过调度算法（如安卓优化的 CFS 调度器）为每个进程分配 CPU 时间片，避免某个进程独占资源，保证系统流畅性（比如同时运行微信、音乐和浏览器时，内核协调它们的 CPU 使用权）。</li>
<li><strong>进程隔离</strong>：通过 “进程 ID（PID）” 和内存隔离机制，确保不同应用的进程相互独立，一个应用崩溃不会影响其他应用或系统核心。</li>
<li><strong>线程管理</strong>：支持多线程并发，允许单个应用内的多个任务（如 UI 渲染、后台数据加载）并行执行，提升应用响应速度。</li>
</ul>
<h4 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. <strong>内存管理</strong></h4><p>内核负责手机内存（RAM）的分配、回收和保护：</p>
<ul>
<li><strong>内存分配</strong>：为应用、框架和系统进程分配内存空间，通过虚拟内存技术（VM）让每个进程 “认为自己独占内存”，实际由内核统一管理物理内存。</li>
<li><strong>内存回收</strong>：当内存不足时，通过 “低内存杀手（Low Memory Killer，LMK）” 机制，按优先级回收后台进程的内存（如先杀长时间不用的后台应用，保留前台应用和系统核心进程）。</li>
<li><strong>内存保护</strong>：通过权限控制和地址空间隔离，防止进程非法访问其他进程或内核的内存区域，避免数据泄露或恶意攻击。</li>
</ul>
<h4 id="4-文件系统管理"><a href="#4-文件系统管理" class="headerlink" title="4. 文件系统管理"></a>4. <strong>文件系统管理</strong></h4><p>内核提供文件系统支持，负责数据的存储和访问：</p>
<ul>
<li>支持多种存储介质（如手机内置闪存、SD 卡）和文件系统格式（如 ext4、FAT32），统一抽象为 “文件” 接口，让上层应用可以通过 “读 &#x2F; 写文件” 的方式操作存储设备。</li>
<li>管理文件的权限（如哪些应用可以读写某个文件）、路径和 metadata（如创建时间、大小），确保数据存储的有序性和安全性。</li>
</ul>
<h4 id="5-设备与电源管理"><a href="#5-设备与电源管理" class="headerlink" title="5. 设备与电源管理"></a>5. <strong>设备与电源管理</strong></h4><p>针对移动设备特性，安卓对 Linux 内核进行了定制，强化了设备和电源管理能力：</p>
<ul>
<li><strong>电源管理</strong>：通过 “休眠 &#x2F; 唤醒” 机制（如 CPU 降频、屏幕休眠）减少待机功耗；支持 “动态电压频率调节（DVFS）”，根据应用负载自动调整 CPU 频率（如玩游戏时提频，待机时降频），平衡性能和耗电。</li>
<li><strong>设备状态监控</strong>：实时监控硬件状态（如电池电量、温度、网络连接），并向上层反馈（如通过广播通知低电量）。</li>
</ul>
<h4 id="6-网络与安全机制"><a href="#6-网络与安全机制" class="headerlink" title="6. 网络与安全机制"></a>6. <strong>网络与安全机制</strong></h4><ul>
<li><strong>网络管理</strong>：内核集成网络协议栈（如 TCP&#x2F;IP、WiFi、蓝牙协议），负责数据的封装、传输和路由，让应用可以通过网络接口（如 Socket）实现联网功能（如上网、发消息）。</li>
<li><strong>安全基础</strong>：基于 Linux 的 “用户 - 组 - 权限” 模型（如文件权限 rwx、进程 UID&#x2F;GID），为系统提供基础安全隔离；后续安卓的 SELinux（安全增强型 Linux）也是基于内核实现的强制访问控制。</li>
</ul>
<h2 id="二、Framework-层：安卓的-“基础设施和规则手册”"><a href="#二、Framework-层：安卓的-“基础设施和规则手册”" class="headerlink" title="二、Framework 层：安卓的 “基础设施和规则手册”"></a>二、Framework 层：安卓的 “基础设施和规则手册”</h2><h3 id="易理解-1"><a href="#易理解-1" class="headerlink" title="易理解"></a>易理解</h3><p>在 Linux 内核之上，有一层叫 <strong>Framework（框架）层</strong>，它相当于大楼的 “基础设施管理系统” 和 “规则手册”。它封装了很多现成的工具和功能，给开发者提供 “现成的轮子”，让开发者不用从零开始写代码，就能快速开发出应用。</p>
<p>其中最核心的就是 <strong>四大组件</strong>，它们是安卓应用的 “基本功能模块”，就像大楼里的 “电梯、水管、广播系统、储物间”，各司其职。</p>
<h4 id="1-Activity：手机上的-“屏幕界面”"><a href="#1-Activity：手机上的-“屏幕界面”" class="headerlink" title="1. Activity：手机上的 “屏幕界面”"></a>1. Activity：手机上的 “屏幕界面”</h4><p>Activity 是你能直接看到的 “界面”，比如微信的聊天界面、抖音的视频播放界面、手机的设置界面，每个界面都是一个 Activity。</p>
<ul>
<li><strong>特点</strong>：一个应用可以有多个 Activity（比如微信有 “聊天列表页”“聊天详情页”“朋友圈页”），它们之间可以跳转（比如点微信好友头像，从列表页跳到详情页）。</li>
<li><strong>生活类比</strong>：就像大楼里的 “一个个房间”，每个房间有自己的功能（卧室睡觉、客厅看电视），你可以在房间之间走动（跳转）。</li>
</ul>
<h4 id="2-Service：后台默默工作的-“隐形员工”"><a href="#2-Service：后台默默工作的-“隐形员工”" class="headerlink" title="2. Service：后台默默工作的 “隐形员工”"></a>2. Service：后台默默工作的 “隐形员工”</h4><p>Service 是在后台 “偷偷干活” 的组件，你看不到它，但它一直在运行。</p>
<ul>
<li><p>例子：</p>
<ul>
<li>你听音乐时，按 Home 键退出音乐 APP 界面（Activity 关闭了），但音乐还在播放，这就是 Service 在后台继续工作；</li>
<li>手机下载文件时，你切到其他 APP，下载不会停，也是 Service 在后台运行。</li>
</ul>
</li>
<li><p><strong>生活类比</strong>：就像大楼里的 “空调系统”，你看不到它的机器，但它一直在后台制冷 &#x2F; 制热，即使你在不同房间走动，它也不停。</p>
</li>
</ul>
<h4 id="3-BroadcastReceiver：手机里的-“广播通知员”"><a href="#3-BroadcastReceiver：手机里的-“广播通知员”" class="headerlink" title="3. BroadcastReceiver：手机里的 “广播通知员”"></a>3. BroadcastReceiver：手机里的 “广播通知员”</h4><p>BroadcastReceiver 是 “接收和传递消息” 的组件，就像大楼里的 “广播喇叭”，任何应用或系统都可以发 “广播”，它负责接收并处理消息。</p>
<ul>
<li><p>例子：</p>
<ul>
<li>手机没电时，系统发一条 “低电量广播”，你的 APP 可以收到后提醒你 “快充电”；</li>
<li>收到短信时，系统发一条 “新短信广播”，短信 APP 收到后显示通知。</li>
</ul>
</li>
<li><p><strong>生活类比</strong>：就像小区的 “广播通知”，物业（系统）或住户（应用）发通知，大家（对应的 Receiver）听到后做反应（比如收快递、做核酸）。</p>
</li>
</ul>
<h4 id="4-ContentProvider：应用间的-“数据共享桥梁”"><a href="#4-ContentProvider：应用间的-“数据共享桥梁”" class="headerlink" title="4. ContentProvider：应用间的 “数据共享桥梁”"></a>4. ContentProvider：应用间的 “数据共享桥梁”</h4><p>ContentProvider 是让不同应用之间 “安全共享数据” 的组件。比如你的通讯录应用里的联系人，其他应用（比如微信添加好友时）需要读取，就通过 ContentProvider 实现。</p>
<ul>
<li><strong>特点</strong>：它像一个 “数据管家”，只允许被授权的应用访问数据，避免数据泄露（比如你可以设置微信是否能读取通讯录）。</li>
<li><strong>生活类比</strong>：就像小区的 “快递柜”，快递员（数据产生的应用，比如通讯录）把快递（数据）放进柜子，你授权的人（其他应用，比如微信）凭验证码（权限）才能取。</li>
</ul>
<h3 id="专业知识-1"><a href="#专业知识-1" class="headerlink" title="专业知识"></a>专业知识</h3><h4 id="1-Activity（活动）"><a href="#1-Activity（活动）" class="headerlink" title="1.Activity（活动）"></a>1.Activity（活动）</h4><h5 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>用户交互的基础界面单元</strong>，应用的每个可视化屏幕通常对应一个 Activity</li>
<li>组件间跳转的核心载体，通过<strong>Intent</strong>实现页面切换（正向开发与逆向分析均需重点关注的交互节点）</li>
</ul>
<h5 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h5><ul>
<li><p><strong>生命周期</strong>：完整生命周期为 <code>onCreate()</code>（初始化）→ <code>onStart()</code>（可见）→ <code>onResume()</code>（可交互）→ <code>onPause()</code>（部分可见）→ <code>onStop()</code>（不可见）→ <code>onDestroy()</code>（销毁），系统通过生命周期方法管理组件状态</p>
</li>
<li><p>启动模式：</p>
<ul>
<li><code>standard</code>（默认，每次启动新建实例）</li>
<li><code>singleTop</code>（栈顶复用，避免重复创建）</li>
<li><code>singleTask</code>（栈内唯一，清除其上方实例）</li>
<li><code>singleInstance</code>（独立任务栈，全局唯一）<br>  （逆向时需关注启动模式对任务栈的管理逻辑，影响页面跳转流程）</li>
</ul>
</li>
<li><p><strong>布局绑定</strong>：通过 <code>setContentView()</code> 关联 XML 布局文件，实现界面渲染</p>
</li>
</ul>
<h5 id="逆向关注点"><a href="#逆向关注点" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p>定位应用入口：在<code>AndroidManifest.xml</code>中查找包含以下过滤器的 Activity，即为 Launcher Activity（应用启动第一个页面）：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跨组件数据传递</strong>：分析 <code>startActivityForResult()</code> 与 <code>onActivityResult()</code> 逻辑，获取页面间数据回传细节（如登录凭证、选择结果）</p>
</li>
<li><p><strong>Hook 关键方法</strong>：通过 Hook <code>onCreate()</code> 查看初始化逻辑（如密钥加载、配置读取），Hook <code>onActivityResult()</code> 追踪敏感数据流向</p>
</li>
</ul>
<h4 id="2-Service（服务）"><a href="#2-Service（服务）" class="headerlink" title="2.Service（服务）"></a>2.Service（服务）</h4><h5 id="核心定义-1"><a href="#核心定义-1" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>无界面的后台运行组件</strong>，用于执行长期耗时任务（如下载、音乐播放、数据同步），独立于界面生命周期</li>
<li>两种启动方式：<ul>
<li><code>startService()</code>：启动后独立运行，需主动调用 <code>stopService()</code>：停止（如后台下载）</li>
<li><code>bindService()</code>：与调用组件（如 Activity）绑定，通过 Binder&#x2F;aidl 实现 IPC（跨进程通信），组件销毁时服务解绑</li>
</ul>
</li>
</ul>
<h5 id="生命周期差异"><a href="#生命周期差异" class="headerlink" title="生命周期差异"></a>生命周期差异</h5><ul>
<li><strong>启动式服务</strong>：<code>onCreate()</code>（初始化）→ <code>onStartCommand()</code>（接收启动指令）→ <code>onDestroy()</code>（销毁释放资源）</li>
<li><strong>绑定式服务</strong>：<code>onCreate()</code>（初始化）→ <code>onBind()</code>（返回 Binder 对象）→ <code>onUnbind()</code>（解绑回调）→ <code>onDestroy()</code>（销毁）</li>
</ul>
<h5 id="逆向关注点-1"><a href="#逆向关注点-1" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><strong>前台服务识别</strong>：反编译 <code>AndroidManifest.xml</code> 或代码，查找 <code>startForeground()</code> 调用（前台服务需显示通知，优先级高，常用于保活），分析通知配置与保活逻辑</li>
<li><strong>IntentService 机制</strong>：定位继承 <code>IntentService</code> 的服务，其内部通过 HandlerThread 串行处理任务，需分析 <code>onHandleIntent()</code> 中的后台逻辑（如数据加密、API 请求）</li>
<li><strong>跨进程通信接口</strong>：查找 AIDL 文件（<code>.aidl</code>），解析 <code>onBind()</code> 返回的 Binder 接口，获取进程间交互的敏感数据（如用户信息、权限验证）</li>
</ul>
<h4 id="3-BroadcastReceiver（广播接收器）"><a href="#3-BroadcastReceiver（广播接收器）" class="headerlink" title="3.BroadcastReceiver（广播接收器）"></a>3.BroadcastReceiver（广播接收器）</h4><h5 id="核心定义-2"><a href="#核心定义-2" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><strong>系统 &#x2F; 应用事件的监听组件</strong>，用于接收并响应全局事件（如网络状态变化、短信接收、开机完成）</li>
<li>两种注册方式：<ul>
<li><strong>静态注册</strong>：在 <code>AndroidManifest.xml</code> 中声明，应用未启动时可接收广播（如监听开机广播）</li>
<li><strong>动态注册</strong>：在代码中通过 <code>registerReceiver()</code> 注册，随宿主组件（如 Activity）生命周期生效，需手动调用 <code>unregisterReceiver()</code> 注销</li>
</ul>
</li>
</ul>
<h5 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h5><ol>
<li>发送广播：通过 <code>sendBroadcast(Intent)</code> 或 <code>sendOrderedBroadcast(Intent)</code> 发送事件</li>
<li>匹配接收器：系统根据 <code>IntentFilter</code> 中的 <code>action</code>、<code>category</code> 筛选目标接收器</li>
<li>执行逻辑：匹配成功后触发接收器的 <code>onReceive(Context, Intent)</code> 方法</li>
</ol>
<h5 id="逆向关注点-2"><a href="#逆向关注点-2" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p><strong>敏感广播监控</strong>：重点追踪系统级广播（如 <code>android.intent.action.BOOT_COMPLETED</code> 开机自启、<code>android.provider.Telephony.SMS_RECEIVED</code> 短信接收），分析其 <code>onReceive()</code> 中的逻辑（如自启动触发、短信内容窃取）</p>
</li>
<li><p><strong>有序广播优先级滥用</strong>：检查静态注册<code>&lt;intent-filter&gt;</code></p>
<p>  优先级<code>（android:priority）</code>，高优先级接收器可能通过 <code>abortBroadcast()</code>拦截广播（如恶意应用拦截验证码短信）：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态注册追踪</strong>：在代码中定位 <code>registerReceiver()</code> 调用，分析动态注册的广播类型与响应逻辑（如应用内数据更新通知）</p>
</li>
</ul>
<h4 id="4-ContentProvider（内容提供者）"><a href="#4-ContentProvider（内容提供者）" class="headerlink" title="4.ContentProvider（内容提供者）"></a>4.ContentProvider（内容提供者）</h4><h5 id="核心定义-3"><a href="#核心定义-3" class="headerlink" title="核心定义"></a>核心定义</h5><ul>
<li><p><strong>跨应用数据共享的标准化接口</strong>，用于安全暴露应用内部数据（如数据库、文件）给其他应用访问</p>
</li>
<li><p>通过URI唯一标识数据源，格式为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content:<span class="comment">//com.example.provider/user/1</span></span><br><span class="line">↑          ↑                ↑     ↑</span><br><span class="line">协议       授权名（包名）    数据路径  记录ID</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><ul>
<li><code>query(Uri, String[], String, String[], String)</code>：查询数据（类似 SQL 的 SELECT）</li>
<li><code>insert(Uri, ContentValues)</code>：插入数据（类似 SQL 的 INSERT）</li>
<li><code>update(Uri, ContentValues, String, String[])</code>：更新数据（类似 SQL 的 UPDATE）</li>
<li><code>delete(Uri, String, String[])</code>：删除数据（类似 SQL 的 DELETE）</li>
<li><code>getType(Uri)</code>：返回数据的 MIME 类型（如 <code>vnd.android.cursor.item/user</code>）</li>
</ul>
<h5 id="逆向关注点-3"><a href="#逆向关注点-3" class="headerlink" title="逆向关注点"></a>逆向关注点</h5><ul>
<li><p>权限控制分析：在 <code>AndroidManifest.xml</code> 中查看 <code>&lt;provider&gt;</code></p>
<p>  声明的读写权限，判断是否存在权限配置宽松（如未声明权限）导致的敏感数据泄露：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.provider&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:readPermission</span>=<span class="string">&quot;com.example.READ_DATA&quot;</span>  // <span class="attr">读权限</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">android:writePermission</span>=<span class="string">&quot;com.example.WRITE_DATA&quot;</span> // <span class="attr">写权限</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  // 是否允许外部应用访问</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据操作追踪</strong>：通过 Hook <code>ContentResolver</code> 的 <code>query()</code>&#x2F;<code>insert()</code> 等方法，获取其他应用访问本应用数据的路径与内容（如通讯录、相册的访问记录）</p>
</li>
<li><p><strong>URI 注入漏洞检测</strong>：分析 <code>query()</code> 等方法中对输入 URI 的校验逻辑，若未过滤特殊字符（如 <code>../</code>），可能存在目录遍历或 SQL 注入风险</p>
</li>
</ul>
<h2 id="三、APK-结构：安卓应用的-“安装包三件套”"><a href="#三、APK-结构：安卓应用的-“安装包三件套”" class="headerlink" title="三、APK 结构：安卓应用的 “安装包三件套”"></a>三、APK 结构：安卓应用的 “安装包三件套”</h2><h3 id="易理解-2"><a href="#易理解-2" class="headerlink" title="易理解"></a>易理解</h3><p>你在应用商店下载的 APP，本质上是一个后缀为 <code>.apk</code> 的文件（比如 “微信.apk”），它是安卓应用的 “安装包”。这个安装包里装着应用运行的所有 “零件”，核心有三个：</p>
<h4 id="1-classes-dex：应用的-“大脑指令集”"><a href="#1-classes-dex：应用的-“大脑指令集”" class="headerlink" title="1. classes.dex：应用的 “大脑指令集”"></a>1. classes.dex：应用的 “大脑指令集”</h4><p>你写的 Java&#x2F;Kotlin 代码，经过编译后会变成一个叫 <code>classes.dex</code> 的文件，它相当于应用的 “大脑”，里面是计算机能看懂的 “指令”（比如 “点击按钮后跳转到下一页”“计算加法结果”）。</p>
<ul>
<li>生活类比：就像菜谱里的 “步骤说明”，厨师（手机 CPU）按照步骤做菜（运行应用）。</li>
</ul>
<h4 id="2-res：应用的-“素材仓库”"><a href="#2-res：应用的-“素材仓库”" class="headerlink" title="2. res：应用的 “素材仓库”"></a>2. res：应用的 “素材仓库”</h4><p><code>res</code> 是 “资源文件夹”，里面存着应用的所有 “素材”：</p>
<ul>
<li>图片（比如 APP 图标、按钮背景图）；</li>
<li>文字（比如按钮上的 “登录”“注册” 文字，支持多语言翻译）；</li>
<li>布局文件（比如界面里按钮、文字的位置排列，像装修设计图）。</li>
<li>生活类比：就像做菜的 “食材和餐具”，菜谱（classes.dex）需要用这些素材才能做出菜（显示界面）。</li>
</ul>
<h4 id="3-AndroidManifest-xml：应用的-“身份证和说明书”"><a href="#3-AndroidManifest-xml：应用的-“身份证和说明书”" class="headerlink" title="3. AndroidManifest.xml：应用的 “身份证和说明书”"></a>3. AndroidManifest.xml：应用的 “身份证和说明书”</h4><p>这个文件是应用的 “配置清单”，相当于给系统的 “说明书”，告诉系统：</p>
<ul>
<li>这个应用叫什么名字、图标是什么；</li>
<li>它有哪些组件（Activity、Service 等），比如 “登录界面是哪个 Activity”；</li>
<li>它需要什么权限（比如 “允许访问摄像头”“允许读取位置”）。</li>
<li>生活类比：就像商品的 “包装说明”，告诉买家（系统）这是什么商品、怎么用、需要什么条件（比如 “需冷藏” 对应 “需定位权限”）。</li>
</ul>
<h3 id="专业知识-2"><a href="#专业知识-2" class="headerlink" title="专业知识"></a>专业知识</h3><p>在安卓应用的APK结构中，所谓的“安装包三件套”指的是构成APK核心功能的三个关键文件：<strong>AndroidManifest.xml</strong>、<strong>classes.dex</strong>（或多个dex文件）、<strong>resources.arsc</strong>。这三个文件是APK的“骨架”，决定了应用的基本功能、运行逻辑和资源管理方式，也是安卓逆向分析中最核心的分析对象。</p>
<h4 id="1-AndroidManifest-xml：应用的“身份证与说明书”"><a href="#1-AndroidManifest-xml：应用的“身份证与说明书”" class="headerlink" title="1.AndroidManifest.xml：应用的“身份证与说明书”"></a>1.AndroidManifest.xml：应用的“身份证与说明书”</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>它是APK的全局配置文件，记录了应用的“身份信息”和“功能清单”，系统安装和运行应用时首先读取该文件。</p>
<h5 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h5><ul>
<li><p><strong>应用身份</strong>：</p>
<ul>
<li>包名（package）：应用的唯一标识（如<code>com.example.myapp</code>），是系统区分不同应用的依据。</li>
<li>版本信息：<code>versionCode</code>（内部版本号，整数，用于升级判断）和<code>versionName</code>（用户可见版本号，如<code>1.0.0</code>）。</li>
</ul>
</li>
<li><p><strong>组件声明</strong>：</p>
<p>  安卓应用的四大组件（Acivity、Service、BroadcastReceiver、ContentProvider）必须在此声明才能被系统识别和调用。</p>
<ul>
<li>例如：声明启动页Activity（<code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;</code>）及启动模式、意图过滤器（Intent Filter）等。</li>
</ul>
</li>
<li><p><strong>权限声明</strong>：</p>
<p>  应用需要的系统权限（如联网、读写文件、获取位置等），通过<code>&lt;uses-permission&gt;</code>标签声明（如<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code>）。</p>
</li>
<li><p><strong>其他配置</strong>：</p>
<p>  如最低支持的安卓版本（<code>minSdVersion</code>）、目标版本（<code>targetSdkVersion</code>）、应用图标、主题等。</p>
</li>
</ul>
<h5 id="格式与逆向注意"><a href="#格式与逆向注意" class="headerlink" title="格式与逆向注意"></a><strong>格式与逆向注意</strong></h5><ul>
<li>原始APK中<code>androidManifest.xml</code>是<strong>二进制XML格式</strong>（为了压缩和加密），无法直接阅读。</li>
<li>逆向时需要用APKtool等工具反编译为可读的文本XML（如<code>apktool d app.apk</code>），通过分析该文件可快速了解应用的功能范围、权限需求和组件结构。</li>
</ul>
<h4 id="2-classes-dex：应用的-“逻辑大脑”"><a href="#2-classes-dex：应用的-“逻辑大脑”" class="headerlink" title="2.classes.dex：应用的 “逻辑大脑”"></a>2.classes.dex：应用的 “逻辑大脑”</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>它是安卓应用的<strong>可执行字节码文件</strong>，包含了应用的所有业务逻辑（ 如按钮点击事件、网络请求、数据处理等），是应用的核心 。</p>
<h5 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h5><ul>
<li><p><strong>格式特殊性</strong></p>
<p>  不同于Java的<code>class</code>文件，<code>classes.dex</code>是基于<strong>Dalvik&#x2F;ART虚拟机</strong>的字节码格式（Dalvik Executable）。安卓将所有Java代码编译后的<code>class</code>文件合并、优化为一个或多个<code>dex</code>文件（当代码量过大是会拆分出<code>classes2.dex</code>、<code>classes3.dex</code>等），一提高运行效率。</p>
</li>
<li><p><strong>逆向关键</strong></p>
<ul>
<li><code>dex</code>文件是逆向分析的核心目标，通过工具（如<code>dex2jar</code>）可将其转换为Java的<code>jar</code>文件，再用<code>JD-GUI</code>或<code>jadx</code>等工具查看近似的Java源代码（需注意：混淆后的diamagnetic会被重命名为a、b、c等无意义类名，增加分析难度）。</li>
<li>动态调试时（如用<code>IDA Pro</code>或<code>Frida</code>），<code>dex</code>文件的字节码时断点和hook的主要操作对象。</li>
</ul>
</li>
</ul>
<h4 id="3-resources-arsc：资源的“索引字典”"><a href="#3-resources-arsc：资源的“索引字典”" class="headerlink" title="3.resources.arsc：资源的“索引字典”"></a>3.resources.arsc：资源的“索引字典”</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>它是应用的<strong>资源索引表</strong>，用于管理应用中的所有静态资源（字符串、图片、布局文件、颜色、尺寸等），实现资源的高效查找和适配。</p>
<h5 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h5><ul>
<li><p><strong>资源分类与索引</strong>：</p>
<ul>
<li>应用的资源（如<code>res/values/strings.xml</code>中的字符串、<code>res/drawable/</code>中的图片）会被编译为二进制格式，而<code>resources.arsc</code>则记录了这些资源的 ID、类型、路径及对应的语言、分辨率等适配信息。</li>
</ul>
</li>
<li><p><strong>资源适配支持</strong>：</p>
<ul>
<li>安卓系统会根据设备的语言（如中文 &#x2F; 英文）、屏幕分辨率、系统版本等，通过<code>resources.arsc</code>索引到最合适的资源（例如：中文设备优先加载<code>values-zh</code>目录下的字符串）。</li>
</ul>
</li>
</ul>
<h4 id="逆向中的应用"><a href="#逆向中的应用" class="headerlink" title="逆向中的应用"></a>逆向中的应用</h4><ul>
<li>反编译后，<code>resources.arsc</code>会被转换为可读的资源索引信息，结合<code>res</code>目录下的具体资源文件（如图片、布局 XML），可分析应用的 UI 设计、文本内容（如关键提示信息、接口地址等）。</li>
<li>修改<code>resources.arsc</code>和对应资源文件（如替换图标、修改文本）是 “换皮” 类逆向的常用操作。</li>
</ul>
<h4 id="三者的协同关系"><a href="#三者的协同关系" class="headerlink" title="三者的协同关系"></a>三者的协同关系</h4><p>APK 的运行依赖这三个文件的配合：</p>
<ol>
<li>系统通过<code>AndroidManifest.xml</code>识别应用身份、权限和组件，决定如何启动应用；</li>
<li>启动后，通过<code>resources.arsc</code>加载对应的 UI 资源和文本，展示界面；</li>
<li>用户操作（如点击按钮）触发<code>classes.dex</code>中的逻辑代码，完成具体功能（如跳转页面、提交数据）。</li>
</ol>
<h2 id="总结：安卓系统的-“三层关系”"><a href="#总结：安卓系统的-“三层关系”" class="headerlink" title="总结：安卓系统的 “三层关系”"></a>总结：安卓系统的 “三层关系”</h2><p>从底层到上层，就像 “地基→基础设施→房间”：</p>
<ol>
<li><strong>Linux 内核</strong>（地基）：支撑硬件运行，管资源分配；</li>
<li><strong>Framework 层</strong>（基础设施）：提供四大组件等工具，让开发者能快速做应用；</li>
<li><strong>APK</strong>（具体房间）：打包了代码、素材和配置，安装后就是你用的 APP。</li>
</ol>
<p>这样一来，安卓系统就能稳定、高效地运行各种应用啦～</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>四大件</tag>
      </tags>
  </entry>
  <entry>
    <title>环境小记</title>
    <url>/2025/05/21/%E7%8E%AF%E5%A2%83%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1-Windows环境配置"><a href="#1-Windows环境配置" class="headerlink" title="1. Windows环境配置"></a>1. Windows环境配置</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>1.WINDOWS环境配置的难易程度因人而异，很多学员在此步骤上遇到困难。 </p>
<p>2.LINUX系统问题较少，原因是使用者较少且版本统一，而WINDOWS系统版本繁多，导致问题多样。 </p>
<p>3.WINDOWS系统使用ANSI编码，与常用的UTF-8编码不同，可能导致兼容性问题。</p>
<h3 id="1-2-系统版本选择"><a href="#1-2-系统版本选择" class="headerlink" title="1.2 系统版本选择"></a>1.2 系统版本选择</h3><p>1.推荐使用原版WINDOWS 10系统，避免使用精简版，以防出现未知问题。</p>
<p> 2.查看系统版本的方法包括使用win ver命令或系统设置中的关于选项。 </p>
<p>3.启用超级用户（类似于安卓系统的root用户）可以解决权限问题，避免某些操作失败。</p>
<h2 id="2-cmd和环境变量"><a href="#2-cmd和环境变量" class="headerlink" title="2. cmd和环境变量"></a>2. cmd和环境变量</h2><h3 id="2-1-cmd的打开方式"><a href="#2-1-cmd的打开方式" class="headerlink" title="2.1 cmd的打开方式"></a>2.1 cmd的打开方式</h3><p>1.cmd是一个常用的终端工具，在逆向工程中经常使用。 </p>
<p>2.打开cmd的方式有多种，推荐使用快捷键win键+r键打开。 </p>
<p>3.另一种打开方式是在指定路径下直接点击cmd，无需切换路径。</p>
<h3 id="2-2-cmd的基本操作"><a href="#2-2-cmd的基本操作" class="headerlink" title="2.2 cmd的基本操作"></a>2.2 cmd的基本操作</h3><p>1.显示当前路径下的所有文件，使用dir命令。 </p>
<p>2.清屏操作，使用cls命令。 </p>
<p>3.切换目录，使用cd命令。 </p>
<p>4.Tab键自动补全路径。 </p>
<p>5.复制和粘贴操作，通过右键菜单完成。 </p>
<p>6.回到上一级目录，使用cd..命令。 </p>
<p>7.上下键选择之前输入过的命令。 </p>
<p>8.在cmd中运行文件，包括没有扩展名的文件。</p>
<h3 id="2-4-相对路径和绝对路径"><a href="#2-4-相对路径和绝对路径" class="headerlink" title="2.4 相对路径和绝对路径"></a>2.4 相对路径和绝对路径</h3><p>1.绝对路径从盘符开始，如E:\soft\test。 </p>
<p>2.相对路径基于当前目录，如..\c或b。 </p>
<p>3.CD -d命令用于在不同盘符之间切换。</p>
<h3 id="2-5-环境变量的作用"><a href="#2-5-环境变量的作用" class="headerlink" title="2.5 环境变量的作用"></a>2.5 环境变量的作用</h3><p>1.环境变量Path用于指定程序搜索路径。 </p>
<p>2.通过将路径添加到Path变量，程序可以在任意目录下运行。 </p>
<p>3.环境变量的加载在启动时完成，新开的cmd窗口才能识别新的环境变量。</p>
<h2 id="3-jdk的安装"><a href="#3-jdk的安装" class="headerlink" title="3.jdk的安装"></a>3.jdk的安装</h2><h3 id="3-1-jdk的介绍"><a href="#3-1-jdk的介绍" class="headerlink" title="3.1 jdk的介绍"></a>3.1 jdk的介绍</h3><p>1.jdk是JAVA开发工具集，包含JAVA虚拟机和一些基本的类库。 </p>
<p>2.jdk是jre的基础上增加了开发工具，用于JAVA开发。 </p>
<p>3.jdk的版本主要有8和17，其中8和11是长期支持版本。</p>
<h3 id="3-2-jdk的下载和安装"><a href="#3-2-jdk的下载和安装" class="headerlink" title="3.2 jdk的下载和安装"></a>3.2 jdk的下载和安装</h3><p>1.jdk可以从Oracle官网或OpenJDK网站下载。 </p>
<p>2.下载时需要注册账号并登录。 </p>
<p>3.安装时选择合适的操作系统和版本，可以是ese或exe。</p>
<h3 id="3-3-jdk的安装检测"><a href="#3-3-jdk的安装检测" class="headerlink" title="3.3 jdk的安装检测"></a>3.3 jdk的安装检测</h3><p>1.安装完成后，通过cmd输入JAVA或JAVA_HOME来检测安装是否成功。 </p>
<p>2.如果输入JAVA或JAVA_HOME能显示版本信息，则表示环境配置正确。</p>
<h2 id="5-Windows注意事项"><a href="#5-Windows注意事项" class="headerlink" title="5.Windows注意事项"></a>5.Windows注意事项</h2><h3 id="5-1-Windows路径命名规范"><a href="#5-1-Windows路径命名规范" class="headerlink" title="5.1 Windows路径命名规范"></a>5.1 Windows路径命名规范</h3><p>1.Windows系统中路径命名应避免使用中文、空格和特殊符号，以防止出现错误。 </p>
<p>2.计算机名也应避免使用中文，以确保软件的正常运行。 </p>
<p>3.国外软件在Windows系统中对中文路径的兼容性较差。</p>
<h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>1.安装Python时，建议将Python的安装路径和脚本路径添加到系统环境变量中。 </p>
<p>2.通过配置环境变量，可以方便地运行Python解释器和脚本。 </p>
<p>3.在Windows系统中，可以使用path变量来添加Python的安装路径和脚本路径。</p>
<h3 id="5-3-计算机名对软件运行的影响"><a href="#5-3-计算机名对软件运行的影响" class="headerlink" title="5.3 计算机名对软件运行的影响"></a>5.3 计算机名对软件运行的影响</h3><p>1.计算机名使用中文可能导致某些软件无法正常运行，尤其是国外软件。 </p>
<p>2.修改计算机名为英文或数字可以解决某些软件运行问题。 </p>
<p>3.在虚拟机中可以方便地修改计算机名以进行测试。</p>
<h2 id="6-Android-Studio"><a href="#6-Android-Studio" class="headerlink" title="6.Android Studio"></a>6.Android Studio</h2><h3 id="6-1-安装与配置"><a href="#6-1-安装与配置" class="headerlink" title="6.1 安装与配置"></a>6.1 安装与配置</h3><p>1.Android Studio是一个强大的IDE工具，用于安卓开发和逆向工程。 </p>
<p>2.安装过程包括下载安装包和选择安装路径，建议不要将Android Studio安装在系统盘。</p>
<h3 id="6-2-启动与配置"><a href="#6-2-启动与配置" class="headerlink" title="6.2 启动与配置"></a>6.2 启动与配置</h3><p>1.启动Android Studio时选择不导入任何配置文件。 </p>
<p>2.选择自定义设置，并配置SDK的安装路径。 </p>
<p>3.配置模拟器的内存和主题选择。</p>
<h3 id="6-3-SDK的配置与管理"><a href="#6-3-SDK的配置与管理" class="headerlink" title="6.3 SDK的配置与管理"></a>6.3 SDK的配置与管理</h3><p>1.通过SDK Manager配置SDK，包括安装不同版本的SDK和工具。 </p>
<p>2.选择安装安卓10（API 29）和必要的build tools、NDK和CMake。</p>
<p>3.安装Google USB Driver以连接谷歌手机。</p>
<h3 id="6-4-创建安卓项目"><a href="#6-4-创建安卓项目" class="headerlink" title="6.4 创建安卓项目"></a>6.4 创建安卓项目</h3><p>1.选择创建Native C++项目以测试NDK支持。 </p>
<p>2.输入项目名称和包名，选择保存路径和语言（Java或Kotlin）。 </p>
<p>3.选择最小支持的SDK版本和C++标准。</p>
<h3 id="6-5-工程目录结构"><a href="#6-5-工程目录结构" class="headerlink" title="6.5 工程目录结构"></a>6.5 工程目录结构</h3><p>1.项目目录包括工程级别的配置文件和模块级别的代码文件。 </p>
<p>2.模块目录结构包括src、main、java和gradle文件。 </p>
<p>3.gradle文件中配置SDK版本、build tools版本和编译目标API版本。</p>
<h3 id="6-6-SDK目录结构"><a href="#6-6-SDK目录结构" class="headerlink" title="6.6 SDK目录结构"></a>6.6 SDK目录结构</h3><p>1.SDK目录包括build tools、platform tools、USB driver和其他编译和打包工具。 </p>
<p>2.build tools用于编译APP，platform tools用于刷机和操控手机。</p>
<h3 id="6-7-配置文件位置"><a href="#6-7-配置文件位置" class="headerlink" title="6.7 配置文件位置"></a>6.7 配置文件位置</h3><p>1.Android Studio的配置文件包括gradle和android配置文件。 </p>
<p>2.配置文件位于C盘用户目录下，需要手动删除以重置配置。</p>
<h2 id="7-ADB（Android-Debug-Bridge）"><a href="#7-ADB（Android-Debug-Bridge）" class="headerlink" title="7.ADB（Android Debug Bridge）"></a>7.ADB（Android Debug Bridge）</h2><h3 id="7-1-作用与原理"><a href="#7-1-作用与原理" class="headerlink" title="7.1 作用与原理"></a>7.1 作用与原理</h3><p>1.adb可以在电脑端操控手机，主要用于安卓应用安装和调试。 </p>
<p>2.adb的原理是通过电脑端的客户端和服务器与手机端的adbd进程进行交互，发送指令并操控手机。</p>
<p>3.adb客户端和服务器在电脑端，而adbd进程在手机端。</p>
<h3 id="7-2-概念与命令"><a href="#7-2-概念与命令" class="headerlink" title="7.2 概念与命令"></a>7.2 概念与命令</h3><p>1.超级adb具有root权限，不需要通过SEO申请，可以通过修改adbd源码实现。 </p>
<p>2.超级adb可以使用两个命令：adb root和adb remount。 </p>
<p>3.adb root使adb在root权限下运行，adb remount将system分区挂载为可读写。</p>
<h3 id="7-3-超级adb配置与环境变量"><a href="#7-3-超级adb配置与环境变量" class="headerlink" title="7.3 超级adb配置与环境变量"></a>7.3 超级adb配置与环境变量</h3><p>1.adb在SDK的platform tools目录下，使用前需将该目录添加到环境变量中。 </p>
<p>2.通过修改环境变量，可以在任意目录下访问adb命令。 </p>
<p>3.添加环境变量后，需重启计算机使其生效。</p>
<h2 id="8-安卓模拟环境"><a href="#8-安卓模拟环境" class="headerlink" title="8. 安卓模拟环境"></a>8. 安卓模拟环境</h2><h3 id="8-1-安装软件"><a href="#8-1-安装软件" class="headerlink" title="8.1 安装软件"></a>8.1 安装软件</h3><p>1.到官网下载9.0模拟器，并安装<br><a href="https://www.ldmnq.com/">https://www.ldmnq.com/</a></p>
<p>[更新!]适用于几乎所有安卓模拟器(7+)安装magisk的教程-简单无脑向<br><a href="https://www.52pojie.cn/thread-1583586-1-1.html">https://www.52pojie.cn/thread-1583586-1-1.html</a><br>(出处: 吾爱破解论坛)</p>
<p>2.下载配置文件</p>
<p>3.安装面具</p>
<h3 id="8-2-Magisk介绍"><a href="#8-2-Magisk介绍" class="headerlink" title="8.2 Magisk介绍"></a>8.2 Magisk介绍</h3><p>Magisk 是一套用于定制 Android 的开源软件，支持高于 Android 5.0 的设备。</p>
<p>以下是一些功能亮点：</p>
<ul>
<li><strong>MagiskSU</strong>：为应用程序提供 root 访问权限</li>
<li><strong>Magisk 模块</strong>：通过安装模块修改只读分区</li>
<li><strong>MagiskHide</strong>：从根检测 &#x2F; 系统完整性检查中隐藏 Magisk(Shamiko)</li>
<li><strong>MagiskBoot</strong> : 最完整的安卓启动镜像解包和重新打包工具</li>
</ul>
<p>#二、工具介绍</p>
<h2 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1.IDE"></a>1.IDE</h2><p>IDE（集成开发环境）- IDEA</p>
<ul>
<li>IDEA介绍</li>
</ul>
<ol>
<li><p>DEA全程InteliJ IDEA</p>
</li>
<li><p>在业界被公认为最好的Java开发工具</p>
</li>
<li><p>IDEA是JetBrains公司的产品，总部位于捷克的首部布拉格</p>
</li>
<li><p>除了支持Java开发，还支持HTML、CSS、PHP、MySQL、Python等</p>
</li>
</ol>
<p>IDE（集成开发环境）- Eclipse</p>
<ul>
<li>Eclipse介绍</li>
</ul>
<ol>
<li>Eclipse是开放源代码的、基于JAva的可拓展开发平台</li>
<li>最初是由IBM公司耗资3000万美金开发的下一代IDE开发环境</li>
<li>2001年11月贡献给开源社区</li>
<li>Eclipse是目前最优秀的Java开发IDE之一</li>
</ol>
<h2 id="2-jadx"><a href="#2-jadx" class="headerlink" title="2. jadx"></a>2. jadx</h2><p>下载地址：<a href="https://github.com/skylot/jadx/releases/tag/v1.3.2">Release 1.3.2 · skylot&#x2F;jadx</a></p>
<p>1.jadx是一个常用的反编译工具，更新到1.3版本，功能强大。 </p>
<p>2.jadx安装在GitHub上，提供源代码和编译好的版本。 3.安装简单，不需要安装jadx本身，只需安装7-Zip用于解压。</p>
<p> 4.安装完成后，通过修改注册表并勾选选项，自动识别jadx。 </p>
<p>5.jadx界面默认中文版，可用于反编译APP，生成字面文件和代码。</p>
<p> 6.新版本jadx可以直接导出源代码，支持中文显示内存使用栏。</p>
<p>7.通过bat文件可以修改内存使用量，默认4GB，可改为8GB。 </p>
<p>8.jadx支持搜索类名和源代码，具有调试功能，需配置ADB。 </p>
<p>9.反混淆功能建议关闭，以免更改类名导致问题。</p>
<h2 id="3-gda"><a href="#3-gda" class="headerlink" title="3.gda"></a>3.gda</h2><p>下载地址：<a href="http://www.gda.wiki:9090/">http://www.gda.wiki:9090/</a></p>
<p>使用free版本</p>
<h2 id="4-jeb"><a href="#4-jeb" class="headerlink" title="4. jeb"></a>4. jeb</h2><p><strong>JAD与JEB的比较</strong></p>
<p>1.JAD可能反编译出的代码绿色注释部分不完整，反编译能力较弱。 </p>
<p>2.JEB反编译能力更强，适用于JAD反编译失败的APP。 </p>
<p>3.在JAD或JEB无法反编译的情况下，可以尝试使用定制ART虚拟机直接输出运行过程中的SMILE代码和寄存器参数进行分析。</p>
<p><strong>JEB的安装与使用</strong></p>
<p>1.下载JEB 4.2版本，解压后将jab.exe替换到bin目录下。 </p>
<p>2.双击jab.exe打开软件，接受协议并生成key。 </p>
<p>3.确保替换掉原jb.exe文件后，生成的东西才有用。 </p>
<p>4.软件界面延迟到2033年，可以通过拖入文件进行反编译。 </p>
<p>5.在Edit菜单下选择Language，可以切换到中文界面。 </p>
<p>6.反编译出的JAVA代码可以在Smart Code区域查看，搜索和跳转功能也十分便捷。 </p>
<p>7.JEB需要使用到JDK，并且JDK的大小目前最大为4GB，可以通过配置文件进行修改。</p>
<h2 id="5-apktool"><a href="#5-apktool" class="headerlink" title="5. apktool"></a>5. apktool</h2><p>官方地址<a href="https://maximoff.su/**apktool**/?history=1&lang=zh">https://maximoff.su/**apktool**/?history=1&amp;lang=zh</a></p>
<h2 id="6-frida"><a href="#6-frida" class="headerlink" title="6.frida"></a>6.frida</h2><ul>
<li>frida-server 安装（Android）: <a href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>frida-tools 安装：<a href="https://frida.re/docs/installation/">https://frida.re/docs/installation/</a></li>
<li>frida 官方网站: <a href="https://frida.re/">https://frida.re/</a></li>
<li>frida 官方文档：<a href="https://frida.re/docs/">https://frida.re/docs/</a></li>
</ul>
<p>本次安装涉及Frida 的两个组件，一个是安装到手机或模拟器中的: <code>frida-server</code>，另外就是装在电脑上用于逆向分析的：<code>frida-tools</code>。</p>
<h4 id="frida-server-安装"><a href="#frida-server-安装" class="headerlink" title="frida-server 安装"></a><code>frida-server</code> 安装</h4><p>安装方法参考：<a href="https://blog.csdn.net/weixin_45320254/article/details/126215490">最新2023：Frida完美安装方案_frida-server下载-CSDN博客</a></p>
<p>关键步骤：</p>
<p>将解压之后的文件push到设备中，指定到 &#x2F;data&#x2F;local&#x2F;tmp 路径下重命名为 frida-server。</p>
<p>终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\&gt; adb push C:\Users\xxx\Desktop\frida-server-15.2.2-android-x86_64 /data/local/tmp/frida-server</span><br><span class="line">C:\Users\xxx\Desktop\frida-server-15.2.2-android-x86...le pushed, 0 skipped. 19.4 MB/s (99542760 bytes in 4.882s)    </span><br></pre></td></tr></table></figure>

<p>命令行运行android设备中的frida-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\&gt; adb shell   // 进入手机</span><br><span class="line">VOG-AL00:/ # su    // 确定手机是root权限</span><br><span class="line">VOG-AL00:/ # cd /data/local/tmp      // 进入到tmp目录下</span><br><span class="line">VOG-AL00:/data/local/tmp # chmod 777 frida-server      // 给执行权限，可读可写可执行</span><br><span class="line">VOG-AL00:/data/local/tmp # ./frida-server      //正式启动frida-server</span><br></pre></td></tr></table></figure>

<p><code>提示：执行完毕后为运行状态。这个shell不能关闭，关闭了frida就停止了。</code></p>
<p>应用参考：<a href="https://blog.csdn.net/qq_38474570/article/details/120876120">Android之Frida框架完全使用指南_android frida-CSDN博客</a></p>
<h4 id="安装-FRIDA-DEXDump"><a href="#安装-FRIDA-DEXDump" class="headerlink" title="安装 FRIDA-DEXDump"></a><strong>安装 FRIDA-DEXDump</strong></h4><p>从 GitHub 仓库克隆项目并安装：</p>
<p>手动下载<a href="https://github.com/hluwa/frida-dexdump">frida-dexdump</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hluwa/FRIDA-DEXDump.git</span><br><span class="line"><span class="built_in">cd</span> FRIDA-DEXDump</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1945680&highlight=Frida">Frida 安装 - 吾爱破解 </a></p>
<p>逆向过程中，借助<strong>Frida</strong> 可以更快的实现软件的逆向破解，Frida不仅可以实现Android应用的逆向，对于IOS应用，Windows应用同样可以实现不错的效果本文可能由于frida 代码的不断更新，可能出现某些错误或者过时，大家尽量以官方文档为主：</p>
<ul>
<li>frida-server 安装（Android）: <a href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>frida-tools 安装：<a href="https://frida.re/docs/installation/">https://frida.re/docs/installation/</a></li>
<li>frida 官方网站: <a href="https://frida.re/">https://frida.re/</a></li>
<li>frida 官方文档：<a href="https://frida.re/docs/">https://frida.re/docs/</a></li>
</ul>
<p>本次安装涉及Frida 的两个组件，一个是安装到手机或模拟器中的: <code>frida-server</code>，另外就是装在电脑上用于逆向分析的：<code>frida-tools</code>。</p>
<h4 id="frida-server-安装-1"><a href="#frida-server-安装-1" class="headerlink" title="frida-server 安装"></a><code>frida-server</code> 安装</h4><p>frida-server 本质上是一个二进制文件，将其拷贝到需要进行hook的系统中运行即可，下面以Android系统为例：</p>
<p>首先需要从 <strong>github</strong> 的仓库中下载编译好的 frida-server 文件。仓库地址：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>从Release中下载对应版本的文件即可。frida-server的命名规则为：<code>frida-server-&#123;版本号&#125;-&#123;支持的系统&#125;-&#123;CPU架构&#125;.&#123;压缩文件扩展名&#125;</code></p>
<p>认准自己手机或模拟器的架构下载即可。例如我是 arm64 的 Android 手机，那么我就下载 <code>frida-server-16.4.5-android-arm64.xz</code> 即可</p>
<p>下载到合适的frida-server后，使用<code>adb push</code>命令将二进制文件推送到目标设备中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>如果推送不成功，也可以先推送到 <code>/sdcard/</code> 目录后，再使用 <code>adb shell</code>将 frida-server 复制到 <code>/data/local/tmp/</code> 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">mv /sdcard/frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure>

<p>推送完成后，使用：<code>adb shell</code>命令进入shell，并赋予 <code>frida-server</code> 可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure>

<p>上述工作都做完后，可以启动 <code>frida-server</code>了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell后，使用 su 命令切换到 root 用户</span></span><br><span class="line">su</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果手机/模拟器提示需要授权，请在手机上点击授权即可，请留意手机</span></span><br><span class="line">cd /data/local/tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予 frida-server 可执行权限</span></span><br><span class="line">./frida-server</span><br></pre></td></tr></table></figure>

<p><code>frida-server</code>启动后不会有任何屏幕的提示信息。请注意这个命令行窗口不要关闭，如果命令窗口关闭后，<code>frida-server</code> 也会关闭</p>
<h4 id="frida-tools-安装"><a href="#frida-tools-安装" class="headerlink" title="frida-tools 安装"></a><code>frida-tools</code> 安装</h4><p>需要注意的是，上文提到的 frida-server 需与 frida 版本保持一致，安装 <code>frida-tools</code> 时又会自动安装 <code>frida</code> 。那么如何得知 <code>frida-tools</code> 版本呢？</p>
<p>首先打开 frida 仓库：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a>, 在 Release 中寻找 frida 版本并查找到 frida 的发布日期</p>
<p>获取到 frida 发布日期后，打开 frida-tools 仓库：<a href="https://github.com/frida/frida-tools">https://github.com/frida/frida-tools</a> 寻找上述 frida 发布日期的相同或之后的一个 frida-tools 版本，请记住这个版本号！</p>
<p>以 Windows 系统为例，电脑中需要存在Python环境：</p>
<p>使用以下命令安装 <code>frida-tools</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">pip3 install frida-tools==&#123;frida-tools版本号&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>安装 <code>frida-tools</code> 时会自动安装 <code>frida</code> 所以不要像网上某些教程教的一样分别安装, 不然有可能会出现安装失败或安装后运行时报错等问题！</p>
</blockquote>
<p>如果安装时出现网络连接问题，或者一些与网络相关的错误，请多试几遍，也可使用以下方法：</p>
<ul>
<li>使用 <code>-i</code> 参数指定软件源：<code>pip3 install frida-tools==&#123;frida-tools版本号&#125; -i https://pypi.tuna.tsinghua.edu.cn/simple</code></li>
<li>使用 <code>--proxy</code> 参数: <code>pip3 install frida-tools==&#123;frida-tools版本号&#125; --proxy=&#39;socks5://127.0.0.1:7890&#39;</code></li>
</ul>
<p>安装完成后，使用命令<code>frida-ps</code> 命令验证是否安装成功：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  ----------------------------</span></span><br><span class="line"><span class="function">  832  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">27076  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">30132  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">22788  <span class="title">chrome.exe</span></span></span><br><span class="line"><span class="function">21040  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">30480  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function"> 1872  <span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function">13060  <span class="title">conhost.exe</span></span></span><br><span class="line"><span class="function"> 1880  <span class="title">dllhost.exe</span></span></span><br><span class="line"><span class="function"> 8544  <span class="title">explorer.exe</span></span></span><br><span class="line"><span class="function">13700  <span class="title">frida</span>-<span class="title">ps.exe</span></span></span><br><span class="line"><span class="function">15032  <span class="title">nvcontainer.exe</span></span></span><br><span class="line"><span class="function">26740  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">27464  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function">26948  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 2076  <span class="title">rundll32.exe</span></span></span><br><span class="line"><span class="function"> 9824  <span class="title">sihost.exe</span></span></span><br><span class="line"><span class="function"> 9860  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9868  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function"> 9928  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">11208  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">20020  <span class="title">svchost.exe</span></span></span><br><span class="line"><span class="function">10020  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">10084  <span class="title">taskhostw.exe</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<p>执行命令后出现的就是当前机器的进程列表，证明 <code>frida-tools</code> 单独运行是没问题的。那么如何测试是否能正确的与运行在手机或模拟器中的<code>frida-server</code>通信呢？</p>
<p>将手机与电脑连接后，按照上文说的启动 <code>frida-server</code> ，在命令行中使用 <code>frida-ps -U</code>命令查看手机进程：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">LemonGo97</span>&gt; <span class="title">frida</span>-<span class="title">ps</span> -<span class="title">U</span></span></span><br><span class="line"><span class="function">  <span class="title">PID</span>  <span class="title">Name</span></span></span><br><span class="line"><span class="function">-----  --------------------------------------------</span></span><br><span class="line"><span class="function">  683  <span class="title">ATFWD</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">24558  <span class="title">adbd</span></span></span><br><span class="line"><span class="function">  672  <span class="title">adsprpcd</span></span></span><br><span class="line"><span class="function">  686  <span class="title">alipayservice</span></span></span><br><span class="line"><span class="function">11860  <span class="title">android.process.acore</span></span></span><br><span class="line"><span class="function">22740  <span class="title">android.process.contacts</span></span></span><br><span class="line"><span class="function">11653  <span class="title">android.process.media</span></span></span><br><span class="line"><span class="function">  690  <span class="title">audiod</span></span></span><br><span class="line"><span class="function">  664  <span class="title">bspCriticalLog</span></span></span><br><span class="line"><span class="function">  662  <span class="title">cnd</span></span></span><br><span class="line"><span class="function">  680  <span class="title">cnss</span>-<span class="title">daemon</span></span></span><br><span class="line"><span class="function">12137  <span class="title">com.amap.android.location</span></span></span><br><span class="line"><span class="function">12262  <span class="title">com.android.incallui</span></span></span><br><span class="line"><span class="function">24490  <span class="title">com.android.keyguard</span></span></span><br><span class="line"><span class="function">22711  <span class="title">com.android.mms</span></span></span><br><span class="line"><span class="function">12125  <span class="title">com.android.phone</span></span></span><br><span class="line"><span class="function">14538  <span class="title">com.android.providers.downloads</span></span></span><br></pre></td></tr></table></figure>

<p>如果执行结果如上所示，那么基本上 frida 安装已经成功了，如果出现错误，请仔细检查以上的所有步骤是否正确。</p>
<h2 id="7-BinaryNinja"><a href="#7-BinaryNinja" class="headerlink" title="7.BinaryNinja"></a>7.BinaryNinja</h2><h2 id="8-010-Editor"><a href="#8-010-Editor" class="headerlink" title="8.010 Editor"></a>8.010 Editor</h2><p>16进制文件编辑工具，以16进制方式打开文件。</p>
<p><strong>总的（包含linux和windows以及破解软件）：</strong><br>链接：<a href="https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu">https://pan.baidu.com/s/1HoJfYRzuYD57BgjRmtVW-g?pwd=1ynu</a><br>提取码：1ynu</p>
<p>参考：<a href="https://blog.csdn.net/NS_ice/article/details/132398846">010editor的安装与基本操作-CSDN博客</a></p>
<h2 id="9-Ghidra"><a href="#9-Ghidra" class="headerlink" title="9.Ghidra"></a>9.Ghidra</h2><p>参考：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=2020073&highlight=Ghidra">逆向分析工具GhidraMCP 吾爱破解</a></p>
<pre><code>   [《Ghidra简介及使用方法》学习 - 吾爱破解](https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1793425&amp;highlight=Ghidra)
</code></pre>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a><strong>下载地址</strong>：</h3><p>从 GitHub Releases 下载对应系统的压缩包（如 <code>ghidra_11.0_PUBLIC_YYYYMMDD.zip</code>）。</p>
<p><strong>解压文件</strong>：</p>
<ul>
<li><p><strong>Windows</strong>：使用 WinRAR、7-Zip 或系统自带解压工具。</p>
</li>
<li><p><strong>Linux&#x2F;macOS</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip ghidra_11.0_PUBLIC_*.zip -d ~/ghidra</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a><strong>安装依赖</strong></h3><h4 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a><strong>Java 环境</strong></h4><p>Ghidra 需要 **Java 11+**（推荐 OpenJDK 11）：</p>
<ul>
<li><p><strong>Windows&#x2F;macOS</strong>：</p>
<ul>
<li>下载并安装 <a href="https://adoptium.net/">Adoptium Temurin JDK 11</a>。</li>
</ul>
</li>
<li><p><strong>Linux</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk  # Ubuntu/Debian</span><br><span class="line">sudo dnf install java-11-openjdk # Fedora</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="验证-Java-版本"><a href="#验证-Java-版本" class="headerlink" title="验证 Java 版本"></a><strong>验证 Java 版本</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version  # 输出应包含 &quot;openjdk 11.0.x&quot;</span><br></pre></td></tr></table></figure>

<h3 id="启动-Ghidra"><a href="#启动-Ghidra" class="headerlink" title="启动 Ghidra"></a><strong>启动 Ghidra</strong></h3><p><strong>Windows</strong></p>
<ol>
<li>进入解压后的目录 <code>ghidra_11.0/</code>。</li>
<li>双击运行 **<code>ghidraRun.bat</code>**（可能需要管理员权限）</li>
</ol>
<h4 id="Linux-macOS"><a href="#Linux-macOS" class="headerlink" title="Linux&#x2F;macOS"></a><strong>Linux&#x2F;macOS</strong></h4><ol>
<li><p>打开终端，进入解压目录：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/ghidra/ghidra_11.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋予执行权限并启动：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ghidraRun</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="首次配置"><a href="#首次配置" class="headerlink" title="首次配置"></a><strong>首次配置</strong></h3><ol>
<li><strong>选择工作目录</strong>：<ul>
<li>首次启动时，Ghidra 会提示设置项目目录（默认 <code>~/ghidra_projects</code>）。</li>
</ul>
</li>
<li><strong>接受许可协议</strong>：<ul>
<li>阅读并同意 Ghidra 的许可条款。</li>
</ul>
</li>
</ol>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h3><p><strong>（1）创建项目</strong></p>
<ol>
<li>点击 **<code>File &gt; New Project</code>**。</li>
<li>选择 **”Non-Shared Project”**（个人项目），输入项目名称（如 <code>MyFirstProject</code>）。</li>
</ol>
<p><strong>（2）导入文件</strong></p>
<ol>
<li>在项目窗口中，右键点击项目名 → **<code>Import File</code>**。</li>
<li>选择要分析的二进制文件（如 <code>.exe</code>、<code>.elf</code>、<code>.dll</code>）。</li>
<li>保持默认选项，点击 **”Import”**。</li>
</ol>
<p><strong>（3）分析代码</strong></p>
<ol>
<li>双击导入的文件，Ghidra 会提示是否分析 → 点击 **”Yes”**。</li>
<li>选择分析选项（默认勾选所有），点击 **”Analyze”**：<ul>
<li><strong>反编译</strong>：查看伪代码（按 <code>F</code> 聚焦到函数）。</li>
<li><strong>字符串搜索</strong>：在 <code>Defined Strings</code> 列表查找线索（如 <code>flag&#123;</code>）。</li>
<li><strong>交叉引用（XRefs）</strong>：右键点击函数或变量 → **”References”**。</li>
</ul>
</li>
</ol>
<p><strong>（4）常用快捷键</strong></p>
<ul>
<li><code>F</code>：聚焦到当前函数。</li>
<li><code>G</code>：跳转到地址。</li>
<li><code>Ctrl + F</code>：在当前视图搜索文本。</li>
<li><code>;</code>：添加注释。</li>
</ul>
<hr>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a><strong>高级功能</strong></h3><p><strong>（1）脚本与插件</strong></p>
<ul>
<li><strong>脚本</strong>：在 <code>Window &gt; Script Manager</code> 中运行 Python 脚本（如自动解密算法）。</li>
<li><strong>插件</strong>：将插件放入 <code>ghidra_11.0/Ghidra/Extensions</code> 目录并重启。</li>
</ul>
<p><strong>（2）版本控制</strong></p>
<ul>
<li>支持通过 Git 管理项目（需手动配置）。</li>
</ul>
<p><strong>（3）反编译优化</strong></p>
<ul>
<li>在反编译窗口右键 → <strong>“Rename Variable”</strong> 或 <strong>“Retype Variable”</strong> 提高可读性。</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><p><strong>（1）启动报错 “No suitable Java version found”</strong></p>
<ul>
<li><strong>原因</strong>：未安装 Java 11 或环境变量配置错误。</li>
<li><strong>解决</strong>：<ul>
<li>检查 <code>java -version</code> 是否为 JDK 11。</li>
<li>手动指定 Java 路径（编辑 <code>ghidraRun</code> 脚本）。</li>
</ul>
</li>
</ul>
<p><strong>（2）分析卡死</strong></p>
<ul>
<li><strong>原因</strong>：大文件分析内存不足。</li>
<li><strong>解决</strong>：<ul>
<li>修改 <code>ghidraRun</code> 中的内存参数（如 <code>MAXMEM=4096M</code>）。</li>
</ul>
</li>
</ul>
<p><strong>（3）中文乱码</strong></p>
<ul>
<li><strong>解决</strong>：<ul>
<li>在反汇编视图右键 → <strong>“Options &gt; Listing Fields”</strong> → 修改字体为支持中文的字体（如宋体）。</li>
</ul>
</li>
</ul>
<h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a><strong>学习资源</strong></h3><ul>
<li><strong>官方文档</strong>：<br>  <a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a></li>
<li><strong>入门教程</strong>：<br>  <a href="https://ghidra.re/ghidra_docs/Introductory_Tutorial.html">Ghidra 官方入门指南</a></li>
<li><strong>社区支持</strong>：<br>  <a href="https://github.com/NationalSecurityAgency/ghidra/discussions">Ghidra 官方论坛</a></li>
</ul>
<h2 id="10-HxD-Hex"><a href="#10-HxD-Hex" class="headerlink" title="10.HxD_Hex"></a>10.HxD_Hex</h2><p>HxD Hex Editor 是一款功能强大的十六进制编辑器和磁盘编辑器，它可以让你直接查看和编辑二进制文件的内容。你可以使用HxD Hex Editor来分析、修改和处理各种数据格式，包括程序文件、磁盘映像、内存转储以及其他二进制文件。</p>
<p>下载地址：<a href="https://mh-nexus.de/en/hxd">HxD | https://mh-nexus.de/en/hxd</a></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><ol>
<li><p>以十六进制表示方式显示文件内容，并允许直接编辑其中的字节</p>
</li>
<li><p>支持将数据按特定数据类型进行解析和显示，方便对结构化数据进行编辑和分析。</p>
<p> 视图  &gt;&gt;  位置显示数制、数据显示、字节分组大小</p>
</li>
<li><p>可用于比较两个文件的差异，以找出变更或修改的部分。</p>
<p> 将两个图像的数据进行对比</p>
</li>
<li><p>可以执行文本或二进制数据的搜索和替换操作，帮助定位和修改特定的数据。</p>
<p> 搜索  &gt;&gt;  搜索（Ctrl+F）……</p>
</li>
<li><p>支持将数据导入到文件中或将文件导出为不同的数据格式</p>
<p> 文件 &gt;&gt;  导出  &gt;&gt;  ……</p>
</li>
<li><p>能够处理非常大的文件，并且在编辑和浏览时保持快速响应。</p>
</li>
</ol>
<p>了解更多详情：<a href="https://mh-nexus.de/en/hxd/">https://mh-nexus.de/en/hxd/</a></p>
<p>用途<br>HxD Hex Editor通常用于以下几个方面：</p>
<p>1）帮助软件开发人员进行反汇编、调试和逆向工程。查看和修改程序的二进制代码，以理解其内部结构、修复漏洞或进行功能定制。</p>
<p>2）对于受损的文件或存储介质，HxD Hex Editor可以帮助您直接浏览并修复数据错误。查看和编辑二进制数据来识别并修复文件中的损坏部分，如磁盘映像、内存转储等。</p>
<p>3）HxD Hex Editor提供了强大的数据分析和处理功能，一些游戏会使用二进制文件格式来存储游戏数据。</p>
<h2 id="11-upx"><a href="#11-upx" class="headerlink" title="11.upx"></a>11.upx</h2><h2 id="12-XVolkolak"><a href="#12-XVolkolak" class="headerlink" title="12.XVolkolak"></a>12.XVolkolak</h2><h2 id="13-radare2"><a href="#13-radare2" class="headerlink" title="13.radare2"></a>13.radare2</h2><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><p>安装radare2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y gcc make cmake curl git  gcc-multilib</span><br><span class="line">git clone https://github.com/radare/radare2.git</span><br><span class="line">cd radare2</span><br><span class="line">./sys/install.sh</span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line"></span><br><span class="line">make uninstall</span><br><span class="line">make purge</span><br></pre></td></tr></table></figure>

<h3 id="window环境"><a href="#window环境" class="headerlink" title="window环境"></a>window环境</h3><p>参考：</p>
<p><a href="https://bbs.kanxue.com/thread-225529.htm">在Windows平台下的使用radare2进行调试-外文翻译-看雪</a></p>
<p>在Windows上安装Radare2并配置r2pipe库的步骤如下：</p>
<h3 id="下载正确的文件"><a href="#下载正确的文件" class="headerlink" title="下载正确的文件"></a><strong>下载正确的文件</strong></h3><p>访问 <a href="https://github.com/radareorg/radare2/releases/tag/5.9.8">Radare2 5.9.8 发布页面</a>，在 <strong>Assets</strong> 部分找到以下文件：</p>
<ul>
<li><strong><code>radare2-5.9.8-w64.zip</code></strong><ul>
<li>这是 <strong>64 位 Windows 系统</strong>的预编译版本，适用于天选2笔记本（现代笔记本通常为 64 位系统）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><strong>安装步骤</strong></h3><ol>
<li><p><strong>下载文件</strong>：点击 <code>radare2-5.9.8-w64.zip</code> 下载压缩包。</p>
</li>
<li><p><strong>解压文件</strong>：将压缩包解压到任意目录（例如 <code>C:\radare2</code>）。</p>
</li>
<li><p><strong>配置环境变量</strong>：</p>
<ul>
<li>将 Radare2 的 <code>bin</code> 目录（如 <code>C:\radare2\bin</code>）添加到系统 <code>PATH</code> 环境变量。</li>
<li><strong>步骤</strong>：<ol>
<li>右键点击“此电脑” → 属性 → 高级系统设置 → 环境变量 → 编辑系统变量 <code>Path</code> → 添加 <code>C:\radare2\bin</code>。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>验证安装</strong>：</p>
<ul>
<li><p>打开命令提示符（CMD 或 PowerShell），输入：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r2 -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出应显示版本信息：<code>radare2 5.9.8 ...</code>。</p>
</li>
</ul>
</li>
<li><p>打开命令提示符（CMD）或PowerShell，并导航至Radare2所在目录。使用以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\radare2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该目录下执行以下命令来运行Radare2：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r2.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p>这将启动Radare2交互式环境。</p>
<p> 验证Radare2是否正确安装。在Radare2交互式环境中，输入<code>?</code>或<code>help</code>命令查看帮助文档。</p>
<p> 接下来，您可以通过pip来安装r2pipe库。请确保您已经安装了Python和pip。</p>
<p> 打开命令提示符或PowerShell，并运行以下命令来安装r2pipe库：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install r2pipe</span><br></pre></td></tr></table></figure>

<p> 安装完成后，您可以在Python脚本中导入并使用r2pipe库与已安装的Radare2进行交互了。</p>
</li>
</ol>
<p>以上是在Windows上安装和配置Radare 2及r2pipe库的基本步骤。根据系统和安装方式，可能会有细微差异，请参考官方文档或社区支持寻求更详细的帮助。</p>
<p>安装程序都将radare2.exe以及其他工具放在C：&#x2F;users &#x2F;username &#96;&#96;&#x2F; AppData目录中。 我必须从命令行将目录切换到该文件夹才能使用可执行文件。 为了从命令行的任何位置访问该文件，必须将该目录添加到$ PATH环境变量中。 这计算机用来查找可以从系统的任何位置运行的命令和应用程序的变量。<br>要设置你的$ PATH变量，你可以通过以下两种方法之一来完成。 您可以通过转到系统属性 -&gt;高级 -&gt;环境变量来使用Windows GUI进行更改，单击路径变量并单击编辑。 然后你可以添加你的radare2文件的目录。</p>
<h3 id="命令行使用方法"><a href="#命令行使用方法" class="headerlink" title="命令行使用方法"></a>命令行使用方法</h3><p>Radare2 在命令行下有一些小工具可供使用：</p>
<ul>
<li>radare2：十六进制编辑器和调试器的核心，通常通过它进入交互式界面。</li>
<li>rabin2：从可执行二进制文件中提取信息。</li>
<li>rasm2：汇编和反汇编。</li>
<li>rahash2：基于块的哈希工具。</li>
<li>radiff2：二进制文件或代码差异比对。</li>
<li>rafind2：查找字节模式。</li>
<li>ragg2：r_egg 的前端，将高级语言编写的简单程序编译成x86、x86-64和ARM的二进制文件。</li>
<li>rarun2：用于在不同环境中运行程序。</li>
<li>rax2：数据格式转换。</li>
</ul>
<h4 id="radare2-r2"><a href="#radare2-r2" class="headerlink" title="radare2&#x2F;r2"></a>radare2&#x2F;r2</h4><p>参数很多，这里最重要是 <code>file</code>。如果想 attach 到一个进程上，则使用 <code>pid</code>。常用参数如下：</p>
<ul>
<li><code>-A</code>：相当于在交互界面输入了 <code>aaa</code>。</li>
<li><code>-c</code>：运行 radare 命令。（<code>r2 -A -q -c &#39;iI~pic&#39; file</code>）</li>
<li><code>-d</code>：调试二进制文件或进程。</li>
<li><code>-a</code>,<code>-b</code>,<code>-o</code>：分别指定体系结构、位数和操作系统，通常是自动的，但也可以手动指定。</li>
<li><code>-w</code>：使用可写模式打开。</li>
</ul>
<h4 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h4><p>拿到一个二进制文件时，第一步就是获取关于它的基本信息，这时候就可以使用 rabin2。rabin2 可以获取包括 ELF、PE、Mach-O、Java CLASS 文件的区段、头信息、导入导出表、数据段字符串、入口点等信息，并且支持多种格式的输出。</p>
<p>下面介绍一些常见的用法：</p>
<ul>
<li><code>-I</code>：最常用的参数，它可以打印出二进制文件信息，其中我们需要重点关注其使用的安全防护技术，如 canary、pic、nx 等。（<code>file</code>、<code>chekcsec -f</code>）</li>
<li><code>-e</code>：得到二进制文件的入口点。（｀readelf -h&#96;）</li>
<li><code>-i</code>：获得导入符号表，RLT中的偏移等。（<code>readelf -r</code>）</li>
<li><code>-E</code>：获得全局导出符号表。</li>
<li><code>-s</code>：获得符号表。（<code>readelf -s</code>）</li>
<li><code>-l</code>：获得二进制文件使用到的动态链接库。（<code>ldd</code>）</li>
<li><code>-z</code>：从 ELF 文件的 .rodare 段或 PE 文件的 .text 中获得字符串。（<code>strings -d</code>）</li>
<li><code>-S</code>：获得完整的段信息。（<code>readelf -S</code>）</li>
<li><code>-c</code>：列出所有类，在分析 Java 程序是很有用。</li>
</ul>
<p>最后还要提到的一个参数 <code>-r</code>，它可以将得到的信息以 radare2 可读的形式输出，在后续的分析中可以将这样格式的信息输入 radare2，这是非常有用的。</p>
<h4 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h4><p>rasm2 是一个内联汇编、反汇编程序。它的主要功能是获取给定机器指令操作码对应的字节。</p>
<p>下面是一些重要的参数：</p>
<ul>
<li><code>-L</code>：列出目标体系结构所支持的插件，输出中的第一列说明了插件提供的功能（a&#x3D;asm, d&#x3D;disasm, A&#x3D;analyze, e&#x3D;ESIL）。</li>
<li><code>-a</code>：知道插件的名字后，就可以使用 -a&#96; 来进行设置。</li>
<li><code>-b</code>：设置CPU寄存器的位数。</li>
<li><code>-d</code>：反汇编十六进制对字符串。</li>
<li><code>-D</code>：反汇编并显示十六进制对和操作码。</li>
<li><code>-C</code>：汇编后以 C 语言风格输出。</li>
<li><code>-f</code>：从文件中读入汇编代码。</li>
</ul>
<h4 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h4><p>rahash2 用于计算检验和，支持字节流、文件、字符串等形式和多种算法。</p>
<p>重要参数：</p>
<ul>
<li><code>-a</code>：指定算法。默认为 sha256，如果指定为 all，则使用所有算法。</li>
<li><code>-b</code>：指定块的大小（而不是整个文件）</li>
<li><code>-B</code>：打印处每个块的哈希</li>
<li><code>-s</code>：指定字符串（而不是文件）</li>
<li><code>-a entropy</code>：显示每个块的熵（<code>-B -b 512 -a entropy</code>）</li>
</ul>
<h4 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h4><p>radiff2 是一个基于偏移的比较工具。</p>
<p>重要参数：</p>
<ul>
<li><p><code>-s</code>：计算文本距离并得到相似度。</p>
</li>
<li><p><code>－AC</code>：这两个参数通常一起使用，从函数的角度进行比较。</p>
</li>
<li><pre><code>  -g
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	：得到给定的符号或两个偏移的图像对比。</span><br><span class="line"></span><br><span class="line">	- 如：`radiff2 -g main a.out b.out | xdot -`（需要安装xdot）</span><br><span class="line"></span><br><span class="line">- `-c`：计算不同点的数量。</span><br><span class="line"></span><br><span class="line">#### rafind2</span><br><span class="line"></span><br><span class="line">rafind2 用于在二进制文件中查找字符模式。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-s`：查找特定字符串。</span><br><span class="line">- `-e`：使用正则匹配。</span><br><span class="line">- `-z`：搜索以`\0`结束的字符串。</span><br><span class="line">- `-x`：查找十六进制字符串。</span><br><span class="line"></span><br><span class="line">#### ragg2</span><br><span class="line"></span><br><span class="line">ragg2 可以将高级语言编写的简单程序编译成 x86、x86-64 或 ARM 的二进制文件。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-a`：设置体系结构。</span><br><span class="line">- `-b`：设置体系结构位数(32/64)。</span><br><span class="line">- `-P`：生成某种模式的字符串，常用于输入到某程序中并寻找溢出点。</span><br><span class="line">- -r：使用原始字符而不是十六进制对。</span><br><span class="line">	- ragg2 -P 50 -r`</span><br><span class="line">- -i：生成指定的 shellcode。查看-L。</span><br><span class="line">	- `ragg2 -a x86 -b 32 -i exec`</span><br><span class="line">- `-e`：使用指定的编码器。查看 `-L`。</span><br><span class="line"></span><br><span class="line">#### rarun2</span><br><span class="line"></span><br><span class="line">rarun2 是一个可以使用不同环境、参数、标准输入、权限和文件描述符的启动器。</span><br><span class="line"></span><br><span class="line">常用的参数设置：</span><br><span class="line"></span><br><span class="line">- `program`</span><br><span class="line">- `arg1`, `arg2`,…</span><br><span class="line">- `setenv`</span><br><span class="line">- `stdin`, `stdout`</span><br><span class="line"></span><br><span class="line">#### rax2</span><br><span class="line"></span><br><span class="line">rax2 是一个格式转换工具，在二进制、八进制、十六进制数字和字符串之间进行转换。</span><br><span class="line"></span><br><span class="line">重要参数：</span><br><span class="line"></span><br><span class="line">- `-e`：交换字节顺序</span><br><span class="line">- `-s`：十六进制-&gt;字符</span><br><span class="line">- `-S`：字符-&gt;十六进制</span><br><span class="line">- `-D`, `-E`：base64 解码和编码</span><br><span class="line"></span><br><span class="line">## 14.Strings</span><br><span class="line"></span><br><span class="line">## ZipRepair</span><br><span class="line"></span><br><span class="line">## x64dbg</span><br><span class="line"></span><br><span class="line">x64dbg 是一款开源的、目前仍在积极开发中的 x32/x64 位动态调试器。其界面及操作方法与 [OllyDbg](https://www.52pojie.cn/thread-350397-1-1.html) 类似，和 OllyDbg 不同的是它可以对 64 位程序进行调试。此外，其开放式的设计给了此软件很强的生命力。通过爱好者们不断的修改和扩充，使其功能越来越强大。</span><br><span class="line">该调试器(目前)有三部分：DBG、GUI、Bridge：</span><br><span class="line">DBG 是调试器的调试部分。它处理调试技术(使用 TitanEngine 引擎，近来还新增了 Gleebug 引擎)，并为 GUI 提供数据。</span><br><span class="line">GUI 是调试器的图形部分。它建立在 Qt 上，并提供用户交互界面。</span><br><span class="line">Bridge 是 DBG 和 GUI 部分的通信库(将来也许是在更多的部件之间)。Bridge 可用于在新建功能上工作，而无需更新代码的其他部分。</span><br><span class="line"></span><br><span class="line">**汉化修订说明：**</span><br><span class="line"></span><br><span class="line">1. 对 x64dbg 帮助文档的主要内容进行了汉化，并按照最新版进行了修订、补译。对界面字体以及布局重新进行了设置。将默认调用在线英文帮助更改为调用本地中文帮助文件。</span><br><span class="line">2. 为帮助用户更好地了解 x64dbg 反汇编后的 CPU 汇编指令信息，对汇编指令的“助记符摘要”全部进行了汉化。对“助记符帮助”进行了部分汉化。汇编指令的汉化参考了“清华大学出版社”出版的《汇编语言程序设计教程》(第4版) 中术语，因此可能与其他软件的汉化术语略有不同。</span><br><span class="line">3. 对 Scylla 插件等进行了全面汉化。</span><br><span class="line">4. 对 x64dbg 官方中文版的汉化错误及不一致处进行了修订，并与帮助文档的关键词进行了统一。</span><br><span class="line">5. 对中文版界面的字体进行了重新设置，使其更为美观。</span><br><span class="line">6. 对“暗黑”主题界面颜色的默认值进行了调整，使代码显示更为清晰。并对主题的“选项&gt;外观”对话框中的“颜色”和“字体”标签的排列错位进行了调整。</span><br><span class="line">7. 本次更新集成了可在“CPU”界面搜索中文字符串引用的 x64dbg_tol 插件。</span><br><span class="line">8. 本次更新版本修改了启动条件，改为直接以管理员权限启动。</span><br><span class="line">9. 本次去除了新版本主程序的数字签名，解决了某些 DLL 文件的非标字串不能汉化的问题。</span><br><span class="line"></span><br><span class="line">在x64dbg中设置条件断点 – by elecs@看雪学院</span><br><span class="line">https://bbs.pediy.com/thread-251385.htm</span><br><span class="line"></span><br><span class="line">x64dbg Plugin Manager 第三方人员开发的插件管理器</span><br><span class="line">https://github.com/horsicq/x64dbg-Plugin-Manager</span><br><span class="line"></span><br><span class="line">官网：https://x64dbg.com/</span><br><span class="line"></span><br><span class="line">x64dbg官方下载地址（软件原版已经自带简体中文语言）</span><br><span class="line">https://github.com/x64dbg/x64dbg/releases</span><br><span class="line">https://sourceforge.net/projects/x64dbg/files/snapshots</span><br><span class="line"></span><br><span class="line">x64dbg 简体中文版(Jan 6 2024)： https://www.lanzouu.com/iuFXx1l65ush</span><br><span class="line"></span><br><span class="line">## IDA pro</span><br><span class="line"></span><br><span class="line">参考：[IDA Pro 9 安装和插件配置-安全工具-看雪](https://bbs.kanxue.com/thread-285604.htm#msg_header_h1_1)</span><br><span class="line"></span><br><span class="line">### IDA Pro 9.0.241217 SP1</span><br><span class="line"></span><br><span class="line">打包了配置好的IDA9 SP1,设置IDAPython路径即可使用</span><br><span class="line"></span><br><span class="line">附件:</span><br><span class="line"></span><br><span class="line">- IDAPlugins.zip</span><br><span class="line"></span><br><span class="line">- IdaPro9Beta-Keygen-iRabbit.py</span><br><span class="line"></span><br><span class="line">- IDA Professional 9.0.7z</span><br><span class="line"></span><br><span class="line">	链接: https://pan.baidu.com/s/1eCmxbP6nNHm5qz41rFbetg?pwd=5hdq</span><br><span class="line"></span><br><span class="line">参考如下步骤</span><br><span class="line"></span><br><span class="line">1. 运行ida-pro_90sp1_x64win.exe安装ida</span><br><span class="line">2. 修改IdaPro9Beta-Keygen-iRabbit.py文件的部分内容,复制到ida根目录</span><br><span class="line">3. python运行keygen,自动修补</span><br><span class="line">4. 修改patched文件后缀,替换ida.dll和ida32.dll(注意保存原始文件)</span><br><span class="line"></span><br><span class="line">### IDA Pro 9.1.250226</span><br><span class="line"></span><br><span class="line">相比之下9.1修了不少bug,分析程序更快更丝滑,还有signatures-bundle和IDA Feeds可以使用</span><br><span class="line"></span><br><span class="line">实测9.0的patch脚本可用于9.1,并且大部分9.0的插件可用于9.1,由于二者配置方法类似便不多赘述</span><br><span class="line"></span><br><span class="line">更新部分如下(2025/04/14):</span><br><span class="line"></span><br><span class="line">1. 初始化IDA</span><br><span class="line"></span><br><span class="line">	参考Binwalker师傅编写的7.7绿色版的IDA_InitTool</span><br><span class="line"></span><br><span class="line">	使用python实现禁用IDA自动更新和设置IDAPython路径的功能(默认使用嵌入的python3.11.9</span><br><span class="line"></span><br><span class="line">2. 配置和使用IDA Feeds插件</span><br><span class="line"></span><br><span class="line">	泄露文件中包括了符号库signatures-bundles-9.1.zip,物尽其用配置了一波该插件</span><br><span class="line"></span><br><span class="line">3. 配置和使用IDA MCP插件</span><br><span class="line"></span><br><span class="line">	实测自动化分析效果和WPeChatGPT差不多,但能看到分析过程,需要注意消耗的token更多</span><br><span class="line"></span><br><span class="line">提供配置好的IDA9.1压缩包,初次使用前运行InitIDA.exe后即可使用(WPeChatgpt需要手动配置api和模型)</span><br><span class="line">IDA Professional 9.1.7z 链接: https://pan.baidu.com/s/16Hk9FjEygb1yohUzblxdFw?pwd=8put 提取码: 8put</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **GDB（Linux）**</span><br><span class="line"></span><br><span class="line">1. 安装：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  sudo apt install gdb
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 基础命令：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  gdb ./target         # 加载程序
  break main           # 在main函数下断点
  run                 # 运行
  ni                  # 单步执行
  info registers      # 查看寄存器
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># IDA Pro快速上手</span><br><span class="line"></span><br><span class="line">参考：[IDA Pro的使用CSDN](https://blog.csdn.net/Python_0011/article/details/146866529)</span><br><span class="line"></span><br><span class="line">来源：BUUCTF 	题目：easyre</span><br><span class="line"></span><br><span class="line">## 打开软件</span><br><span class="line"></span><br><span class="line">打开IDA，会看到 &quot;New&quot; 和 &quot;Go&quot; 两个选项。&quot;New&quot; 是直接打开程序，&quot;Go&quot; 是先启动 IDA 界面。</span><br><span class="line"></span><br><span class="line">选 &quot;Go&quot;，启动后，在菜单栏里点 &quot;File&quot; -&gt; &quot;Open&quot;，找到要分析的程序。然后会跳出个窗口，默认设置就好。</span><br><span class="line"></span><br><span class="line">### 加载文件配置窗口</span><br><span class="line"></span><br><span class="line">这个界面是一个IDA Pro或类似的逆向工程软件在加载可执行文件时显示的配置对话框。以下是各部分的解释：</span><br><span class="line"></span><br><span class="line">**1. 文件加载信息**</span><br><span class="line"></span><br><span class="line">- **`Load file F:\AA-Reversing\BUUCTF\easyre\easyre.exe as`**</span><br><span class="line">	表示正在加载的可执行文件路径和名称（`easyre.exe`），并询问以何种格式解析该文件。</span><br><span class="line">	提供的选项包括：</span><br><span class="line">	- **Portable executable for AMD64 (PE) [pe.dll]**：将文件解析为64位PE格式（Windows可执行文件）。</span><br><span class="line">	- **MS-DOS executable (EXE) [dos.dll]**：将文件解析为MS-DOS格式（旧版兼容模式）。</span><br><span class="line">	- **Binary file**：直接以二进制文件形式加载（无自动解析）。</span><br><span class="line"></span><br><span class="line">**2. 处理器类型（Processor type）**</span><br><span class="line"></span><br><span class="line">选择目标文件的CPU架构，通常工具会根据文件头自动识别，但也可手动调整。例如：</span><br><span class="line"></span><br><span class="line">- **Intel Pentium protected with MMX**：保护模式下的x86指令集（常见于Windows/Linux可执行文件）。</span><br><span class="line">- **Intel Pentium real with MMX**：实模式（常见于DOS程序）。</span><br><span class="line">- **MetaPC**：通用反汇编模式。</span><br><span class="line">- **Intel 860**：较少见的架构（通常不用于常规逆向）。</span><br><span class="line"></span><br><span class="line">**3. 加载段配置（Loading segment/offset）**</span><br><span class="line"></span><br><span class="line">- **Loading segment 0x0000000000000000**</span><br><span class="line">	指定代码段的起始地址（通常PE文件会从`0x00400000`开始，此处可能是默认值或手动输入）。</span><br><span class="line">- **Loading offset 0x0000000000000000**</span><br><span class="line">	指定文件在内存中的偏移量（与段地址配合使用）。</span><br><span class="line"></span><br><span class="line">**4. 分析选项（Analysis/Options）**</span><br><span class="line"></span><br><span class="line">- **Enabled**：是否启用自动分析（如识别函数、字符串等）。</span><br><span class="line">- **Create segments**：自动创建代码/数据段。</span><br><span class="line">- **Load resources**：加载PE文件的资源部分（如图标、字符串表）。</span><br><span class="line">- **Fill segment gaps**：填充段之间的空隙（对齐内存）。</span><br><span class="line">- **Create FLAT group**：将段合并为平坦内存模型（简化地址计算）。</span><br><span class="line">- **Manual load**：手动加载（高级用户自定义配置）。</span><br><span class="line"></span><br><span class="line">**5. 底部按钮**</span><br><span class="line"></span><br><span class="line">- **OK**：确认配置并加载文件。</span><br><span class="line">- **Cancel**：取消加载。</span><br><span class="line">- **Help**：查看帮助文档。</span><br><span class="line"></span><br><span class="line">**用户操作建议**</span><br><span class="line"></span><br><span class="line">1. **保持默认选项**：如果是标准的Windows PE文件（如`easyre.exe`），直接选择`Portable executable for AMD64`并点击`OK`。</span><br><span class="line">2. **手动调整**：若文件特殊（如加壳、混淆），可能需要修改处理器类型或关闭自动分析。</span><br><span class="line">3. **错误处理**：如果加载后代码混乱，可能是架构选错，需重新尝试其他选项。</span><br><span class="line"></span><br><span class="line">这个界面主要用于确保工具正确解析文件结构和指令集，是逆向工程的第一步。</span><br><span class="line"></span><br><span class="line">### **DWARF调试信息** 配置窗口</span><br><span class="line"></span><br><span class="line">检测到目标文件中包含 **DWARF调试信息** 时弹出的配置对话框。</span><br><span class="line"></span><br><span class="line">DWARF是一种常见的调试数据格式（主要用于ELF文件，如Linux/gcc编译的程序），包含函数名、变量类型、源代码行号等高级信息。以下是各选项的详细解释：</span><br><span class="line"></span><br><span class="line">**1. 核心选项**</span><br><span class="line"></span><br><span class="line">- **`Global names`**</span><br><span class="line">	加载全局变量和符号的名称（如`g_counter`）。勾选后，逆向时能看到更有意义的变量名。</span><br><span class="line">- **`Functions`**</span><br><span class="line">	**（默认勾选）** 加载函数名和边界信息（如`main()`、`sub_401000`会被替换为原始函数名）。</span><br><span class="line">- **`Use function bounds`**</span><br><span class="line">	严格按DWARF信息定义函数范围（避免工具错误分割函数）。</span><br><span class="line"></span><br><span class="line">**2. 类型与调用约定**</span><br><span class="line"></span><br><span class="line">- **`Types (uncheck for speed)`**</span><br><span class="line">	**（默认勾选）** 加载变量/结构体的类型信息（如`int`、`char*`）。取消勾选可加快加载速度，但会丢失类型提示。</span><br><span class="line">- **`Apply calling conventions`**</span><br><span class="line">	**（默认勾选）** 应用DWARF中记录的调用约定（如`cdecl`、`fastcall`），确保反汇编的调用逻辑准确。</span><br><span class="line">- **`Allow __usercall`**</span><br><span class="line">	**（默认勾选）** 支持非标准调用约定（如用户自定义的寄存器传参方式）。</span><br><span class="line">- **`Function prototypes are definitive`**</span><br><span class="line">	**（默认勾选）** 强制使用DWARF中的函数原型（覆盖工具的自动推断）。</span><br><span class="line"></span><br><span class="line">**3. 源代码关联**</span><br><span class="line"></span><br><span class="line">- **`Import file names/line numbers`**</span><br><span class="line">	关联源代码文件名和行号（需DWARF中包含编译路径信息）。勾选后，反汇编窗口可能显示类似`/home/user/src/main.c:10`的注释。</span><br><span class="line"></span><br><span class="line">**4. 底部按钮**</span><br><span class="line"></span><br><span class="line">- **`Yes`** 确认加载DWARF信息（推荐勾选所需选项后点击）。</span><br><span class="line">- **`No`** 忽略DWARF信息，仅按二进制文件分析。</span><br><span class="line"></span><br><span class="line">**用户操作建议**</span><br><span class="line"></span><br><span class="line">1. **常规逆向**：保持默认勾选（尤其是`Functions`和`Types`），以获取最大信息量。</span><br><span class="line">2. **性能优先**：若文件较大，可取消`Types`或`Import file names/line numbers`加速加载。</span><br><span class="line">3. **混淆/优化代码**：若DWARF信息可能被篡改（如某些CTF题目），可关闭`Function prototypes are definitive`，避免误导。</span><br><span class="line">4. **无源码调试**：即使勾选`Import file names/line numbers`，若DWARF中路径无效，则不会显示行号。</span><br><span class="line"></span><br><span class="line">### **为什么重要？**</span><br><span class="line"></span><br><span class="line">DWARF信息能极大提升逆向效率，例如：</span><br><span class="line"></span><br><span class="line">- 直接显示`main()`而非`sub_401000`。</span><br><span class="line">- 恢复结构体字段名（如`struct.user.name`）。</span><br><span class="line">- 识别库函数调用（如`strcpy`的参数类型）。</span><br><span class="line">	但需注意：**发布版本通常剥离DWARF**，此界面多见于开发/调试版本。</span><br><span class="line"></span><br><span class="line">## 窗口介绍</span><br><span class="line"></span><br><span class="line">主窗口界面：</span><br><span class="line"></span><br><span class="line">- **函数窗口 (Functions window)：**</span><br><span class="line"></span><br><span class="line">	在左侧的就是函数窗口，所有的后汉书都在此窗口列出。</span><br><span class="line"></span><br><span class="line">	拿到一个题目，一般从main函数开始，但main函数通常不会直接显示出来，所以需要点击窗口后用Ctrl+F搜一下。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/IDA_Functions%20window.png)</span><br><span class="line"></span><br><span class="line">- **汇编窗口 (IDA views):**</span><br><span class="line"></span><br><span class="line">	这块是汇编代码的地盘，有两种显示方式：</span><br><span class="line"></span><br><span class="line">	1.图形模式</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543842.png)</span><br><span class="line"></span><br><span class="line">	2.文本模式</span><br><span class="line"></span><br><span class="line">	在图形模式下，右键选 &quot;Text view&quot; 或者按空格键就能切换到文本模式。</span><br><span class="line"></span><br><span class="line">	展示汇编代码和地址。![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543843.png)</span><br><span class="line"></span><br><span class="line">	- **伪代码窗口：**</span><br><span class="line"></span><br><span class="line">		在汇编窗口文本模式中，对着函数按 `F5`，就能看到伪代码，把汇编语言变成了更易读的伪代码。</span><br><span class="line"></span><br><span class="line">	![image-20250505180517503](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/IDA_views%E4%BC%AA%E4%BB%A3%E7%A0%81.png)</span><br><span class="line"></span><br><span class="line">- **十六进制窗口：**</span><br><span class="line"></span><br><span class="line">	虽然叫“十六进制窗口”，但它其实能显示各种格式，还能当十六进制编辑器用。默认情况下，它会显示程序的十六进制代码和对应的 ASCII 字符，每行 16 个字节。可以同时打开好几个十六进制窗口。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051809928.png)</span><br><span class="line"></span><br><span class="line">- **消息窗口：**</span><br><span class="line"></span><br><span class="line">	会显示 IDA 输出的信息，比如文件分析状态、操作错误等等，就像 Pycharm 的 Console 控制台。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051810911.png)</span><br><span class="line"></span><br><span class="line">- **导航栏：**</span><br><span class="line"></span><br><span class="line">	导航栏就是那条彩色的水平带，它能线性地展示被加载文件的地址空间。默认情况下，它会显示整个二进制文件的地址范围。右击导航栏，会显示一个提示，告诉你光标所在位置对应二进制文件中的哪个位置。</span><br><span class="line"></span><br><span class="line">	简单来说，点哪儿跳哪儿，不同的颜色代表不同的数据段，比如 data 段、text 段等等。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051811379.png)</span><br><span class="line"></span><br><span class="line">## 修正</span><br><span class="line"></span><br><span class="line">IDA在加载文件的时候会有些错误，需要手动纠正。</span><br><span class="line"></span><br><span class="line">1. 函数修正：</span><br><span class="line"></span><br><span class="line">通常以 push ebp/rbp 指令开头的地址是函数的起始地址，但 IDA 有时会认错。这时候，在起始地址的汇编代码处，按快捷键 P (或者右键选 &quot;Create Function&quot;)，就能把它变成函数。</span><br><span class="line"></span><br><span class="line">2. 指令修正：</span><br><span class="line"></span><br><span class="line">如果 IDA 把某些指令识别错了，选中后按快捷键 D 就能手动修正。</span><br><span class="line"></span><br><span class="line">3. 数据修正：</span><br><span class="line"></span><br><span class="line">在数据段，一个数据的长度可能是 1/2/4/8 字节，用快捷键 D 可以修改类型。如果某部分数据是字符串但没被正确识别，按快捷键 A 就能把它变成 ASCII 字符串。</span><br><span class="line"></span><br><span class="line">## 注释和重命名</span><br><span class="line"></span><br><span class="line">- **重命名：**</span><br><span class="line"></span><br><span class="line">	在 IDA 里，你可以修改变量名、函数名等等，方便理解代码。在需要重命名的地方右键，选 &quot;Rename&quot; 就行。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051817181.png)</span><br><span class="line"></span><br><span class="line">- **注释：**</span><br><span class="line"></span><br><span class="line">	快捷键 `;` 可以在反汇编窗口加注释，快捷键 `/` 可以在反编译窗口加注释。IDA 还能自动给不常用架构的代码加注释，在 &quot;Auto comments&quot; 那里勾选就行。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051825870.png)</span><br><span class="line"></span><br><span class="line">## 交叉引用</span><br><span class="line"></span><br><span class="line">- **代码交叉引用：**</span><br><span class="line"></span><br><span class="line">	表示一个指令把控制权交给另一个指令，能帮忙了解指令和指令、指令和函数之间的调用关系。</span><br><span class="line"></span><br><span class="line">- **数据交叉引用：**</span><br><span class="line"></span><br><span class="line">	用于追踪二进制文件访问数据的情况，能让知道指令和数据之间有啥关系。这部分需要比较扎实的汇编知识。</span><br><span class="line"></span><br><span class="line">## 常用快捷键</span><br><span class="line"></span><br><span class="line">- F5：</span><br><span class="line"></span><br><span class="line">	在汇编窗口里按 F5，能生成对应函数的伪代码。</span><br><span class="line"></span><br><span class="line">* Ctrl+F5：</span><br><span class="line"></span><br><span class="line">	可以把伪代码导出保存下来。</span><br><span class="line"></span><br><span class="line">* Shift+F12：</span><br><span class="line"></span><br><span class="line">	在汇编窗口里按 Shift+F12，能打开字符串窗口。所有字符串都在这儿展示，你可以搜一些关键字符串。双击某个字符串，就能跳到汇编窗口中该字符串对应的位置。用 Ctrl+F 可以查找字符串。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051953784.png)</span><br><span class="line"></span><br><span class="line">- **Ctrl+X (交叉引用)：**</span><br><span class="line"></span><br><span class="line">	在汇编窗口中，用 `Ctrl+X` 可以查看哪些函数引用了这个字符串或数据。点 &quot;OK&quot; 会跳到相应位置。</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505051955880.png)</span><br><span class="line"></span><br><span class="line">- **Alt+T (文本搜索)：**</span><br><span class="line"></span><br><span class="line">	IDA 文本搜索相当于在反汇编列表窗口文本模式下搜索子字符串。搜到字符串后，会自动跳到汇编窗口中对应的位置。</span><br><span class="line"></span><br><span class="line">	它只会查找完整的词，包括操作码助记符或常量。</span><br><span class="line"></span><br><span class="line">	选 &quot;Find all occurences&quot;，IDA 会在一个新窗口里显示所有搜索结果，方便你快速定位。</span><br><span class="line"></span><br><span class="line">- **跳转地址：**</span><br><span class="line"></span><br><span class="line">	汇编窗口左边是地址，右边是汇编代码。</span><br><span class="line"></span><br><span class="line">	在浏览代码的时候，可能会迷路。或者你知道想去的目标地址，但反汇编窗口里没有可供双击导航的名称。这时候，用 `G` 就能跳到指定位置。</span><br><span class="line"></span><br><span class="line">- **N (重命名)：**</span><br><span class="line"></span><br><span class="line">	可以把一些函数名或者变量名改成方便理解的名字。</span><br><span class="line"></span><br><span class="line">- **Ctrl+Z (撤回操作)：**</span><br><span class="line"></span><br><span class="line">	不小心改错了，Ctrl+Z回到上一步。</span><br><span class="line"></span><br><span class="line">## 数据类型转换快捷键</span><br><span class="line"></span><br><span class="line">当flag 是 16 进制 ASCII 值时，可以靠快捷键搞定。</span><br><span class="line"></span><br><span class="line">- D (转换成数据形式)：</span><br><span class="line"></span><br><span class="line">	分析数据时，有时候需要把字符串转换成数据。</span><br><span class="line"></span><br><span class="line">* A (转换成字符形式)：</span><br><span class="line"></span><br><span class="line">	转换成字符串。</span><br><span class="line"></span><br><span class="line">* C (转换成汇编代码)：</span><br><span class="line"></span><br><span class="line">	转换成汇编代码。</span><br><span class="line"></span><br><span class="line">* U (转成原始字符)：</span><br><span class="line"></span><br><span class="line">	转换成最原始的状态。</span><br><span class="line"></span><br><span class="line">* Shift+E (导出数据)：</span><br><span class="line"></span><br><span class="line">	导出数据，选中后按 Shift+E，选你想导出的方式。</span><br><span class="line"></span><br><span class="line">- **数据转化形式：**</span><br><span class="line"></span><br><span class="line">	分析伪代码时，有时候要对数据进行类型转化。右键数据，会出现这些选项：</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505052002733.png)</span><br><span class="line"></span><br><span class="line">	- Hexadecimal: 十六进制</span><br><span class="line">	- Octal: 八进制</span><br><span class="line">	- Char: 字符</span><br><span class="line">	- Enum: 枚举</span><br><span class="line"></span><br><span class="line">main函数翻成伪代码后：</span><br><span class="line"></span><br><span class="line">````java</span><br><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int b; // [rsp+28h] [rbp-8h] BYREF</span><br><span class="line">  int b_1; // [rsp+2Ch] [rbp-4h] BYREF</span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  scanf(&quot;%d%d&quot;, &amp;b_1, &amp;b);</span><br><span class="line">  if ( b_1 == b )</span><br><span class="line">    printf(&quot;flag&#123;this_Is_a_EaSyRe&#125;&quot;);</span><br><span class="line">  else</span><br><span class="line">    printf(&quot;sorry,you can&#x27;t get flag&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">分析出 `main` 函数的逻辑是：**输入两个相同的数字 → 输出 flag**</span><br><span class="line"></span><br><span class="line">## **解题方法**</span><br><span class="line"></span><br><span class="line">### **方法 1：直接运行程序并输入相同数字**</span><br><span class="line"></span><br><span class="line">1. **运行程序**（如果是 Windows 的 `.exe`，直接双击；如果是 Linux 的 ELF，用 `./program` 运行）。</span><br><span class="line"></span><br><span class="line">2. **输入两个相同的数字**，比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  123
  123
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. **程序输出 flag**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  flag&#123;this_Is_a_EaSyRe&#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### **方法 2：直接修改二进制文件（硬编码绕过检查）**</span><br><span class="line"></span><br><span class="line">如果不想手动输入，可以修改汇编代码，让程序直接输出 flag（适用于逆向题目）：</span><br><span class="line"></span><br><span class="line">1. 用 **IDA/Ghidra** 找到 `if (b_1 == b)` 的判断部分。</span><br><span class="line">2. 把 `JNE`（跳转如果不相等）改成 `JMP` 或 `NOP`，让程序直接执行 `printf(&quot;flag&#123;...&#125;&quot;)`。</span><br><span class="line">3. 保存修改后的程序，运行即可直接得 flag。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># IDA Pro MCP 逆向分析利器</span><br><span class="line"></span><br><span class="line">参考：[AI逆向50页长文掌握 IDA Pro MCP 逆向分析利器](https://bbs.kanxue.com/thread-286813.htm)</span><br><span class="line"></span><br><span class="line">## 步骤一：准备大模型 API Key</span><br><span class="line"></span><br><span class="line">要使用 IDA Pro MCP，首先需要一个大模型服务的 API Key。</span><br><span class="line"></span><br><span class="line">### DeepSeek</span><br><span class="line"></span><br><span class="line">- **官方网站:** [https://www.deepseek.com/](https://bbs.kanxue.com/elink@cc8K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6%4N6%4N6Q4x3X3g2V1k6h3g2H3M7$3g2W2K9#2)</span><br><span class="line">- **API 管理平台:** [https://platform.deepseek.com/usage](https://bbs.kanxue.com/elink@fa1K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3L8r3q4@1k6X3!0J5L8g2)</span><br><span class="line"></span><br><span class="line">根据平台的指引完成实名认证和充值，在API管理页创建一个新的API Key。</span><br><span class="line"></span><br><span class="line">`务必妥善保管API Key，防止泄露！！！`</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543844.png)</span><br><span class="line"></span><br><span class="line">在充值后，在liunx系统使用curl命令测试api是否可用。</span><br><span class="line"></span><br><span class="line">将 `&lt;DeepSeek API Key&gt;` 替换为自己的 Key</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">curl https://api.deepseek.com/chat/completions \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -H &quot;Authorization: Bearer &lt;DeepSeek API Key&gt;&quot; \</span><br><span class="line">  -d &#x27;&#123;</span><br><span class="line">        &quot;model&quot;: &quot;deepseek-chat&quot;,</span><br><span class="line">        &quot;messages&quot;: [</span><br><span class="line">          &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;,</span><br><span class="line">          &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Hello!&quot;&#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;stream&quot;: false</span><br><span class="line">      &#125;&#x27;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220917980.png)</span><br><span class="line"></span><br><span class="line">如果终端成功输出了 AI 的回复消息，则表示 DeepSeek API Key 配置成功.</span><br><span class="line"></span><br><span class="line">## 步骤二：选择并配置 MCP 客户端</span><br><span class="line"></span><br><span class="line">### 客户端一：VS Code 插件 (Cline / RooCode)</span><br><span class="line"></span><br><span class="line">Cline 和 RooCode 是两款支持 MCP 的 VS Code 插件，可以将 VS Code 作为 IDA Pro MCP 的客户端。</span><br><span class="line"></span><br><span class="line">#### 安装</span><br><span class="line"></span><br><span class="line">“扩展”，插件cline或RooCode</span><br><span class="line"></span><br><span class="line">#### 初始化配置</span><br><span class="line"></span><br><span class="line">进行初始化配置，主要是设置大模型API Key</span><br><span class="line"></span><br><span class="line">1. 打开其中一个插件的设置界面，点击插件图标（或是用命令面板Ctrl+Shift+P/Cmd+Shift+P走索插件名称找到。）</span><br><span class="line"></span><br><span class="line">2. 选择“使用自己的PAPI Key”（Use your own API key）</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220931666.png)</span><br><span class="line"></span><br><span class="line">3. 配置 API Key</span><br><span class="line"></span><br><span class="line">	根据选择的 API 服务商进行配置：</span><br><span class="line"></span><br><span class="line">	- **DeepSeek:**</span><br><span class="line">		- 选择 `API Provider` 为 `DeepSeek`。</span><br><span class="line">		- 在 `API Key` 字段中填入 DeepSeek API Key。</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220933934.png)</span><br><span class="line"></span><br><span class="line">**语言设置（Preferred Language）**</span><br><span class="line"></span><br><span class="line">- **简体中文**：强制工具（如Cline插件）始终以中文与你交互，即使你的提问包含其他语言。</span><br><span class="line">- **作用场景**：例如当你输入英文问题时，工具仍会用中文回答。</span><br><span class="line"></span><br><span class="line">![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505220957109.png)</span><br><span class="line"></span><br><span class="line">## 步骤四：部署 IDA Pro MCP (Windows)</span><br><span class="line"></span><br><span class="line">1. **配置python环境**</span><br><span class="line"></span><br><span class="line">	Windows 环境需要安装 Python 3.11 或更高版本</span><br><span class="line"></span><br><span class="line">	已安装python使用的版本为3.12.6</span><br><span class="line"></span><br><span class="line">2. **切换 IDA Pro 的 Python 环境**</span><br><span class="line"></span><br><span class="line">	告知 IDA Pro 使用安装的 Python 3.12.6，cmd中执行</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	&quot;F:\IDA Professional 9.1\idapyswitch.exe&quot; --force-path &quot;E:\python\python3,dll&quot;</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/202505221043566.png)</span><br><span class="line"></span><br><span class="line">	成功执行后通常没有输出。</span><br><span class="line"></span><br><span class="line">3. **安装 ida-pro-mcp Python 包**</span><br><span class="line"></span><br><span class="line">	下载 `uv` 包</span><br><span class="line"></span><br><span class="line">	#### 分步安装依赖</span><br><span class="line"></span><br><span class="line">	如果直接安装失败，先安装小体积依赖包，再尝试安装 `uv`：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  # 先安装其他小包（如有必要）
  pip install numpy pandas -i https://pypi.tuna.tsinghua.edu.cn/simple
  
  # 再安装 uv
  pip install uv -i https://pypi.tuna.tsinghua.edu.cn/simple
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 Python  的 pip 来安装 `ida-pro-mcp`。</span><br><span class="line"></span><br><span class="line">之后所有 pip 安装都会默认使用清华源，**永久配置镜像源**（推荐）</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">**临时指定镜像源**：在命令中添加 `-i` 参数：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  pip install --upgrade git+https://github.com/mrexodia/ida-pro-mcp -i https://pypi.tuna.tsinghua.edu.cn/simple
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. **安装 MCP 插件到 IDA Pro**</span><br><span class="line"></span><br><span class="line">	执行安装命令将插件复制到 IDA Pro</span><br><span class="line"></span><br><span class="line">	使用命令查找`ida-pro-mcp.exe` 可执行文件的路径。</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	pip show -f ida-pro-mcp</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	输出信息：</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	Name: ida-pro-mcp</span><br><span class="line">	Version: 1.3.0</span><br><span class="line">	...</span><br><span class="line">	Location: E:\python\Lib\site-packages# &lt;--- 包安装位置</span><br><span class="line">	Requires: mcp</span><br><span class="line">	Required-by:</span><br><span class="line">	Files:</span><br><span class="line">	  ..\..\Scripts\ida-pro-mcp.exe# &lt;--- 可执行文件相对路</span><br><span class="line">	  ..\..\Scripts\idalib-mcp.exe</span><br><span class="line">	  ida_pro_mcp-1.3.0.dist-info\INSTALLER</span><br><span class="line">		...</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	可得绝对路径：E:\python\Scripts\ida-pro-mcp.exe</span><br><span class="line"></span><br><span class="line">	执行安装命令：</span><br><span class="line"></span><br><span class="line">	````</span><br><span class="line">	&quot;E:\python\Scripts\ida-pro-mcp.exe&quot; --install</span><br><span class="line">	````</span><br><span class="line"></span><br><span class="line">	![](https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202507031543845.png)</span><br><span class="line"></span><br><span class="line">​	**MCP 服务器配置生成**，这是 **MCP 服务器的标准配置模板**，需手动添加到对应工具的配置文件中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>Installed IDA Pro plugin (IDA restart required)<br>Plugin: C:\Users\tangxtang\AppData\Roaming\Hex-Rays\IDA Pro\plugins\mcp-plugin.py</p>
<pre><code>
- **核心功能已部署**，插件文件已复制到 IDA 的插件目录。
- 需要 **重启 IDA** 才能生效。
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓逆向工程</tag>
        <tag>信息安全</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>基础总结</title>
    <url>/2025/05/01/%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="一、基础语法结构"><a href="#一、基础语法结构" class="headerlink" title="一、基础语法结构"></a>一、基础语法结构</h2><h3 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1. 变量与数据类型"></a>1. 变量与数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;                  <span class="comment">// 整数（4字节）</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">9.99</span>;           <span class="comment">// 双精度浮点</span></span><br><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;              <span class="comment">// 单个字符</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isOpen</span> <span class="operator">=</span> <span class="literal">true</span>;         <span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用数据类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Android&quot;</span>;       <span class="comment">// 字符串</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;       <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>

<h3 id="2-控制流程"><a href="#2-控制流程" class="headerlink" title="2. 控制流程"></a>2. 控制流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">40</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;补考&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;挂科&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环结构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);      <span class="comment">// 0,1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(j++);    <span class="comment">// 0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、面向对象核心"><a href="#二、面向对象核心" class="headerlink" title="二、面向对象核心"></a>二、面向对象核心</h2><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象使用</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">p.sayHello();  <span class="comment">// 输出: Hello, I&#x27;m Alice</span></span><br></pre></td></tr></table></figure>

<h3 id="2-继承与多态"><a href="#2-继承与多态" class="headerlink" title="2. 继承与多态"></a>2. 继承与多态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);  <span class="comment">// 方法重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态示例</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">myDog.sound();  <span class="comment">// 输出: 汪汪汪</span></span><br></pre></td></tr></table></figure>

<h2 id="三、关键语法特性"><a href="#三、关键语法特性" class="headerlink" title="三、关键语法特性"></a>三、关键语法特性</h2><h3 id="1-访问修饰符"><a href="#1-访问修饰符" class="headerlink" title="1. 访问修饰符"></a>1. 访问修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>类内</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
</tr>
<tr>
<td><code>public</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>默认</td>
<td>✔️</td>
<td>✔️</td>
<td>✖️</td>
<td>✖️</td>
</tr>
</tbody></table>
<h3 id="2-接口与抽象类"><a href="#2-接口与抽象类" class="headerlink" title="2. 接口与抽象类"></a>2. 接口与抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口（100%抽象）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;  <span class="comment">// 隐式 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类（可包含实现）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123; <span class="comment">/* 具体实现 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;总会执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、集合框架"><a href="#五、集合框架" class="headerlink" title="五、集合框架"></a>五、集合框架</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用集合类</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 有序可重复</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();     <span class="comment">// 无序唯一</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合操作</span></span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="六、其他逆向重点"><a href="#六、其他逆向重点" class="headerlink" title="六、其他逆向重点"></a>六、其他逆向重点</h2><h3 id="1-反射机制（逆向关键）"><a href="#1-反射机制（逆向关键）" class="headerlink" title="1. 反射机制（逆向关键）"></a>1. 反射机制（逆向关键）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;secretMethod&quot;</span>);</span><br><span class="line">method.invoke(clazz.newInstance());</span><br></pre></td></tr></table></figure>

<h3 id="2-泛型（反编译常见）"><a href="#2-泛型（反编译常见）" class="headerlink" title="2. 泛型（反编译常见）"></a>2. 泛型（反编译常见）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Integer&gt;&gt; complexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异步执行&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h2 id="七、内存管理基础"><a href="#七、内存管理基础" class="headerlink" title="七、内存管理基础"></a><strong>七、内存管理基础</strong></h2><ol>
<li><strong>栈内存</strong>：存储基本类型变量和方法调用</li>
<li><strong>堆内存</strong>：存储对象实例</li>
<li><strong>方法区</strong>：存储类信息、常量池</li>
<li><strong>垃圾回收</strong>：自动回收无引用对象（<code>System.gc()</code>建议回收）</li>
</ol>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a><strong>学习建议</strong></h2><ol>
<li><strong>重点掌握</strong>：类与对象、继承多态、集合框架</li>
<li><strong>逆向关联</strong>：反射机制、异常处理、接口特性</li>
<li><strong>实践方法</strong>：通过修改开源项目的代码观察运行结果</li>
</ol>
<p><strong>附：逆向工程中常见的Java代码特征</strong></p>
<ul>
<li><code>private static final</code> 修饰的密钥字段</li>
<li><code>try-catch</code> 包裹的核心逻辑</li>
<li><code>native</code> 声明的JNI方法</li>
<li><code>synchronized</code> 同步代码块</li>
</ul>
<p>结合APK反编译后的实际代码进行对照学习，理解语法到字节码的转换逻辑。</p>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="一、基本特性与优势"><a href="#一、基本特性与优势" class="headerlink" title="一、基本特性与优势"></a>一、基本特性与优势</h2><ul>
<li><strong>简洁性</strong>：语法精简，减少模板代码（如省略分号、简化类定义）。</li>
<li><strong>空安全</strong>：编译期检查空指针，从语法层面避免 <code>NullPointerException</code>。</li>
<li><strong>函数式编程</strong>：支持 Lambda 表达式、高阶函数、协程等。</li>
<li><strong>面向对象</strong>：保留类、继承、接口等 OOP 特性，同时更灵活。</li>
<li><strong>与 Java 互操作</strong>：可直接调用 Java 代码，Java 也可调用 Kotlin 代码，无缝兼容 Android 现有项目。</li>
</ul>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h3><p>Kotlin 变量分为<strong>可变</strong>（<code>var</code>）和<strong>不可变</strong>（<code>val</code>，类似 Java 的 <code>final</code>），无需显式声明类型（类型推断）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可变变量（推荐优先使用）</span></span><br><span class="line"><span class="keyword">val</span> name: String = <span class="string">&quot;Kotlin&quot;</span>  <span class="comment">// 显式声明类型</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span>  <span class="comment">// 类型推断为 Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">90</span>  <span class="comment">// 类型推断为 Int</span></span><br><span class="line">score = <span class="number">95</span>  <span class="comment">// 可修改</span></span><br></pre></td></tr></table></figure>

<h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h3><p>与 Java 类似，但<strong>无基本类型与包装类之分</strong>，全部是对象，支持直接调用方法：</p>
<ul>
<li>数值类型：<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code></li>
<li>字符：<code>Char</code>（单引号，如 <code>&#39;A&#39;</code>）</li>
<li>布尔：<code>Boolean</code>（<code>true</code>&#x2F;<code>false</code>）</li>
<li>字符串：<code>String</code>（双引号，支持模板语法 <code>$&#123;&#125;</code>）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">10L</span>  <span class="comment">// 加 L 表示 Long 类型</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="number">3.14f</span>  <span class="comment">// 加 f 表示 Float 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串模板</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="keyword">val</span> info = <span class="string">&quot;Language: <span class="variable">$name</span>, Version: <span class="subst">$&#123;<span class="number">1.9</span> + <span class="number">0.1</span>&#125;</span>&quot;</span>  <span class="comment">// 输出 &quot;Language: Kotlin, Version: 2.0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-函数定义"><a href="#3-函数定义" class="headerlink" title="3. 函数定义"></a>3. 函数定义</h3><p>用 <code>fun</code> 关键字定义，语法：&#96;fun 函数名(参数: 类型): 返回值类型 { … }</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单表达式函数（简化写法，自动推断返回值）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiply</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a * b  <span class="comment">// 等价于返回 a*b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无返回值（返回 Unit，类似 Java 的 void，可省略）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHi</span><span class="params">()</span></span> &#123;  <span class="comment">// 省略 Unit</span></span><br><span class="line">    println(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特色参数</strong>：</p>
<ul>
<li><p>默认参数：给参数设置默认值，调用时可省略</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;Guest&quot;</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet()  <span class="comment">// 输出 &quot;Hello, Guest&quot;</span></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment">// 输出 &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名参数：调用时指定参数名，增强可读性</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>)</span></span> = a + b + c</span><br><span class="line">add(b = <span class="number">2</span>, a = <span class="number">1</span>, c = <span class="number">3</span>)  <span class="comment">// 按名称传参，结果 6</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a>三、控制流</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h3><ul>
<li><p><code>if</code>可作为<strong>表达式</strong>（有返回值），替代 Java 的<code>三元运算符</code>：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b  <span class="comment">// 等价于 Java 的 a &gt; b ? a : b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多分支用 <code>if-else if-else</code>，逻辑同 Java。</p>
</li>
</ul>
<h3 id="2-when-表达式（替代-Java-的-switch）"><a href="#2-when-表达式（替代-Java-的-switch）" class="headerlink" title="2. when 表达式（替代 Java 的 switch）"></a>2. when 表达式（替代 Java 的 switch）</h3><p>更灵活，支持任意类型匹配，且可作为表达式返回值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(x: <span class="type">Any</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">&quot;Int 类型，值为 1&quot;</span></span><br><span class="line">        <span class="string">&quot;hello&quot;</span> -&gt; <span class="string">&quot;String 类型&quot;</span></span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Boolean</span> -&gt; <span class="string">&quot;Boolean 类型&quot;</span>  <span class="comment">// 类型匹配（is 类似 Java 的 instanceof）</span></span><br><span class="line">        <span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; <span class="string">&quot;在 10-20 范围内&quot;</span>  <span class="comment">// 范围匹配</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;未知类型&quot;</span>  <span class="comment">// 必须包含 else（除非覆盖所有可能）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h3><ul>
<li><p><code>for</code> 循环：遍历集合或范围（<code>..</code> 表示闭区间）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历范围</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;  <span class="comment">// 1 到 5（包含 5）</span></span><br><span class="line">    print(i)  <span class="comment">// 输出 12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while</code> 和 <code>do-while</code>：与 Java 语法完全一致。</p>
</li>
</ul>
<h2 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h2><h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><p>默认是<strong>不可继承的</strong>（<code>final</code>），需用 <code>open</code> 关键字标记才能被继承：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 类成员变量</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可继承的类（open 修饰）</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;动物进食&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><ul>
<li><p><strong>主构造函数</strong>：类名后直接声明，简洁用于初始化参数</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">var</span> name: String) &#123;  <span class="comment">// 主构造函数参数</span></span><br><span class="line">    <span class="comment">// 初始化代码块（主构造函数执行时调用）</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student 初始化：id=<span class="variable">$id</span>, name=<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：val stu = Student(1, &quot;Tom&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>次构造函数</strong>：用 <code>constructor</code> 关键字，需调用主构造函数（<code>this</code>）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 次构造函数（必须调用主构造函数）</span></span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Int</span>, name: String) : <span class="keyword">this</span>(id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-数据类（data-class）"><a href="#3-数据类（data-class）" class="headerlink" title="3. 数据类（data class）"></a>3. 数据类（data class）</h3><p>专门用于存储数据的类，自动生成 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等方法，简化实体类定义（Android 中常用于网络数据模型）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">val</span> user = User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">println(user)  <span class="comment">// 自动生成 toString()：User(id=1, name=Alice, age=25)</span></span><br><span class="line"><span class="keyword">val</span> user2 = user.copy(age = <span class="number">26</span>)  <span class="comment">// 复制对象并修改部分属性</span></span><br></pre></td></tr></table></figure>

<h3 id="4-密封类（sealed-class）"><a href="#4-密封类（sealed-class）" class="headerlink" title="4. 密封类（sealed class）"></a>4. 密封类（sealed class）</h3><p>用于<strong>受限的类层次结构</strong>（子类固定），常用于状态管理（如 UI 状态：加载中、成功、失败）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> <span class="keyword">data</span>: String) : Result()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> message: String) : Result()</span><br><span class="line"><span class="keyword">object</span> Loading : Result()  <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时，when 语句可自动推断所有子类，无需 else</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleResult</span><span class="params">(result: <span class="type">Result</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (result) &#123;</span><br><span class="line">        <span class="keyword">is</span> Success -&gt; println(<span class="string">&quot;成功：<span class="subst">$&#123;result.data&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> Error -&gt; println(<span class="string">&quot;错误：<span class="subst">$&#123;result.message&#125;</span>&quot;</span>)</span><br><span class="line">        Loading -&gt; println(<span class="string">&quot;加载中...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、继承与接口"><a href="#五、继承与接口" class="headerlink" title="五、继承与接口"></a>五、继承与接口</h2><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><p>用 <code>:</code> 表示继承，父类需用 <code>open</code> 修饰，重写方法需用 <code>override</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;  <span class="comment">// 可重写的方法（open 修饰）</span></span><br><span class="line">        println(<span class="string">&quot;动物叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="type">Animal</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;  <span class="comment">// 重写父类方法（override 修饰）</span></span><br><span class="line">        println(<span class="string">&quot;汪汪叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><p>用 <code>interface</code> 定义，支持<strong>默认方法实现</strong>，类用 <code>:</code> 实现接口（可多实现）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimable</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法（无实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法（有实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">breath</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;在水中呼吸&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="type">Swimable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;鱼游来游去&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、空安全（核心特性）"><a href="#六、空安全（核心特性）" class="headerlink" title="六、空安全（核心特性）"></a>六、空安全（核心特性）</h2><p>Kotlin 区分<strong>可空类型</strong>（可能为 <code>null</code>）和<strong>非空类型</strong>（不可为 <code>null</code>），编译期避免空指针：</p>
<h4 id="1-可空类型标记"><a href="#1-可空类型标记" class="headerlink" title="1. 可空类型标记"></a>1. 可空类型标记</h4><p>在类型后加 <code>?</code> 表示可空：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String = <span class="string">&quot;abc&quot;</span>  <span class="comment">// 非空类型，不能赋值 null</span></span><br><span class="line">str = <span class="literal">null</span>  <span class="comment">// 编译报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nullableStr: String? = <span class="string">&quot;xyz&quot;</span>  <span class="comment">// 可空类型</span></span><br><span class="line">nullableStr = <span class="literal">null</span>  <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<h4 id="2-安全操作符"><a href="#2-安全操作符" class="headerlink" title="2. 安全操作符"></a>2. 安全操作符</h4><ul>
<li><p>**安全调用 <code>?.</code>**：若对象为 <code>null</code>，则表达式返回 <code>null</code>（不崩溃）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> length = nullableStr?.length  <span class="comment">// 若 nullableStr 为 null，length 为 null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**Elvis 操作符 <code>?:</code>**：若左侧为 <code>null</code>，则返回右侧默认值</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> len = nullableStr?.length ?: <span class="number">0</span>  <span class="comment">// 若为 null，返回 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**非空断言 <code>!!</code>**：强制认为对象非空，若为 <code>null</code> 则抛出 <code>NullPointerException</code>（谨慎使用）</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> len = nullableStr!!.length  <span class="comment">// 若 nullableStr 为 null，崩溃</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、集合框架"><a href="#七、集合框架" class="headerlink" title="七、集合框架"></a>七、集合框架</h2><p>Kotlin 集合分为<strong>不可变</strong>（默认，只读）和<strong>可变</strong>（可读写），通过不同函数创建：</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>不可变（只读）</th>
<th>可变（可读写）</th>
</tr>
</thead>
<tbody><tr>
<td>列表</td>
<td><code>listOf()</code></td>
<td><code>mutableListOf()</code></td>
</tr>
<tr>
<td>集合</td>
<td><code>setOf()</code></td>
<td><code>mutableSetOf()</code></td>
</tr>
<tr>
<td>映射</td>
<td><code>mapOf()</code></td>
<td><code>mutableMapOf()</code></td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可变列表（无法添加/删除元素）</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变列表</span></span><br><span class="line"><span class="keyword">val</span> mutableList = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">mutableList.add(<span class="number">4</span>)  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射（键值对）</span></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;name&quot;</span> to <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;version&quot;</span> to <span class="number">1.9</span>)</span><br><span class="line">println(map[<span class="string">&quot;name&quot;</span>])  <span class="comment">// 输出 &quot;Kotlin&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>集合操作</strong>（函数式风格）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> evenNumbers = numbers.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;  <span class="comment">// 过滤偶数：[2,4]</span></span><br><span class="line"><span class="keyword">val</span> squares = numbers.map &#123; it * it &#125;  <span class="comment">// 求平方：[1,4,9,16,25]</span></span><br><span class="line"><span class="keyword">val</span> sum = numbers.reduce &#123; acc, num -&gt; acc + num &#125;  <span class="comment">// 累加：15</span></span><br></pre></td></tr></table></figure>

<h2 id="八、扩展函数"><a href="#八、扩展函数" class="headerlink" title="八、扩展函数"></a>八、扩展函数</h2><p>无需继承，直接给现有类添加新方法（如给 <code>String</code> 加 <code>isEmail</code> 方法）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 String 扩展一个判断是否为邮箱的方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isEmail</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contains(<span class="string">&quot;@&quot;</span>) &amp;&amp; contains(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">val</span> email = <span class="string">&quot;test@example.com&quot;</span></span><br><span class="line">println(email.isEmail())  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p><strong>Android 中常用</strong>：给 <code>Context</code> 扩展 <code>toast</code> 方法，简化弹窗：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">toast</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Activity 中直接调用</span></span><br><span class="line">toast(<span class="string">&quot;Hello Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="九、Lambda-表达式与高阶函数"><a href="#九、Lambda-表达式与高阶函数" class="headerlink" title="九、Lambda 表达式与高阶函数"></a>九、Lambda 表达式与高阶函数</h3><h3 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. Lambda 表达式</h3><p>匿名函数，语法：<code>&#123; 参数 -&gt; 函数体 &#125;</code>，常用于简化回调：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接收 Lambda 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    action()  <span class="comment">// 执行 Lambda</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：传递 Lambda</span></span><br><span class="line">doSomething &#123;</span><br><span class="line">    println(<span class="string">&quot;执行操作&quot;</span>)  <span class="comment">// 输出 &quot;执行操作&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a>2. 高阶函数</h3><p>参数或返回值为函数的函数（如集合的 <code>filter</code>、<code>map</code>）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数：参数为 (Int) -&gt; Boolean 类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">filterNumbers</span><span class="params">(numbers: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, predicate: (<span class="type">Int</span>) -&gt; <span class="type">Boolean</span>)</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (num <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate(num)) &#123;  <span class="comment">// 调用传入的函数</span></span><br><span class="line">            result.add(num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：传递 Lambda 作为参数</span></span><br><span class="line"><span class="keyword">val</span> nums = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> evenNums = filterNumbers(nums) &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;  <span class="comment">// 过滤偶数：[2,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="十、协程（Coroutines）"><a href="#十、协程（Coroutines）" class="headerlink" title="十、协程（Coroutines）"></a>十、协程（Coroutines）</h2><p>Kotlin 用于<strong>异步编程</strong>的核心特性，解决回调地狱，让异步代码像同步代码一样直观（Android 中用于网络请求、数据库操作等耗时任务）：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>需添加依赖（<code>kotlinx-coroutines-core</code>），用 <code>launch</code> 启动协程，<code>suspend</code> 标记 suspend 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动协程（在主线程的协程作用域中）</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;  <span class="comment">// 启动一个新协程</span></span><br><span class="line">            delay(<span class="number">1000</span>)  <span class="comment">// 暂停 1 秒（非阻塞，不阻塞主线程）</span></span><br><span class="line">            println(<span class="string">&quot;协程执行完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;主线程继续执行&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2. 关键概念"></a>2. 关键概念</h3><ul>
<li><strong>协程作用域（CoroutineScope）</strong>：管理协程生命周期（如 Android 中的 <code>lifecycleScope</code>）。</li>
<li><strong>suspend 函数</strong>：只能在协程或其他 suspend 函数中调用，可包含耗时操作。</li>
<li><strong>非阻塞</strong>：协程暂停时，线程可执行其他任务，提高效率。</li>
</ul>
<h3 id="十一、与-Java-互操作"><a href="#十一、与-Java-互操作" class="headerlink" title="十一、与 Java 互操作"></a>十一、与 Java 互操作</h3><ul>
<li><strong>调用 Java 代码</strong>：直接使用，无需额外处理（如调用 <code>java.util.ArrayList</code>）。</li>
<li>Java 调用 Kotlin 代码：<ul>
<li>Kotlin 类默认是 <code>final</code>，Java 需用 <code>open</code> 修饰才能继承。</li>
<li>顶层函数（不在类中的函数）会被编译为 <code>文件名Kt</code> 类的静态方法。</li>
</ul>
</li>
</ul>
<h1 id="Android四大组件的核心概念"><a href="#Android四大组件的核心概念" class="headerlink" title="Android四大组件的核心概念"></a>Android四大组件的核心概念</h1><h2 id="一、Activity（活动）"><a href="#一、Activity（活动）" class="headerlink" title="一、Activity（活动）"></a>一、Activity（活动）</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>用户交互界面单元</strong>，每个屏幕对应一个Activity</li>
<li>通过<strong>Intent</strong>实现页面跳转（正向&#x2F;逆向均需重点监控）</li>
</ul>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul>
<li><strong>生命周期</strong>：<code>onCreate()</code> → <code>onStart()</code> → <code>onResume()</code> → <code>onPause()</code> → <code>onStop()</code> → <code>onDestroy()</code></li>
<li><strong>启动模式</strong>：standard&#x2F;singleTop&#x2F;singleTask&#x2F;singleInstance（逆向时关注任务栈管理）</li>
<li><strong>布局绑定</strong>：通过<code>setContentView()</code>关联XML布局</li>
</ul>
<h3 id="逆向关注点"><a href="#逆向关注点" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>查找<strong>Launcher Activity</strong>（应用入口）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析<code>startActivityForResult()</code>跨组件通信</li>
<li>Hook <code>onActivityResult()</code>获取数据回传逻辑</li>
</ul>
<h2 id="二、Service（服务）"><a href="#二、Service（服务）" class="headerlink" title="二、Service（服务）"></a>二、Service（服务）</h2><h3 id="核心定义-1"><a href="#核心定义-1" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>后台运行组件</strong>，无界面（常驻&#x2F;耗时操作）</li>
<li>两种启动方式：<ul>
<li>**startService()**（长期运行，如音乐播放）</li>
<li>**bindService()**（IPC跨进程通信）</li>
</ul>
</li>
</ul>
<h3 id="生命周期差异"><a href="#生命周期差异" class="headerlink" title="生命周期差异"></a>生命周期差异</h3><ul>
<li><strong>启动式</strong>：<code>onCreate()</code> → <code>onStartCommand()</code> → <code>onDestroy()</code></li>
<li><strong>绑定式</strong>：<code>onCreate()</code> → <code>onBind()</code> → <code>onUnbind()</code> → <code>onDestroy()</code></li>
</ul>
<h3 id="逆向关注点-1"><a href="#逆向关注点-1" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>识别<strong>Foreground Service</strong>（通知栏常驻，需反编译检查通知配置）</li>
<li>分析<code>IntentService</code>的消息处理机制</li>
<li>检测<code>startForeground()</code>防杀保活手段</li>
<li>定位跨进程通信的<strong>AIDL接口</strong></li>
</ul>
<hr>
<h2 id="三、BroadcastReceiver（广播接收器）"><a href="#三、BroadcastReceiver（广播接收器）" class="headerlink" title="三、BroadcastReceiver（广播接收器）"></a>三、BroadcastReceiver（广播接收器）</h2><h3 id="核心定义-2"><a href="#核心定义-2" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>系统&#x2F;应用事件监听器</strong>（如网络变化、短信接收）</li>
<li>两种注册方式：<ul>
<li><strong>静态注册</strong>：AndroidManifest.xml声明（系统广播）</li>
<li><strong>动态注册</strong>：代码中<code>registerReceiver()</code>（应用内广播）</li>
</ul>
</li>
</ul>
<h3 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h3><ol>
<li>发送广播：<code>sendBroadcast(intent)</code></li>
<li>匹配接收器：通过<code>IntentFilter</code>筛选</li>
<li>执行<code>onReceive()</code>逻辑</li>
</ol>
<h3 id="逆向关注点-2"><a href="#逆向关注点-2" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>监控<strong>敏感广播</strong>（如<code>BOOT_COMPLETED</code>开机自启）</li>
<li>分析有序广播的优先级滥用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter android:priority=<span class="string">&quot;1000&quot;</span>&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Hook <code>abortBroadcast()</code>拦截广播传递链</li>
</ul>
<hr>
<h2 id="四、ContentProvider（内容提供者）"><a href="#四、ContentProvider（内容提供者）" class="headerlink" title="四、ContentProvider（内容提供者）"></a>四、ContentProvider（内容提供者）</h2><h3 id="核心定义-3"><a href="#核心定义-3" class="headerlink" title="核心定义"></a>核心定义</h3><ul>
<li><strong>跨应用数据共享</strong>的标准化接口（数据库&#x2F;文件）</li>
<li>通过<strong>URI</strong>标识数据源：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content:<span class="comment">//com.example.provider/user/1</span></span><br><span class="line">↑          ↑                ↑     ↑</span><br><span class="line">协议       包名             表名  记录ID</span><br></pre></td></tr></table></figure>

<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul>
<li><code>query()</code>：查询数据</li>
<li><code>insert()</code>：插入数据</li>
<li><code>update()</code>：更新数据</li>
<li><code>delete()</code>：删除数据</li>
<li><code>getType()</code>：返回MIME类型</li>
</ul>
<h3 id="逆向关注点-3"><a href="#逆向关注点-3" class="headerlink" title="逆向关注点"></a>逆向关注点</h3><ul>
<li>解析<code>&lt;provider&gt;</code>声明中的<strong>权限控制</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;provider </span><br><span class="line">    android:authorities=<span class="string">&quot;com.example.provider&quot;</span></span><br><span class="line">    android:readPermission=<span class="string">&quot;READ_DATA&quot;</span></span><br><span class="line">    android:writePermission=<span class="string">&quot;WRITE_DATA&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>追踪<code>ContentResolver</code>的CRUD操作路径</li>
<li>检测<strong>URI注入漏洞</strong>（未校验外部输入）</li>
</ul>
<h2 id="五、四大组件共性特征"><a href="#五、四大组件共性特征" class="headerlink" title="五、四大组件共性特征"></a>五、四大组件共性特征</h2><h3 id="1-清单文件声明"><a href="#1-清单文件声明" class="headerlink" title="1. 清单文件声明"></a>1. 清单文件声明</h3><p>所有组件必须在<code>AndroidManifest.xml</code>注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.MainActivity&quot;</span>/&gt;</span><br><span class="line">&lt;service android:name=<span class="string">&quot;.MyService&quot;</span>/&gt;</span><br><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyReceiver&quot;</span>/&gt;</span><br><span class="line">&lt;provider android:name=<span class="string">&quot;.MyProvider&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-Intent通信机制"><a href="#2-Intent通信机制" class="headerlink" title="2. Intent通信机制"></a>2. Intent通信机制</h3><ul>
<li><strong>显式Intent</strong>：明确指定组件类名（逆向易追踪）</li>
<li><strong>隐式Intent</strong>：通过Action&#x2F;Category匹配（需反编译查看过滤条件）</li>
</ul>
<h3 id="3-逆向工程切入点"><a href="#3-逆向工程切入点" class="headerlink" title="3. 逆向工程切入点"></a>3. 逆向工程切入点</h3><ul>
<li><strong>入口分析</strong>：定位Launcher Activity和开机广播接收器</li>
<li><strong>协议破解</strong>：监控ContentProvider的数据读写格式</li>
<li><strong>Hook位置</strong>：选择组件生命周期方法注入代码（如Activity的<code>onCreate()</code>）</li>
</ul>
<h2 id="逆向实战技巧"><a href="#逆向实战技巧" class="headerlink" title="逆向实战技巧"></a>逆向实战技巧</h2><ol>
<li><p><strong>快速定位组件</strong>：</p>
<ul>
<li>使用<code>apktool</code>反编译后，在<code>AndroidManifest.xml</code>搜索组件声明</li>
<li>通过<code>jadx-gui</code>查看组件的Java&#x2F;Kotlin实现类</li>
</ul>
</li>
<li><p><strong>动态行为监控</strong>：</p>
<ul>
<li><p>使用<code>logcat</code>过滤组件生命周期日志：</p>
</li>
<li><pre><code class="java">adb logcat | grep -E &quot;ActivityManager|BroadcastRecord&quot;
</code></pre>
</li>
<li><p>Frida Hook <code>android.app.Activity</code>的<code>onCreate()</code>方法</p>
</li>
</ul>
</li>
</ol>
<p>3.<strong>安全漏洞挖掘</strong>：</p>
<ul>
<li>检测<code>exported=true</code>的暴露组件（未授权访问风险）</li>
<li>分析Intent传递的Bundle数据是否缺少校验</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向这档子事</title>
    <url>/2025/03/12/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="一、初识APK"><a href="#一、初识APK" class="headerlink" title="一、初识APK"></a>一、初识APK</h1><h2 id="1-双开及其原理"><a href="#1-双开及其原理" class="headerlink" title="1..双开及其原理"></a>1..双开及其原理</h2><p><strong>双开：简单来说，就是手机同时运行两个或多个相同的应用，例如同时运行两个微信</strong></p>
<table>
<thead>
<tr>
<th align="left">原理</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">修改包名</td>
<td align="left">让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP</td>
</tr>
<tr>
<td align="left">修改Framework</td>
<td align="left">对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开</td>
</tr>
<tr>
<td align="left">通过虚拟化技术实现</td>
<td align="left">虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间</td>
</tr>
<tr>
<td align="left">以插件机制运行</td>
<td align="left">利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp</td>
</tr>
</tbody></table>
<h3 id="2-1-修改包名"><a href="#2-1-修改包名" class="headerlink" title="2.1 修改包名"></a>2.1 修改包名</h3><h4 id="2-1-1-使用工具"><a href="#2-1-1-使用工具" class="headerlink" title="2.1.1 使用工具"></a>2.1.1 使用工具</h4><p>MT管理器和NP管理器，都是Android设备上用于文件管理和系统操作的工具，但它们在功能特点、用户界面以及使用场景上有一些区别。</p>
<p><strong>MT管理器</strong></p>
<p>MT管理器（MT Manager）是一款功能强大的文件管理器，主要用于对APK文件、dex&#x2F;oat&#x2F;smali文件进行编辑，还可以进行文件对比、文本翻译等。它的主要特点包括：</p>
<ul>
<li>支持直接编辑APK文件中的资源文件、smali代码。</li>
<li>提供了丰富的文件操作功能，如复制、粘贴、重命名等。</li>
<li>可以用来汉化应用、修改游戏数据等高级操作。</li>
<li>用户界面相对复杂，更适合有一定技术背景的用户使用。</li>
</ul>
<p><strong>NP管理器</strong></p>
<p>NP管理器（NP Manager）也是一个文件管理器，虽然它也提供了对APK文件的基本编辑能力，但是其主要侧重点在于提供更直观的文件浏览体验和基本的文件管理功能。相比于MT管理器，NP管理器的特点有：</p>
<ul>
<li>界面设计更加简洁直观，适合普通用户进行基础的文件管理任务。</li>
<li>提供了对多种文件格式的支持，如压缩文件(zip, rar)的解压与创建。</li>
<li>功能性上相对于MT管理器来说较为简单，适用于不需要深入编辑apk或系统文件的用户。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>功能深度</strong>：MT管理器在处理复杂的文件编辑和系统级操作方面更为强大；而NP管理器则侧重于提供一个易于使用的文件管理解决方案。</li>
<li><strong>用户界面</strong>：MT管理器的UI更加复杂，包含更多专业化的选项；NP管理器设计得更加友好，适合所有级别的用户。</li>
<li><strong>使用场景</strong>：如果需要对应用程序进行深层次的修改，比如反编译apk文件，则MT管理器是更好的选择。而对于那些仅需要基本文件管理功能的用户来说，NP管理器可能更加合适。</li>
</ul>
<p>根据实际需求应用，有的功能需要VIP……</p>
<h4 id="2-1-2-操作"><a href="#2-1-2-操作" class="headerlink" title="2.1.2 操作"></a>2.1.2 操作</h4><p>将MT管理器、NP管理器以及练手demo安装至安卓模拟器</p>
<p>由于MT管理器双开需要会员，所以选择NP管理器。进入NP管理器软件，点击左上角的三根杠，选择安装包提取。</p>
<p>然后选择需要提取的软件</p>
<p> —&gt; 提取安装包—&gt; 定位 —&gt;点击软件 —&gt;功能—&gt;APK共存</p>
<p>最后确认，此时便有了该软件的安装包，通过带点击下方提取出来的安装包，进行安装，桌面上便有了新的一个demo软件</p>
<p>注意这个地方，提取出来后，两个包的包名不一样</p>
<p>由于该方法是通过修改包名实现的，所以懂了应用的签名信息，如果开发者做了一个签名校验，那就很有可能安装后软件出现闪退奔溃的情况。</p>
<h2 id="3-汉化"><a href="#3-汉化" class="headerlink" title="3.汉化"></a>3.汉化</h2><p><strong>汉化：使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化</strong></p>
<p>基本上字符串都是在arsc里，建议一键汉化，然后再润色。<br>少量没汉化到的字符串参考视频中的方法定位去逐个汉化。</p>
<p>流程图</p>
<p>可以使用MT管理器，进入demo的apk文件中，进行搜索需要修改句子对应的文件所在位置，使用搜索，点击高级搜索可以进入全局搜索。查找到文件位置后进入文件，手动修改句子，翻译为中文。真的累。</p>
<p>修改后会出现一个签名改动的问题，可以直接卸载了再安装，或者核心破解。</p>
<h2 id="4-初识AndroidManifest-xml"><a href="#4-初识AndroidManifest-xml" class="headerlink" title="4.初识AndroidManifest.xml"></a>4.初识AndroidManifest.xml</h2><p>AndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">versionCode</td>
<td align="left">版本号，主要用来更新，例如:12</td>
</tr>
<tr>
<td align="left">versionName</td>
<td align="left">版本名，给用户看的，例如:1.2</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包名，例如：com.zj.52pj.demo</td>
</tr>
<tr>
<td align="left">uses-permission android:name&#x3D;””</td>
<td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td>
</tr>
<tr>
<td align="left">android:label&#x3D;”@string&#x2F;app_name”</td>
<td align="left">应用名称</td>
</tr>
<tr>
<td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td>
<td align="left">应用图标路径</td>
</tr>
<tr>
<td align="left">android:debuggable&#x3D;”true”</td>
<td align="left">应用是否开启debug权限</td>
</tr>
</tbody></table>
<h1 id="二、初识smail"><a href="#二、初识smail" class="headerlink" title="二、初识smail"></a>二、初识smail</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>安卓逆向工程</tag>
        <tag>吾爱破解</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware虚拟机</title>
    <url>/2025/02/20/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="📚专业术语"><a href="#📚专业术语" class="headerlink" title="📚专业术语"></a>📚专业术语</h2><p>.iso：是电脑上光盘镜像（CD Mirror）的存储格式之一，因为其是i根据ISO-9660有关CD-ROM文件系统标准存储的文件，许哦一通常在电脑中以后缀,iso命名，俗称iso镜像文件。</p>
<p>镜像文件：镜像文件可以类比为图书馆的一本书的副本。一本珍贵的书，想要确保即使在原书损坏或丢失的情况下，书的内容仍然可以得到保留和使用。为此，制作了这本书的精确复制品，这个复制品包含了原书的所有页面和文字，但它可能是以特殊的格式存储的，比如扫描后的PDF文件或者一系列图片。</p>
<h2 id="🖥创建新的虚拟机"><a href="#🖥创建新的虚拟机" class="headerlink" title="🖥创建新的虚拟机"></a>🖥创建新的虚拟机</h2><h3 id="1-Window系统"><a href="#1-Window系统" class="headerlink" title="1.Window系统"></a>1.Window系统</h3><p>点击软件首页的创建新的虚拟机，进入新建导向</p>
<p>选择自定义（高级）然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206165405761.png"></p>
<p>硬件兼容性选择软件版本，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182831247.png"></p>
<p>选择安装程序光盘映像文件（iso），选择安装好的光盘映像文件，可以去微软官网上去下载，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182926495.png"></p>
<p>完成windows简易安装信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206182950623.png"></p>
<p>对新建的虚拟机进行命名，名字注意区分其他并易懂，还有保存位置，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183009197.png"></p>
<p>选择虚拟机的固件类型，即引导设备，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183034037.png"></p>
<p>选择虚拟机处理器配置，处理器数量、每个处理器的内核数量，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183051953.png"></p>
<p>设置虚拟机的内存，不要太大也不要太小，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183110891.png"></p>
<p>选择网络模式，使用网络地址转换（NAT），然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183132574.png"></p>
<p>选择I&#x2F;O控制器类型，按照新建向导的推荐选择，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206183147255.png"></p>
<p>选择磁盘类型，按照新建向导的推荐选择，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122431324.png"></p>
<p>选择磁盘容量，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122452975.png"></p>
<p>确定号新建的虚拟机的设置信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250207122514411.png"></p>
<p>至此，Windows10虚拟机创建成功，等待启动然后设置，激活系统。</p>
<h3 id="2-Linux系统"><a href="#2-Linux系统" class="headerlink" title="2.Linux系统"></a><strong>2.Linux系统</strong></h3><p>点击软件首页的创建新的虚拟机，进入新建导向</p>
<p>选择自定义（高级）然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206163543615.png"></p>
<p>保持默认不变，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206163649773.png"></p>
<p>选择稍后安装操作系统，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164001987.png"></p>
<p>在选择客户机i操作系统时选择Linux系统，版本选择自己准备的ISO文件的版本，一定要匹配，然后单击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164041840.png"></p>
<p>给本虚拟机命名，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164349880.png"></p>
<p>处理器配置，为虚拟机指定处理器数量，设置为2，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164527143.png"></p>
<p>设置内存，一般两个G，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206164616967.png"></p>
<p>后续一直保持默认推荐，然后点击下一步</p>
<p>确认新建虚拟机的基本信息，然后点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206165452662.png"></p>
<p>至此虚拟机的创建已完成，然后检查一下网络配置</p>
<p>点击编辑&gt;虚拟网络编辑器，查看VMnet8，子网的ip地址是否和NAT设置中的ip地址前三位一致。正常来说是默认配置好的。只是检查以下，不是乱去设置。</p>
<p>接下来去给<strong>虚拟机配置镜像</strong>。</p>
<p>点击编辑虚拟机设置&gt;CD&#x2F;DVD&gt;选择使用镜像文件，点击浏览找到提前下载好的镜像文件，然后点确定，完成后点击开启虚拟机。</p>
<p>然后点击install CentOS，选项变白就是选中了</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206170409114.png"></p>
<p>然后选中想要的语言，选择简体中文就行,点击继续</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206170558494.png"></p>
<p>进入安装信息摘要基本不用改，完成以下安装位置确认，然后点击安装。设置Root密码。创建用户根据个人需要，就是权限比较低的用户。</p>
<p>至此安装成功，点击重启就行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171032438.png"></p>
<p>注意进入后输入用户和密码，密码是不会显示的，输完后回车就行，出现root@localhost就是成功了。</p>
<p>输入cd &#x2F;，再输入ll，查看所有文件。(注意cd 后面要有一个空格)</p>
<p>接下来配置虚拟机的网络。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-06%20171537.jpg"></p>
<p>手动输入，以下路径，虚拟机内无法复制粘贴</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171841943.png"></p>
<p>然后找到ifcfg-ens33，打开它编辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206171953000.png" alt="image-20250206171953000"></p>
<p>使用vi ifcfg-ens33，进入修改。按i，进入修改模式，将BOOTPROTO&#x3D;dhcp（默认），ONBOOT修改为yes。然后按esc退出修改模式。输入:wq，回车强制保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250206172438904.png"></p>
<p>接下来就是去重启网络，service network restart，然后测试是否能访问外网，ping一下百度，出现连接网速表示成功，ctrl+c结束。</p>
<p>后续参考视频【【2024最新】Vmware虚拟机安装Linux系统及配置网络超详细教学安装Centos使用Vmare安装附带安装包及镜像】<a href="https://www.bilibili.com/video/BV1MriFeaEci?vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc">https://www.bilibili.com/video/BV1MriFeaEci?vd_source=cbd0e7aa3299fa0fcc330c5ee16869bc</a></p>
<h2 id="📺操作系统的操作模式"><a href="#📺操作系统的操作模式" class="headerlink" title="📺操作系统的操作模式"></a>📺操作系统的操作模式</h2><p>对操作系统的使用，有2种使用形式：</p>
<ul>
<li><p>图形化页面使用操作系统</p>
</li>
<li><p>以命令的形式使用操作系统</p>
</li>
</ul>
<p>不论是Windows系统还是Linux系统或是MacOS系统，以获得图形化反馈的形式去使用操作系统。</p>
<ul>
<li><p>图形化：使用操作系统提供的图形化页面，以获得图形化反馈形式去使用操作系统。</p>
</li>
<li><p>命令行：使用操作系统提供的各类命令，以获得字符反馈的形式去使用操作系统。</p>
</li>
</ul>
<p>无论是企业开发亦或是个人开发，使用Linux擦欧总系统，多数都是使用的：命令行。</p>
<p>这是因为：</p>
<ul>
<li>Linux从诞生至今，在图形化页面的优化上，并未重点发力。所以LInux操作系统的图形化页面：不好用、不稳定。</li>
<li>在开发中，使用命令行形式，效率更高，更加直观，并且资源占用低、程序运行更稳定。</li>
</ul>
<h2 id="💻网络连接的三种模式"><a href="#💻网络连接的三种模式" class="headerlink" title="💻网络连接的三种模式"></a>💻网络连接的三种模式</h2><h3 id="1-桥接模式：直接连接物理网络"><a href="#1-桥接模式：直接连接物理网络" class="headerlink" title="1.桥接模式：直接连接物理网络"></a>1.桥接模式：直接连接物理网络</h3><p>使用主机中的物理网卡VMnet0，有线网卡或者无线网卡，可以连接主机，并且可以访问局域内的计算机，如果主机可以连接外网，虚拟机也可以连接外网，此时物理主机相当于一个交换机，把所有桥接模式的虚拟机都连接在同一个交换机上，自己在这个局域网中。注意：容易造成IP冲突。</p>
<h3 id="2-NAT模式：用于共享主机的IP地址"><a href="#2-NAT模式：用于共享主机的IP地址" class="headerlink" title="2.NAT模式：用于共享主机的IP地址"></a>2.NAT模式：用于共享主机的IP地址</h3><p>使用的是虚拟机的网卡VMnet8，可以连接主机，也可以来连接外网，虚拟机IP地址经过NAT转换，与物理机IP地址不在同一网段，所以不能访问局域网内的计算机。</p>
<h3 id="3-仅主机模式：与主机共享的专用网络"><a href="#3-仅主机模式：与主机共享的专用网络" class="headerlink" title="3.仅主机模式：与主机共享的专用网络"></a>3.仅主机模式：与主机共享的专用网络</h3><p>使用的是虚拟机中的VMnet1，可以连接到主机，不能访问局域网内的计算机，也不能连接外网，当我们要组成一个与物理网络相隔离的虚拟网络时可以选择仅主机模式。</p>
<h2 id="📼虚拟机克隆"><a href="#📼虚拟机克隆" class="headerlink" title="📼虚拟机克隆"></a>📼虚拟机克隆</h2><p>如果已经安装了一台linux操作系统，还想再更多的，没必要再重新安装，只需要克隆就行。</p>
<h3 id="1-直接拷贝一份安装好的虚拟机文件"><a href="#1-直接拷贝一份安装好的虚拟机文件" class="headerlink" title="1.直接拷贝一份安装好的虚拟机文件"></a>1.直接拷贝一份安装好的虚拟机文件</h3><p>将虚拟机文件拷贝到另一个盘的文件夹下，文件名可以重命名，也可以保留原名。通过VMware的打开文件，打开拷贝虚拟机文件。</p>
<h3 id="2-使用VMware的克隆操作"><a href="#2-使用VMware的克隆操作" class="headerlink" title="2.使用VMware的克隆操作"></a>2.使用VMware的克隆操作</h3><p>注意：克隆时，需要先关闭正在运行的linux系统。</p>
<p>虚拟机&gt;右键至管理&gt;克隆</p>
<p>克隆类型有两种：创建链接克隆、创建完整克隆。</p>
<p>创建链接克隆，是对原虚拟机的引用，所需要的存储磁盘空间较少，访问的是原虚拟机，是同一个系统。</p>
<p>创建完整克隆：是原虚拟机当前状态的完整副本，此选项使得虚拟机完全独立，需要较多的存储磁盘空间。</p>
<h2 id="📷虚拟机快照"><a href="#📷虚拟机快照" class="headerlink" title="📷虚拟机快照"></a>📷虚拟机快照</h2><p>如果在使用虚拟机系统的时候，想回到原先的某一个状态，也就是说担心有些操作造成系统异常，需要回到原先某个正常运行的状态，VMware提供了一个这样的功能，就叫做快照管理。</p>
<p>推荐关机操作，没关机也可以就是会时间久一点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250210163939993.png"></p>
<h1 id="kali-linux配置"><a href="#kali-linux配置" class="headerlink" title="kali linux配置"></a>kali linux配置</h1><p>参考：</p>
<p><a href="https://blog.csdn.net/m0_74030222/article/details/143866270">kali Linux下载安装及配置（VMware虚拟机）</a></p>
<h2 id="1-源文件的安装"><a href="#1-源文件的安装" class="headerlink" title="1.源文件的安装"></a>1.源文件的安装</h2><p>位置：&#x2F;etc&#x2F;apt&#x2F;sources.list<br>首先第一步<br>输入命令：cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</p>
<p>目的是将原来的sources的文件复制备份出一部分，然后再在原来的基础上修改内容。</p>
<p>输入命令：vim &#x2F;etc&#x2F;apt&#x2F;sources.list<br>目的是用<a href="https://so.csdn.net/so/search?q=vim%E7%BC%96%E8%BE%91%E5%99%A8&spm=1001.2101.3001.7020">vim编辑器</a>进行编辑<br>（在出现的界面中输入字母“i”或者键盘上“insert”,这是“插入”的意思，当显示出下面汉字“插入”时就可以输入了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">国内常用的几个源文件：</span><br><span class="line"> </span><br><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib </span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line"> #阿里云</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib </span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line"> #清华大学</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line"> #浙江大学</span><br><span class="line">deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free </span><br><span class="line">deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>

<p>由于里面的安装源是kali官网，对于国内而言下载的速度比较缓慢，所以把kali官网的安装源用“#”注释掉。</p>
<p>用vim编辑器编写完成之后，按键盘上的“esc”键，退出之后，输入“：”冒号，然后输入wq，代表保存，并退出。</p>
<h2 id="2-软件的更新-安装与删除"><a href="#2-软件的更新-安装与删除" class="headerlink" title="2.软件的更新 安装与删除"></a>2.软件的更新 安装与删除</h2><p>输入命令：apt-get updates 下载最新的安装包<br>输入命令：apt-get upgrade 系统会打开最新的安装包，并将软件安装的系统中<br>输入命令：apt-get clean 会将之前旧的安装包删除，清理内存<br>以上步骤不要着急，慢慢来</p>
<h2 id="3-设置锁屏时间"><a href="#3-设置锁屏时间" class="headerlink" title="3.设置锁屏时间"></a>3.设置锁屏时间</h2><p>设置锁屏时间非常重要，将锁屏的时间设置为“从不”，因为这样不会导致程序在运行的过程中由于锁屏的原因而停止运行。</p>
<h2 id="4-配置ssh服务"><a href="#4-配置ssh服务" class="headerlink" title="4.配置ssh服务"></a>4.配置ssh服务</h2><p>位置：&#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>输入命令：vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config<br>将下面的命令改为yes</p>
<p>PermitRootLogin yes 允许管理员登陆<br>PasswordAuthentication yes 密码验证改为yes</p>
<p>修改完成之后保存并退出</p>
<p>输入命令：service ssh start 开启ssh服务<br>输入命令：update-rc.d ssh enable 设置为开机自启动</p>
]]></content>
      <tags>
        <tag>软件</tag>
        <tag>VMware</tag>
        <tag>Linux系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora的使用</title>
    <url>/2025/01/24/Typora%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[史上最全Typora教程—-程序员必学软件之一-CSDN博客](<a href="https://blog.csdn.net/m0_62648611/article/details/133713273#:~:text=%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Typora%E6%95%99%E7%A8%8B----%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B9%8B%E4%B8%80">https://blog.csdn.net/m0_62648611/article/details/133713273#:~:text=史上最全Typora教程----程序员必学软件之一</a> 1 1. 标题 一级标题：Ctrl%2B1 或%23 二级标题：Ctrl%2B2 或%23%23,代码 插入不确定编程语言代码，快捷键：CTRL%2Bshift%2Bk 插入确定语言代码， &#96;&#96;&#96; 语言名称 如： … 更多项目)</p>
<p>存在待补充</p>
<h2 id="Typora是什么？"><a href="#Typora是什么？" class="headerlink" title="Typora是什么？"></a>Typora是什么？</h2><p>​		Typora是一款由Abner Lee开发的轻量级Markdown编辑器，适用于OS X、Windows和Linux三种操作系统，是一款免费软件。与其他Markdown编辑器不同的是，Typora没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式</p>
<span id="more"></span>


<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a><strong>1.标题</strong></h4><p>快捷键，Ctrl+数字（1、2、3、4、5、6），一共六个数字由大到小六个标题等级。</p>
<h4 id="2-文本"><a href="#2-文本" class="headerlink" title="2.文本"></a><strong>2.文本</strong></h4><h6 id="2-1-分割线"><a href="#2-1-分割线" class="headerlink" title="2.1 分割线"></a>2.1 分割线</h6><p>三个+++、***、或—，如下：</p>
<hr>
<h6 id="2-2-下划线"><a href="#2-2-下划线" class="headerlink" title="2.2 下划线"></a>2.2 下划线</h6><p>Ctrl+U或&lt; u &gt;标签包住文本，如：<u>kedai</u></p>
<h6 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h6><p>Alt+Shift+5或使用一对 “ ~ “符号包括文本，如：<del>kedai</del></p>
<h6 id="2-4-斜体"><a href="#2-4-斜体" class="headerlink" title="2.4 斜体"></a>2.4 斜体</h6><p>Ctrl+l、或使用一对 “ _ “符号包括文本，如：<em>kedai</em></p>
<h6 id="2-5-粗体"><a href="#2-5-粗体" class="headerlink" title="2.5 粗体"></a>2.5 粗体</h6><p>Ctrl+B、使用一对 “ ** “符号包括文本、或使用一对 “ __ “符号包括文本，如：<strong>kedai</strong></p>
<h6 id="2-6-粗体倾斜"><a href="#2-6-粗体倾斜" class="headerlink" title="2.6 粗体倾斜"></a>2.6 粗体倾斜</h6><p>使用一对三个“ * ” 符号包括文本，如：<em><strong>kedai</strong></em></p>
<h6 id="2-7-设置字体颜色及大小"><a href="#2-7-设置字体颜色及大小" class="headerlink" title="2.7 设置字体颜色及大小"></a>2.7 设置字体颜色及大小</h6><p>&lt; font size&#x3D;2 color&#x3D;”yellow” &gt;设置字体大小为2，颜色为黄色&lt; &#x2F;font  &gt; ，如：<font size=2 color="yellow">kedai</font> </p>
<h6 id="2-8-设置字体高亮"><a href="#2-8-设置字体高亮" class="headerlink" title="2.8 设置字体高亮"></a>2.8 设置字体高亮</h6><p>使用一对“ &#x3D;&#x3D; ”符号包括文本，如：&#x3D;&#x3D;kedai&#x3D;&#x3D;</p>
<h6 id="2-9-文本对齐"><a href="#2-9-文本对齐" class="headerlink" title="2.9 文本对齐"></a>2.9 文本对齐</h6><p>&lt; p align&#x3D;”lift” &gt;左对齐&lt; &#x2F;p &gt;</p>
<p align="lift">左对齐</p>

<p>&lt; p align&#x3D;”center” &gt;居中对齐&lt; &#x2F;p &gt;</p>
<p align="center" >居中对齐</p >

<p>&lt; p align&#x3D;”right” &gt;左对齐&lt; &#x2F;p &gt;</p>
<p align="right" >右对齐</p >

<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a><strong>3.插入</strong></h4><h6 id="3-1链接文字"><a href="#3-1链接文字" class="headerlink" title="3.1链接文字"></a>3.1链接文字</h6><p>① 当链接地址为外部地址时，格式：[ 链接文字 ] (src“描述链接”) ，其中的描述可以写也可以不写。快捷键为Ctrl+K，用Ctrl+鼠标左键点击进入链接。如：<a href="https://taobao.com/">这是一个淘宝链接</a></p>
<p>② 当链接地址为本地地址时，其中本地地址可以是相对地址和绝对地址</p>
<ul>
<li><p>绝对地址 格式：[ 绝对地址 ] (src “本地地址链接”)，用Ctrl+鼠标左键点击进入链接，上传远程后是没有效果的。</p>
</li>
<li><p>相对地址 格式：[ 相对地址\ ] ( src “&#x2F;标题.png”)，其中.&#x2F;代表.md文件所在的地址…&#x2F;表示的是.md文件的上级地址。</p>
</li>
</ul>
<h6 id="3-2图片"><a href="#3-2图片" class="headerlink" title="3.2图片"></a>3.2图片</h6><p>一共有四种方式</p>
<p>①外部链接 </p>
<p>格式：！[ alt ] (src)，快捷键：Ctrl+Shift+l</p>
<p>和链接文件、文档差不多，指示在前面加了一个！。alt：是图片的注释（可以为空），src：既可以是本地图片的绝对&#x2F;相对路径。</p>
<p>②html标签 </p>
<p>格式：&lt; img src&#x3D;”.&#x2F;图片演示.png” alt&#x3D;”替代文本” title&#x3D;”图片标题” width&#x3D;”200” height&#x3D;”200” &gt;</p>
<p>width和height设置大小，align设置位置，style中margin设置外边距、border设置边框</p>
<p>③本地文件 </p>
<p>格式：！[ alt ] (src)</p>
<p>直接拖拽、复制就行，也可以进行图片链接。拖拽和复制本质上和第一种图片链接是一样的。但是Typora默认的是绝对地址，图片没有复制到.md文件同一目录下。如果移动了.md文件或者图片位置，都会丢失图片。</p>
<p>④ TYpora支持从剪贴板中粘贴图片，但是因为 Markdown 文件是纯文本文件，所以用户无法在 Markdown 文件中直接插入图片文件，而是通过在 Markdown 文件中引用文件路径或者 URL 的方式插入图片，所以默认情况下，Typora 会先将文件保存到一个固定的目录，在 Windows 上，是保存到~\AppData\Roaming\Typora\typora-user-images\目录下。</p>
<p>所以需要修改设置（文件 &gt; 偏好设置 &gt; 图像 &gt; 对本地位置的图片应用上述规则 &gt; 下拉勾选其中一个）</p>
<p>第一个选项 [无特殊操作]，是默认选项。</p>
<p>第二个选项 [复制图片到当前文件夹（.&#x2F;）]，意思就是在插入图片时，将图片复制到正在编辑的Markdown文件所在的目录下。</p>
<p>第三个选项 [复制图片到.&#x2F;filename.assets文件夹]，意思是在插入图片时，会在当前目录下创建一个名为“{filename.asset}”的文件夹，然后把图片保存在这个文件夹下，其中${filename}&#96;指的是当前你正在编辑的Markdown文件的文件名。</p>
<p>第四个选项 [上传图片]，就是在你插入图片时，使用图片上传服务将图片上传到服务器。</p>
<p>第五个选项 [复制到指定路径]，选择该选项后，会出现一个输入框输入保存图片的路径，这里也就是使用${filrname}来指代当前编辑的Markdowan文件的文件名，也可以点击右边的文件夹按钮在弹出的对话框中选择一个路径。</p>
<p>因为如果在 Markdown 文件中使用了图片，那说明这张图片和写的东西是有关联的，那最好把图片和 Markdown 文件放在一起，这样也便于以后查找。还要注意的是，如果选择了[复制图片到当前文件夹（.&#x2F;）]，那么要把下面的[优先使用相对路径]选项勾选上，这样，Typora 在引用图片时就会使用相对路径，以后即使移动 Markdown 文件到别的目录下，只要图片随着 Markdown 文件一起移动， Typora 就永远都能找到这张图片。再配合[上传图片]，就能使 Markdown 文件的维护成本最小化。</p>
<h6 id="3-3表格"><a href="#3-3表格" class="headerlink" title="3.3表格"></a>3.3表格</h6><p>插入表格可以使用代码的方式插入，但是感觉太麻烦了。采用快捷键Ctrl+T</p>
<h4 id="4-上传图片-详细说明"><a href="#4-上传图片-详细说明" class="headerlink" title="4.[上传图片] 详细说明"></a><strong>4.[上传图片] 详细说明</strong></h4><p>如果src是 URL 的话，你在分享的时候只要分享一个 Markdown 文件就可以了，只要能联网，Markdown 的渲染引擎就能根据 URL 找到你引用的图片。</p>
<p>要想把本地的图片路径转换成 URL，就得把图片上传到网络上某个位置，然后拿到这个图片的 URL。使用[Typora + 第三方图片上传服务]就可以自动完成这一操作。</p>
<p><strong>⚠警告：</strong></p>
<p><u><em>Typora是通过调用第三方的软件实现图片上传的，它本身并不会上传图片，提供存储图片服务的也是第三方的云存储服务，它们并不属于Typora。所以在使用上传图片功能的时候，要注意这些第三方服务的许可证书、用户协议、服务稳定性以及可靠性。</em></u></p>
<p><u><em>在偏好设置中开启上传图片的功能后，Typora 会将要上传的图片发送给第三方图片上传软件，然后他们会把你的图片上传到第三方（甚至是第四方）图床，Typora 不会控制这个过程，也无法保证这个过程的顺利，所以一定要选择一个可靠的服务来保证数据的安全。</em></u></p>
<p><u><em>除了隐私和可靠性问题，你还需注意，有些服务在保存图片时可能会设置过期时间；有些服务没有提供 [删除] 的功能，即使你不小心上传了敏感图片；有些服务遵守的不是你所在国家的法律，可能会封禁一些特定国家的特定类型的图片或者用户等等。</em></u></p>
<p><u><em>总而言之，在选择某个图片上传应用及服务之前，一定要仔细阅读他们的用户手册。</em></u></p>
<p>配置：</p>
<p>在偏好设置面板中可以开启并配置图片上传服务，Typora支持以下图片上传服务：</p>
<ul>
<li>PicGo.app (macOS &#x2F; Windows &#x2F; Linux, 只有简体中文版)</li>
<li>PicGo (命令行应用) (Windows &#x2F; Linux)</li>
<li>自定义 (macOS &#x2F; Windows &#x2F; Linux)</li>
</ul>
<p>在选择了其中一个上传服务后，你需要下载并安装相应的应用，做一些简单的配置，比如你想使用那个云存储服务来保存上传的图片，然后点击 [验证图片上传选项]，验证Typora使用当前服务和配置是否能上传本地图片。</p>
<p>点击 [验证图片上传选项] 按钮后，Typora会尝试使用当前服务和配置上传图片，如果出现 [验证成功] 的对话框，说明图片上传服务可以用了。如果显示的时 [验证失败] 的对话框，有可能时你电脑上还没有安装相应的服务或者网络问题，可以根据对话框中的提示进行检查。</p>
<p><strong><u>Typora + PicGo + Gitee&#x2F;GitHub 搭建个人图床，实现图片上传。</u></strong></p>
<p>Typora 的作用</p>
<p>具有对图片路径进行管理和转换的功能。当用户在 Typora 中插入图片时，它可以将图片的本地路径转换为符合 Markdown 语法的链接形式。而且 Typora 可以与 PicGo 进行集成，将图片上传的操作集成到其操作流程中，使得用户在撰写文档插入图片时，能够直接调用 PicGo 进行图片上传，而无需额外切换到其他工具进行上传操作。</p>
<p>PicGo 的作用</p>
<p>PicGo 是一个专门用于图片上传的工具，它支持多种图床平台，其核心原理是通过调用不同图床平台的 API，将本地图片数据以二进制流等形式发送到对应的图床服务器上。_在与 Typora 和 Gitee&#x2F;GitHub 配合时，PicGo 充当了桥梁的角色。_当在 Typora 中触发图片上传操作时，PicGo 会获取到图片的本地路径和相关信息，然后根据用户在 PicGo 中配置的 Gitee 或 GitHub 图床参数，将图片数据按照相应平台的要求进行格式化和封装，再通过 HTTP 请求等方式将图片上传到 Gitee 或 GitHub 的仓库中。上传成功后，PicGo 会获取到图片在 Gitee 或 GitHub 上的访问链接，并将这个链接返回给 Typora，以便 Typora 将其插入到 Markdown 文档中，实现图片的引用。</p>
<p>Gitee&#x2F;GitHub 的作用</p>
<p>GitHub 本质上是代码托管平台，但它们也可以用于存储图片等静态资源。它们提供了版本控制、仓库管理等功能，用户可以在上面创建仓库来存储各种文件。当 PicGo 将图片上传到  GitHub 仓库时，实际上是利用了这些平台的文件存储功能。这些平台会为每个上传的文件分配一个唯一的存储位置，并生成一个对应的访问链接。这个链接遵循平台的特定规则，通过这个链接，用户可以在互联网上访问到存储在  GitHub 仓库中的图片资源。同时， GitHub 都有一定的免费存储空间和流量额度，这使得用户可以在一定范围内免费使用它们来搭建个人图床，存储和分享自己的图片。</p>
<p><strong>步骤：</strong></p>
<h5 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a><strong>配置GitHub</strong></h5><p>创建一个新的仓库用来保存图片。</p>
<p>选择<u>Add a README file</u>。注意确保选择”<u>Public</u>“，否则之后再外部访问图床中的图片，会由于没有权限导致访问失败。</p>
<p>在个人设置中，选择“<u>Developer settings</u>”。</p>
<p>随后，选择“<u>Personal access tokens</u>”，并选择其中下方的“<u>Tokens (classic)</u>”；随后，选择右上角“<u>Generate new token</u>”，并再选择“<u>Generate new token (classic)</u>”。</p>
<p>随后，在弹出的配置界面中，首先填写“<u>Note</u>”，这个是当前token的注释，也用一个和图片有关的名称来填写即可；随后，配置token的有效期。其实我们可以将有效期选择为永久，但是<u>GitHub</u>官方强烈不推荐这种<u>永久</u>期限的token，因此可以选择 <u>90</u>天，之后过期了我们继续来设置新的有效期就好。随后，配置勾选项，我这里是将全部的勾选项都选中了，但是其实只要保证 <u>repo</u> 开头的勾选项选中即可。</p>
<p>接下来，即可看到此时token的序号已经获取了，如下图所示。这里大家一定需要<u>保存一下当前的序号</u>，之后就看不到这个序号了。</p>
<p>至此，我们就完成了GitHub上的配置操作。</p>
<h5 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a><strong>配置PicGo</strong></h5><p>将图片上传到GitHub中。下载地址：<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a></p>
<p>随后，<u>安装PicGo</u>并打开，如下图所示。其中，我们需要在“<u>图床设置</u>”中找到“<u>GitHub</u>”，并配置各项信息。其中，<u>仓库名</u>就是我们前面创建的<u>Repository的名称</u>；Token就是前面我们获取的token序号；存储路径这里我们可以空着，如果大家需要指定将图片存储到仓库中的某个路径下，就在这里设置即可；分支名由于github网站的调整，仓库的默认分支名称需要修改为<u>main</u>。随后的自定义域名，可以填写<a href="https://cdn.jsdelivr.net/gh/%E2%80%9C%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9D/%E2%80%9C%E4%BB%93%E5%BA%93%E5%90%8D%E2%80%9D@master%E3%80%82">https://cdn.jsdelivr.net/gh/“用户名”/“仓库名”@master。</a></p>
<h5 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a><strong>配置Typora</strong></h5><p>在“<u>文件</u>”中选择“<u>偏好设置…</u>”，随后选择“<u>图像</u>”，下拉选择“<u>上传图片</u>”，勾选“<u>对本地位置的图片应用上述规则</u>”、“<u>插入是自动转义图片URL</u>”。</p>
<p>随后，选择“<u>验证图片上传选项</u>”，如果出现验证成功窗口，则表明成功配置完毕。</p>
<h5 id="上传方式"><a href="#上传方式" class="headerlink" title="上传方式"></a><strong>上传方式</strong></h5><p><strong>全局设置</strong></p>
<p>在偏好设置面板中，[插入图片时…] 下方的下拉框中，选择 [上传图片] 选项，Typora就会在你插入图片时自动上传。如果只想上传本地图片，那么就只勾选 [对本地位置的图片应用上述规则] ，如果插入的图片本来就位于网络上，但是你想再上传一遍图床，那就把 [对网络位置的图片应用上述规则] 也勾选上。</p>
<p><strong>针对每一个文件单独设置</strong></p>
<p>手下需要勾选上偏好设置面板中的 [允许根据YAML设置自动上传图片] ，然后，如果你的Markdown文件再TYAML中包含如下配置：</p>
<p><code>typora-copy-image-to: upload</code></p>
<p>当插入图片时，Typora会使用这个选项自动上传图片。</p>
<p>或者可以在菜单栏中点击 格式 &gt; 图像 &gt; 当插入本地图片时…  插入YAML配置，开启这个功能。</p>
<p><strong>上传指定的图片</strong></p>
<p>可以在Typora中，右击点击要上传的图片，选择 [上传图片] 。</p>
<p><strong>上传所有本地图片</strong></p>
<p>如果文件中含有大量的本地图片，想要一次性都上传，可以点击菜单栏中的 格式 &gt; 图像 &gt; 上传所有本地图片 。</p>
<h4 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5.快捷键"></a><strong>5.快捷键</strong></h4><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>新建一个新的窗口</td>
<td>Ctrl+N</td>
</tr>
<tr>
<td>创建一个新的窗口</td>
<td>Ctrl+Shift+N</td>
</tr>
<tr>
<td>打开资源管理器（初始在.md文件）</td>
<td>Ctrl+O</td>
</tr>
<tr>
<td>快速打开近期使用过的Markdown文件搜索框</td>
<td>Ctrl+P</td>
</tr>
<tr>
<td>保存</td>
<td>Ctrl+S</td>
</tr>
<tr>
<td>保存为（另存为）</td>
<td>Ctrl+Shift+S</td>
</tr>
<tr>
<td>打开偏好设置界面</td>
<td>Ctrl+,</td>
</tr>
<tr>
<td>关闭当前窗口</td>
<td>Ctrl+W</td>
</tr>
<tr>
<td>开始一个新段落</td>
<td>Enter</td>
</tr>
<tr>
<td>开始一个新行</td>
<td>Shift+Enter</td>
</tr>
<tr>
<td>复制选中的文本为Markdown语言</td>
<td>Ctrl+Shift+C</td>
</tr>
<tr>
<td>将复制的内容以纯文本的格式粘贴</td>
<td>Ctrl+Shift+V</td>
</tr>
<tr>
<td>在段落内选中一句\在表内选中一行</td>
<td>Ctrl+L</td>
</tr>
<tr>
<td>删除表中的一行</td>
<td>Ctrl+Shift+Backspace</td>
</tr>
<tr>
<td>选中一个段元格</td>
<td>Ctrl+E</td>
</tr>
<tr>
<td>选择一个单元格</td>
<td>Ctrl+D</td>
</tr>
<tr>
<td>跳转到文章最顶部</td>
<td>Ctrl+Home</td>
</tr>
<tr>
<td>跳转到文章底部</td>
<td>Ctrl+End</td>
</tr>
<tr>
<td>跳转到光标所在位置</td>
<td>Ctrl+J</td>
</tr>
<tr>
<td>删除一个单词</td>
<td>Ctrl+Shift+D</td>
</tr>
<tr>
<td>查找</td>
<td>Ctrl+F</td>
</tr>
<tr>
<td>查找已经查找的的上一个单词</td>
<td>Shift+F3\Shift+Enter</td>
</tr>
<tr>
<td>查找当前查找的的下一个单词</td>
<td>F3\Enter</td>
</tr>
<tr>
<td>替换</td>
<td>Ctrl+H</td>
</tr>
<tr>
<td>设置文本为标题1-6</td>
<td>Ctrl+ 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td>
</tr>
<tr>
<td>设置文本为段落</td>
<td>Ctrl+0</td>
</tr>
<tr>
<td>给标题升1级</td>
<td>Ctrl+&#x3D;</td>
</tr>
<tr>
<td>给标题降1级</td>
<td>Ctrl±</td>
</tr>
<tr>
<td>插入表</td>
<td>Ctrl+T</td>
</tr>
<tr>
<td>插入代码块</td>
<td>Ctrl+Shift+k</td>
</tr>
<tr>
<td>插入数学符号的文本</td>
<td>Ctrl+Shift+M</td>
</tr>
<tr>
<td>插入引用代码</td>
<td>Ctrl+Shift+Q</td>
</tr>
<tr>
<td>插入有序列表</td>
<td>Ctrl+Shift+[</td>
</tr>
<tr>
<td>插入无序列表</td>
<td>Ctrl+Shift+]</td>
</tr>
<tr>
<td>缩进</td>
<td>Tab \ Ctrl+[</td>
</tr>
<tr>
<td>取消缩进</td>
<td>Shift+Tab \ Ctrl+]</td>
</tr>
<tr>
<td>加粗字体</td>
<td>Ctrl+B</td>
</tr>
<tr>
<td>文本删除线</td>
<td>Alt+Shift+5</td>
</tr>
<tr>
<td>斜体</td>
<td>Ctrl+I</td>
</tr>
<tr>
<td>标记为代码</td>
<td>Ctrl+Shift+5</td>
</tr>
<tr>
<td>插入超链接</td>
<td>Ctrl+K</td>
</tr>
<tr>
<td>插入图片链接</td>
<td>Ctrl+Shift+I</td>
</tr>
<tr>
<td>消除文本格式</td>
<td>Ctrl+\</td>
</tr>
<tr>
<td>切换侧边栏</td>
<td>Ctrl+Shift+L</td>
</tr>
<tr>
<td>切换成出大纲</td>
<td>Ctrl+Shift+1</td>
</tr>
<tr>
<td>切换到文件栏</td>
<td>Ctrl+Shift+2</td>
</tr>
<tr>
<td>展示文件目录</td>
<td>Ctrl+Shift+3</td>
</tr>
<tr>
<td>切换成源码格式（Markdown）</td>
<td>Ctrl+&#x2F;</td>
</tr>
<tr>
<td>专注模式</td>
<td>F8</td>
</tr>
<tr>
<td>打字机模式</td>
<td>F9</td>
</tr>
<tr>
<td>全屏模式</td>
<td>F11</td>
</tr>
<tr>
<td>扩大</td>
<td>Ctrl+Shift+&#x3D;</td>
</tr>
<tr>
<td>缩小</td>
<td>Ctrl+Shift±</td>
</tr>
<tr>
<td>重置大小（好像windows有快捷键冲突）</td>
<td>Ctrl+Shift+0</td>
</tr>
<tr>
<td>在两个打开的文件进行切换</td>
<td>Ctrl+Tab</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github+picgo部署博客</title>
    <url>/2025/01/23/hexo-github-%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="2025年12月28日"><a href="#2025年12月28日" class="headerlink" title="2025年12月28日"></a>2025年12月28日</h4><h3 id="GitHub-个人令牌失效：重新生成"><a href="#GitHub-个人令牌失效：重新生成" class="headerlink" title="GitHub 个人令牌失效：重新生成"></a>GitHub 个人令牌失效：重新生成</h3><p>在 GitHub 官网重新生成个人访问令牌，生成「经典」个人访问令牌。</p>
<ol>
<li>访问经典令牌生成页：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></li>
<li>点击右上角「<strong>Generate new token</strong>」→ 选择「**Generate new token (classic)**」</li>
<li>配置项：填写令牌名称、有效期，勾选核心权限 <code>repo</code>（仓库所有操作权限）</li>
<li>点击底部「<strong>Generate token</strong>」，<strong>立即复制令牌</strong>并保存。</li>
<li>然后把令牌复制到picgo的图床设置即可。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/202512281505382.png"></p>
<h2 id="Picgo同步删除图片的插件"><a href="#Picgo同步删除图片的插件" class="headerlink" title="Picgo同步删除图片的插件"></a>Picgo同步删除图片的插件</h2><p><strong>下载链接</strong>：<a href="https://github.com/Molunerfinn/picgo/releases">Releases · Molunerfinn&#x2F;PicGo</a></p>
<p>最终下载版本PicGo-Setup-2.4.0-x64.exe</p>
<p>在该版本内搜索 github-plus 插件并安装：github-plus 1.2.3</p>
<p><img src="/hexo-github-%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2.assets/image-20251228153737427.png"></p>
<p>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo 你的仓库名</span><br><span class="line">brach分支，默认 master</span><br><span class="line">token 就是在GitHub生成的个人令牌</span><br><span class="line">path 路径，例如:我填写 img，我的仓库中就会有一个img的文件夹存放我的图片</span><br><span class="line">customUrl 自定义url，由于GitHub在国内的访问速度比较慢可以使用jsdelivr 进行cdn加速，格式一般为:https://cdn.isdelivr.netlgh/user/repo@version/file</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/ImageBed@main/image/20251228154812360.png"></p>
<hr>
<h4 id="2025年1月23日"><a href="#2025年1月23日" class="headerlink" title="2025年1月23日"></a>2025年1月23日</h4><p>静态博客：是指没有后端数据库的博客，所有文章都是以文件的形式存储，是一种纯前端的博客框架。</p>
<h1 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a><strong>一、准备工具</strong></h1><p>Hexo是通过Node.js生成的。</p>
<h2 id="1-下载并安装Node-js"><a href="#1-下载并安装Node-js" class="headerlink" title="1.下载并安装Node.js"></a><strong>1.下载并安装Node.js</strong></h2><p>win+R  #进入终端</p>
<p>node -v  #查看node版本，v20.18.0，显示版本号，则说明安装成功</p>
<h2 id="2-安装Hexo框架"><a href="#2-安装Hexo框架" class="headerlink" title="2.安装Hexo框架"></a><strong>2.安装Hexo框架</strong></h2><p>Node.js的包管理器，称为npm。</p>
<p>发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。</p>
<p>win+R进入终端</p>
<p>npm -v  #查看npm版本，11.0.0</p>
<p>由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过cnpm来操作下载速度会得到很大提升，但包的版本不一定是最新的。</p>
<p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>  #通过npm安装cnpm</p>
<p>cnpm -v  #查看cnpm版本</p>
<p>npm install -g hexo-cli  #安装hexo框架</p>
<p>hexo -v  #查看版本</p>
<h2 id="3-安装git工具"><a href="#3-安装git工具" class="headerlink" title="3.安装git工具"></a><strong>3.安装git工具</strong></h2><p>下载网址<a href="https://git-scm.com/downloads/win">https://git-scm.com/downloads/win</a></p>
<p>安装版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224192736510.png" alt="安装版本号"></p>
<p>配置用户名和邮箱</p>
<p>很重要，因为每一个都会使用这些信息，它们会写入道每一次提交中，不可更改。</p>
<p>签名的作用是区分操作者的身份，用户的签名信息在每一个版本的提交信息能够看到，以此确认本次提交的是谁做的。Git首次安装必须设置一下用户签名，否则无法提交代码。这里设置用户签名和将来登录GitLab（或者其他代码托管中心）的账号没有任何关系。</p>
<p>在桌面任意位置右键，点击Git bash here，在弹出界面中输入</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-24%20200214.jpg"></p>
<p>输入git config –global –list 命令，检查配置好没有</p>
<p>安装完成后，确保将 git 的可执行文件所在的目录添加到系统的环境变量中。</p>
<p>安装路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200256455.png"></p>
<p>设置环境变量</p>
<p>系统变量中Path，编辑E:\git\Git\cmd</p>
<h1 id="二、搭建仓库"><a href="#二、搭建仓库" class="headerlink" title="二、搭建仓库"></a><strong>二、搭建仓库</strong></h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a><strong>github</strong></h2><h3 id="1-搭建仓库"><a href="#1-搭建仓库" class="headerlink" title="1.搭建仓库"></a><strong>1.搭建仓库</strong></h3><p>在<a href="https://github.com/%E7%BD%91%E5%9D%80%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7">https://github.com/网址准备一个账号</a></p>
<p>新建一个仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200319395.png"></p>
<p>仓库名（Repository name）是要和github的名字一样，例如github名字叫aaa，仓库名字就必须是aaa.github.io，不能是bbb.github.io之类的。</p>
<p>Repository name ： tangxtang1119.github.io</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/image-20250224200335806.png"></p>
<p>勾选Public和Add a README file</p>
<p>然后点击创建Create repository</p>
<h1 id="三、配置ssh-key"><a href="#三、配置ssh-key" class="headerlink" title="三、配置ssh key"></a><strong>三、配置ssh key</strong></h1><h2 id="github-1"><a href="#github-1" class="headerlink" title="github"></a><strong>github</strong></h2><h4 id="1-生成SSH-Keys"><a href="#1-生成SSH-Keys" class="headerlink" title="1.生成SSH Keys"></a><strong>1.生成SSH Keys</strong></h4><p>进入任意文件夹，右键空白处然后点Git bash here,输入</p>
<p>ssh-keygen -t rsa -C “邮件地址”（注意是大写C）</p>
<p>生成SSH Keys</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps3.jpg"> </p>
<p>连续敲4次Enter</p>
<p>然后进入C:\Users\tangxtang.ssh，用记事本打开id_rsa.pub，全选复制这串代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps4.jpg"> </p>
<p>id_rsa ：私钥文件</p>
<p>id_rsa.pub：公钥文件</p>
<p>打开github</p>
<p>进入用户设置，找到SSH and GPG keys</p>
<p>选择New SSH Key新建SSH keys，名称随意，在下面粘贴代码</p>
<p>然后创建</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps5.jpg"> </p>
<h4 id="2-测试SSH-Key配置"><a href="#2-测试SSH-Key配置" class="headerlink" title="2.测试SSH Key配置"></a><strong>2.测试SSH Key配置</strong></h4><p>在git bash 输入</p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p>
<p>最后提示ssh: connect to host github.com port 22: Connection refused这个错误提示的是连接github.com，访问<a href="https://zhida.zhihu.com/search?content_id=203985854&content_type=Article&match_order=1&q=22%E7%AB%AF%E5%8F%A3&zhida_source=entity">22端口</a>被拒绝了。</p>
<p>尝试连接github的443端口，在C:\Users\tangxtang.ssh\config文件里新建记事本，添加以下内容：</p>
<p>Host github.com</p>
<pre><code> Hostname ssh.github.com
</code></pre>
<p> Port 443</p>
<p>如果没有config文件就新建一个即可。</p>
<p>如果执行命令ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>，还是报错，就执行命令</p>
<p>ssh -T -p 443 <a href="mailto:git@ssh.github.com，">git@ssh.github.com</a></p>
<p>如果提示Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide <a href="https://zhida.zhihu.com/search?content_id=203985854&content_type=Article&match_order=2&q=shell+access&zhida_source=entity">shell access</a>. 就表示一切正常了。</p>
<h1 id="四、本地部署"><a href="#四、本地部署" class="headerlink" title="四、本地部署"></a><strong>四、本地部署</strong></h1><h4 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="1.创建目录"></a><strong>1.创建目录</strong></h4><p>由于Hexo的所有文章都是以文件的形式存储在目录下的，</p>
<p>新建一个目录，文件名设置为first-blog，再次目录下继续操作。路径：</p>
<p>E:\myself\self-blog\first-blog</p>
<h4 id="2-初始化博客"><a href="#2-初始化博客" class="headerlink" title="2.初始化博客"></a><strong>2.初始化博客</strong></h4><p>hexo init</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps6.jpg"> </p>
<h4 id="3-新建文章"><a href="#3-新建文章" class="headerlink" title="3.新建文章"></a><strong>3.新建文章</strong></h4><p>hexo new  “BlogName”（BlogName是你的文章名称）</p>
<p>会在source&#x2F;_posts目录下生成BlogName.md文件，可以vim或其他的Markdown编辑器进行修改。</p>
<h4 id="4-生成博客静态文件"><a href="#4-生成博客静态文件" class="headerlink" title="4.生成博客静态文件"></a><strong>4.生成博客静态文件</strong></h4><p>hexo g（g表示generate），生成博客静态文件</p>
<p>每次修改文章后。都需要通过hexo clean清理一下</p>
<p>然后通过hexo g重新生成</p>
<p>最后也不要忘了通过hexo s重新启动Hexo</p>
<h4 id="5-启动博客"><a href="#5-启动博客" class="headerlink" title="5.启动博客"></a><strong>5.启动博客</strong></h4><p>hexo s（s代表server，默认端口号是4000）</p>
<h1 id="四、如何让把个人博客部署到远端"><a href="#四、如何让把个人博客部署到远端" class="headerlink" title="四、如何让把个人博客部署到远端"></a><strong>四、如何让把个人博客部署到远端</strong></h1><p>进入博客文件夹，用记事本打开——config.yml</p>
<p>拉到最后将deploy后面的全删掉，复制粘贴以下这段：</p>
<p> type: git</p>
<p> repository:</p>
<p> branch: main</p>
<p>注意缩进格式：每行前面都有两个空格不要删了，每个冒号后面都有个空格也不要删</p>
<p>去GitHub之前生成的仓库页面，点击code，复制https链接</p>
<p>将其粘贴到记事本中的repository：后面</p>
<p>然后保存退出</p>
<p>回到博客文件夹，git bash</p>
<p>安装自动部署发布工具</p>
<p>npm install hexo-deployer-git –save</p>
<p>执行命令时报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangxtang1119/Pictures@master/wps7.jpg"> </p>
<p>尝试方法：</p>
<p>cnpm install hexo-deployer-git –save</p>
<p>（cnpm会创建文件夹的引用，而npm不会，具体原因不明白）</p>
<p>更改后，上传出现报错</p>
<h4 id="解决报错的地方就是22端口问题，就是连接超时。"><a href="#解决报错的地方就是22端口问题，就是连接超时。" class="headerlink" title="解决报错的地方就是22端口问题，就是连接超时。"></a><strong>解决报错的地方就是22端口问题，就是连接超时。</strong></h4><p>解决办法：</p>
<p>手动修改hosts文件修改访问github.com的IP地址</p>
<h5 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a><strong>修改hosts文件</strong></h5><p>文件位置C:\Windows\System32\drivers\etc\hosts，修改用户权限，开放修改和写入的权限，再编辑hosts文件。添加github.com的IP地址和域名。如下：</p>
<p>140.82.112.3    github.com</p>
<p>151.101.1.194    github.global.ssl.fastly.net</p>
<p>151.101.65.194   github.global.ssl.fastly.net</p>
<p>151.101.129.194   github.global.ssl.fastly.net</p>
<p>151.101.193.194   github.global.ssl.fastly.net</p>
<p>185.199.108.153   assets-cdn.github.com</p>
<p>185.199.109.153   assets-cdn.github.com</p>
<p>185.199.110.153   assets-cdn.github.com</p>
<p>185.199.111.153   assets-cdn.github.com</p>
<h5 id="刷新DNS解析缓存并验证"><a href="#刷新DNS解析缓存并验证" class="headerlink" title="刷新DNS解析缓存并验证"></a><strong>刷新DNS解析缓存并验证</strong></h5><p>在我们访问一个域名（网址）时，系统首先会从本地DNS缓存中读取该域名所对应的IP地址。如果系统无法在DNS缓存中找到对应的IP地址，则去查询DNS服务器，获取该域名的解析结果，并将解析结果缓存到本地DNS缓存中，以便下次访问该域名时可以快速地获取IP地址。</p>
<p>1.刷新DNS解析缓存</p>
<p>ipconfig &#x2F;flushdns命令可以清除所有的DNS缓存，让系统重新去查询DNS服务器，获取最新的解析结果。</p>
<ol start="2">
<li>验证</li>
</ol>
<p>在浏览器中输入网址：github.com，成功访问</p>
<h1 id="五、如何给个人博客更换主题"><a href="#五、如何给个人博客更换主题" class="headerlink" title="五、如何给个人博客更换主题"></a><strong>五、如何给个人博客更换主题</strong></h1><h4 id="GitHub-克隆仓库"><a href="#GitHub-克隆仓库" class="headerlink" title="GitHub 克隆仓库"></a><a href="https://so.csdn.net/so/search?q=GitHub&spm=1001.2101.3001.7020"><strong>GitHub</strong></a> <strong>克隆仓库</strong></h4><p>国内直接从 <a href="https://so.csdn.net/so/search?q=GitHub&spm=1001.2101.3001.7020">GitHub</a> 克隆仓库的速度可能非常慢容易失败，影响开发效率。本文将分享几种加速 git clone 的方法，显著提升克隆速度。</p>
<p>方法：使用 ghproxy 代理服务(推荐)</p>
<p>ghproxy 是一个 GitHub 镜像代理服务，它会将你的请求先发送到代理服务器，然后由代理服务器快速地从 GitHub 获取数据，并返回给你。这种方式能够显著提升 git clone 的速度。</p>
<p>在<a href="https://hexo.io/themes/%E5%AE%98%E7%BD%91%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2">https://hexo.io/themes/官网选择自己喜欢的主题更换</a></p>
<p>使用 ghproxy 代理进行 git clone</p>
<p>通过以下命令使用 ghproxy 代理来加速克隆操作：</p>
<p>git clone <a href="https://mirror.ghproxy.com/https://github.com/USERNAME/REPOSITORY">https://mirror.ghproxy.com/https://github.com/USERNAME/REPOSITORY</a></p>
<p>例如，克隆一个名为 dockerfiles 的仓库，可以使用如下命令：</p>
<p>git clone <a href="https://mirror.ghproxy.com/https:/github.com/stilleshan/dockerfiles">https://mirror.ghproxy.com/https://github.com/stilleshan/dockerfiles</a></p>
<p>下载后把文件移动到themes文件夹中。</p>
<p>解决部署到 Github Page 后无 CSS 样式的问题</p>
<p>方法很简单，在 hexo 根目录下 _config.yml配置文件中，找到对 URL 部分的配置，其他配置选项不动，仅修改 url 选项，如下：</p>
<p># URL</p>
<p>##Set your site url here. For example, if you use GitHub Page, set url as ‘<a href="https://username.github.io/project">https://username.github.io/project</a>‘</p>
<p>url: <a href="https://eternaldeath.github.io/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D/">https://eternaldeath.github.io/你的仓库名/</a></p>
<p>url 放置完整的路径，如果你是在 Github Page 上部署自己的博客，那么则无需添加“你的仓库名”部分，如果你是对某个仓库创建的 Github Page，则需要加上你的仓库名</p>
<h4 id="创建页面（导航栏列表项）"><a href="#创建页面（导航栏列表项）" class="headerlink" title="创建页面（导航栏列表项）"></a><strong>创建页面（导航栏列表项）</strong></h4><p>列表项名：类别 </p>
<p>hexo new page categories </p>
<p>然后将以下代码粘贴到文件中：</p>
<p>&#x2F;source&#x2F;categories&#x2F;index.md </p>
<p>-–</p>
<p>title: categories </p>
<p>type: categories </p>
<p>layout: “categories” </p>
<p>-–</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
